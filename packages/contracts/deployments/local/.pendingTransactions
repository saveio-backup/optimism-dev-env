{
  "0x887351cf7bbb89690df28e3b83f53079dac83e9286289db01c26b918aef26c9e": {
    "name": "ChainStorageContainer-CTC-batches",
    "deployment": {
      "_format": "hh-sol-artifact-1",
      "contractName": "ChainStorageContainer",
      "sourceName": "contracts/L1/rollup/ChainStorageContainer.sol",
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_libAddressManager",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "_owner",
              "type": "string"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "constructor"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_index",
              "type": "uint256"
            },
            {
              "internalType": "bytes27",
              "name": "_globalMetadata",
              "type": "bytes27"
            }
          ],
          "name": "deleteElementsAfterInclusive",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_index",
              "type": "uint256"
            }
          ],
          "name": "deleteElementsAfterInclusive",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_index",
              "type": "uint256"
            }
          ],
          "name": "get",
          "outputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "getGlobalMetadata",
          "outputs": [
            {
              "internalType": "bytes27",
              "name": "",
              "type": "bytes27"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "length",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "libAddressManager",
          "outputs": [
            {
              "internalType": "contract Lib_AddressManager",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "owner",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "_object",
              "type": "bytes32"
            },
            {
              "internalType": "bytes27",
              "name": "_globalMetadata",
              "type": "bytes27"
            }
          ],
          "name": "push",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "_object",
              "type": "bytes32"
            }
          ],
          "name": "push",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "_name",
              "type": "string"
            }
          ],
          "name": "resolve",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes27",
              "name": "_globalMetadata",
              "type": "bytes27"
            }
          ],
          "name": "setGlobalMetadata",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        }
      ],
      "bytecode": "0x60806040523480156200001157600080fd5b50604051620011b3380380620011b3833981016040819052620000349162000129565b600080546001600160a01b0319166001600160a01b0384161790558051620000649060019060208401906200006d565b50505062000266565b8280546200007b9062000229565b90600052602060002090601f0160209004810192826200009f5760008555620000ea565b82601f10620000ba57805160ff1916838001178555620000ea565b82800160010185558215620000ea579182015b82811115620000ea578251825591602001919060010190620000cd565b50620000f8929150620000fc565b5090565b5b80821115620000f85760008155600101620000fd565b634e487b7160e01b600052604160045260246000fd5b600080604083850312156200013d57600080fd5b82516001600160a01b03811681146200015557600080fd5b602084810151919350906001600160401b03808211156200017557600080fd5b818601915086601f8301126200018a57600080fd5b8151818111156200019f576200019f62000113565b604051601f8201601f19908116603f01168101908382118183101715620001ca57620001ca62000113565b816040528281528986848701011115620001e357600080fd5b600093505b82841015620002075784840186015181850187015292850192620001e8565b82841115620002195760008684830101525b8096505050505050509250929050565b600181811c908216806200023e57607f821691505b602082108114156200026057634e487b7160e01b600052602260045260246000fd5b50919050565b610f3d80620002766000396000f3fe608060405234801561001057600080fd5b50600436106100c95760003560e01c8063461a4478116100815780639507d39a1161005b5780639507d39a146101a4578063b298e36b146101b7578063ccf8f969146101ca57600080fd5b8063461a4478146101695780634651d91e1461017c5780638da5cb5b1461018f57600080fd5b80632015276c116100b25780632015276c146100fe57806329061de214610111578063299ca4781461012457600080fd5b8063167fd681146100ce5780631f7b6d32146100e3575b600080fd5b6100e16100dc366004610c59565b6101e9565b005b6100eb61034d565b6040519081526020015b60405180910390f35b6100e161010c366004610c59565b610365565b6100e161011f366004610c85565b61043d565b6000546101449073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100f5565b610144610177366004610cd6565b610517565b6100e161018a366004610da5565b6105c4565b61019761069b565b6040516100f59190610dbe565b6100eb6101b2366004610da5565b610729565b6100e16101c5366004610da5565b61073d565b6101d2610814565b60405164ffffffffff1990911681526020016100f5565b61027c600180546101f990610e31565b80601f016020809104026020016040519081016040528092919081815260200182805461022590610e31565b80156102725780601f1061024757610100808354040283529160200191610272565b820191906000526020600020905b81548152906001019060200180831161025557829003601f168201915b5050505050610517565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461033d57604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e60648201526084015b60405180910390fd5b61034960028383610825565b5050565b6000610359600261090c565b64ffffffffff16905090565b610375600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461043157604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b61034960028383610957565b61044d600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461050957604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b6105146002826109e6565b50565b600080546040517fbf40fac100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091169063bf40fac19061056e908590600401610dbe565b60206040518083038186803b15801561058657600080fd5b505afa15801561059a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105be9190610e85565b92915050565b6105d4600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461069057604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b610514600282610a47565b600180546106a890610e31565b80601f01602080910402602001604051908101604052809291908181526020018280546106d490610e31565b80156107215780601f106106f657610100808354040283529160200191610721565b820191906000526020600020905b81548152906001019060200180831161070457829003601f168201915b505050505081565b60006105be600264ffffffffff8416610aa4565b61074d600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461080957604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b610514600282610b73565b60006108206002610bd0565b905090565b600061086784604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b9050806000015164ffffffffff168364ffffffffff16106108e4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f496e646578206f7574206f6620626f756e64732e0000000000000000000000006044820152606401610334565b64ffffffffff8316815264ffffffffff19821660208201526109068482610c1e565b50505050565b60008061094f83604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b519392505050565b600061099984604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b805164ffffffffff16600090815260018601602052604090208490558051909150816109c482610ebb565b64ffffffffff1690525064ffffffffff19821660208201526109068482610c1e565b6000610a2883604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b64ffffffffff19831660208201529050610a428382610c1e565b505050565b6000610a8983604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b9050610a42828260200151856108259092919063ffffffff16565b600080610ae784604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b805190915064ffffffffff168310610b5b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f496e646578206f7574206f6620626f756e64732e0000000000000000000000006044820152606401610334565b50506000908152600191909101602052604090205490565b6000610bb583604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b9050610a42828260200151856109579092919063ffffffff16565b600080610c1383604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b602001519392505050565b8051602082015183548183179291908314610c37578285555b5050505050565b803564ffffffffff1981168114610c5457600080fd5b919050565b60008060408385031215610c6c57600080fd5b82359150610c7c60208401610c3e565b90509250929050565b600060208284031215610c9757600080fd5b610ca082610c3e565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208284031215610ce857600080fd5b813567ffffffffffffffff80821115610d0057600080fd5b818401915084601f830112610d1457600080fd5b813581811115610d2657610d26610ca7565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715610d6c57610d6c610ca7565b81604052828152876020848701011115610d8557600080fd5b826020860160208301376000928101602001929092525095945050505050565b600060208284031215610db757600080fd5b5035919050565b600060208083528351808285015260005b81811015610deb57858101830151858201604001528201610dcf565b81811115610dfd576000604083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016929092016040019392505050565b600181811c90821680610e4557607f821691505b60208210811415610e7f577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b600060208284031215610e9757600080fd5b815173ffffffffffffffffffffffffffffffffffffffff81168114610ca057600080fd5b600064ffffffffff80831681811415610efd577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600101939250505056fea2646970667358221220e1995ee56c4c5e67de41c56ad510b16704727d3ab1fa5bb2e3c62b0bd7c0597564736f6c63430008090033",
      "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100c95760003560e01c8063461a4478116100815780639507d39a1161005b5780639507d39a146101a4578063b298e36b146101b7578063ccf8f969146101ca57600080fd5b8063461a4478146101695780634651d91e1461017c5780638da5cb5b1461018f57600080fd5b80632015276c116100b25780632015276c146100fe57806329061de214610111578063299ca4781461012457600080fd5b8063167fd681146100ce5780631f7b6d32146100e3575b600080fd5b6100e16100dc366004610c59565b6101e9565b005b6100eb61034d565b6040519081526020015b60405180910390f35b6100e161010c366004610c59565b610365565b6100e161011f366004610c85565b61043d565b6000546101449073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100f5565b610144610177366004610cd6565b610517565b6100e161018a366004610da5565b6105c4565b61019761069b565b6040516100f59190610dbe565b6100eb6101b2366004610da5565b610729565b6100e16101c5366004610da5565b61073d565b6101d2610814565b60405164ffffffffff1990911681526020016100f5565b61027c600180546101f990610e31565b80601f016020809104026020016040519081016040528092919081815260200182805461022590610e31565b80156102725780601f1061024757610100808354040283529160200191610272565b820191906000526020600020905b81548152906001019060200180831161025557829003601f168201915b5050505050610517565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461033d57604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e60648201526084015b60405180910390fd5b61034960028383610825565b5050565b6000610359600261090c565b64ffffffffff16905090565b610375600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461043157604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b61034960028383610957565b61044d600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461050957604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b6105146002826109e6565b50565b600080546040517fbf40fac100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091169063bf40fac19061056e908590600401610dbe565b60206040518083038186803b15801561058657600080fd5b505afa15801561059a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105be9190610e85565b92915050565b6105d4600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461069057604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b610514600282610a47565b600180546106a890610e31565b80601f01602080910402602001604051908101604052809291908181526020018280546106d490610e31565b80156107215780601f106106f657610100808354040283529160200191610721565b820191906000526020600020905b81548152906001019060200180831161070457829003601f168201915b505050505081565b60006105be600264ffffffffff8416610aa4565b61074d600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461080957604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b610514600282610b73565b60006108206002610bd0565b905090565b600061086784604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b9050806000015164ffffffffff168364ffffffffff16106108e4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f496e646578206f7574206f6620626f756e64732e0000000000000000000000006044820152606401610334565b64ffffffffff8316815264ffffffffff19821660208201526109068482610c1e565b50505050565b60008061094f83604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b519392505050565b600061099984604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b805164ffffffffff16600090815260018601602052604090208490558051909150816109c482610ebb565b64ffffffffff1690525064ffffffffff19821660208201526109068482610c1e565b6000610a2883604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b64ffffffffff19831660208201529050610a428382610c1e565b505050565b6000610a8983604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b9050610a42828260200151856108259092919063ffffffff16565b600080610ae784604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b805190915064ffffffffff168310610b5b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f496e646578206f7574206f6620626f756e64732e0000000000000000000000006044820152606401610334565b50506000908152600191909101602052604090205490565b6000610bb583604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b9050610a42828260200151856109579092919063ffffffff16565b600080610c1383604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b602001519392505050565b8051602082015183548183179291908314610c37578285555b5050505050565b803564ffffffffff1981168114610c5457600080fd5b919050565b60008060408385031215610c6c57600080fd5b82359150610c7c60208401610c3e565b90509250929050565b600060208284031215610c9757600080fd5b610ca082610c3e565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208284031215610ce857600080fd5b813567ffffffffffffffff80821115610d0057600080fd5b818401915084601f830112610d1457600080fd5b813581811115610d2657610d26610ca7565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715610d6c57610d6c610ca7565b81604052828152876020848701011115610d8557600080fd5b826020860160208301376000928101602001929092525095945050505050565b600060208284031215610db757600080fd5b5035919050565b600060208083528351808285015260005b81811015610deb57858101830151858201604001528201610dcf565b81811115610dfd576000604083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016929092016040019392505050565b600181811c90821680610e4557607f821691505b60208210811415610e7f577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b600060208284031215610e9757600080fd5b815173ffffffffffffffffffffffffffffffffffffffff81168114610ca057600080fd5b600064ffffffffff80831681811415610efd577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600101939250505056fea2646970667358221220e1995ee56c4c5e67de41c56ad510b16704727d3ab1fa5bb2e3c62b0bd7c0597564736f6c63430008090033",
      "linkReferences": {},
      "deployedLinkReferences": {},
      "devdoc": {
        "details": "The Chain Storage Container provides its owner contract with read, write and delete functionality. This provides gas efficiency gains by enabling it to overwrite storage slots which can no longer be used in a fraud proof due to the fraud window having passed, and the associated chain state or transactions being finalized. Three distinct Chain Storage Containers will be deployed on Layer 1: 1. Stores transaction batches for the Canonical Transaction Chain 2. Stores queued transactions for the Canonical Transaction Chain 3. Stores chain state batches for the State Commitment Chain",
        "kind": "dev",
        "methods": {
          "constructor": {
            "params": {
              "_libAddressManager": "Address of the Address Manager.",
              "_owner": "Name of the contract that owns this container (will be resolved later)."
            }
          },
          "deleteElementsAfterInclusive(uint256)": {
            "params": {
              "_index": "Object index to delete from."
            }
          },
          "deleteElementsAfterInclusive(uint256,bytes27)": {
            "params": {
              "_globalMetadata": "New global metadata for the container.",
              "_index": "Object index to delete from."
            }
          },
          "get(uint256)": {
            "params": {
              "_index": "Index of the particular object to access."
            },
            "returns": {
              "_0": "32 byte object value."
            }
          },
          "getGlobalMetadata()": {
            "returns": {
              "_0": "Container global metadata field."
            }
          },
          "length()": {
            "returns": {
              "_0": "Number of objects in the container."
            }
          },
          "push(bytes32)": {
            "params": {
              "_object": "A 32 byte value to insert into the container."
            }
          },
          "push(bytes32,bytes27)": {
            "params": {
              "_globalMetadata": "New global metadata for the container.",
              "_object": "A 32 byte value to insert into the container."
            }
          },
          "resolve(string)": {
            "params": {
              "_name": "Name to resolve an address for."
            },
            "returns": {
              "_0": "Address associated with the given name."
            }
          },
          "setGlobalMetadata(bytes27)": {
            "params": {
              "_globalMetadata": "New global metadata to set."
            }
          }
        },
        "title": "ChainStorageContainer",
        "version": 1
      },
      "evm": {
        "bytecode": {
          "functionDebugData": {
            "@_4221": {
              "entryPoint": null,
              "id": 4221,
              "parameterSlots": 2,
              "returnSlots": 0
            },
            "@_7672": {
              "entryPoint": null,
              "id": 7672,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "abi_decode_tuple_t_addresst_string_memory_ptr_fromMemory": {
              "entryPoint": 297,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 2
            },
            "extract_byte_array_length": {
              "entryPoint": 553,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "panic_error_0x41": {
              "entryPoint": 275,
              "id": null,
              "parameterSlots": 0,
              "returnSlots": 0
            }
          },
          "generatedSources": [
            {
              "ast": {
                "nodeType": "YulBlock",
                "src": "0:1787:78",
                "statements": [
                  {
                    "nodeType": "YulBlock",
                    "src": "6:3:78",
                    "statements": []
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "46:95:78",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "63:1:78",
                                "type": "",
                                "value": "0"
                              },
                              {
                                "arguments": [
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "70:3:78",
                                    "type": "",
                                    "value": "224"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "75:10:78",
                                    "type": "",
                                    "value": "0x4e487b71"
                                  }
                                ],
                                "functionName": {
                                  "name": "shl",
                                  "nodeType": "YulIdentifier",
                                  "src": "66:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "66:20:78"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "56:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "56:31:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "56:31:78"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "103:1:78",
                                "type": "",
                                "value": "4"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "106:4:78",
                                "type": "",
                                "value": "0x41"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "96:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "96:15:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "96:15:78"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "127:1:78",
                                "type": "",
                                "value": "0"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "130:4:78",
                                "type": "",
                                "value": "0x24"
                              }
                            ],
                            "functionName": {
                              "name": "revert",
                              "nodeType": "YulIdentifier",
                              "src": "120:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "120:15:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "120:15:78"
                        }
                      ]
                    },
                    "name": "panic_error_0x41",
                    "nodeType": "YulFunctionDefinition",
                    "src": "14:127:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "254:1146:78",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "300:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "309:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "312:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "302:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "302:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "302:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "275:7:78"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "284:9:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "271:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "271:23:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "296:2:78",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "267:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "267:32:78"
                          },
                          "nodeType": "YulIf",
                          "src": "264:52:78"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "325:29:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "344:9:78"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "338:5:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "338:16:78"
                          },
                          "variables": [
                            {
                              "name": "value",
                              "nodeType": "YulTypedName",
                              "src": "329:5:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "417:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "426:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "429:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "419:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "419:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "419:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "376:5:78"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "value",
                                        "nodeType": "YulIdentifier",
                                        "src": "387:5:78"
                                      },
                                      {
                                        "arguments": [
                                          {
                                            "arguments": [
                                              {
                                                "kind": "number",
                                                "nodeType": "YulLiteral",
                                                "src": "402:3:78",
                                                "type": "",
                                                "value": "160"
                                              },
                                              {
                                                "kind": "number",
                                                "nodeType": "YulLiteral",
                                                "src": "407:1:78",
                                                "type": "",
                                                "value": "1"
                                              }
                                            ],
                                            "functionName": {
                                              "name": "shl",
                                              "nodeType": "YulIdentifier",
                                              "src": "398:3:78"
                                            },
                                            "nodeType": "YulFunctionCall",
                                            "src": "398:11:78"
                                          },
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "411:1:78",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "sub",
                                          "nodeType": "YulIdentifier",
                                          "src": "394:3:78"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "394:19:78"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "and",
                                      "nodeType": "YulIdentifier",
                                      "src": "383:3:78"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "383:31:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "eq",
                                  "nodeType": "YulIdentifier",
                                  "src": "373:2:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "373:42:78"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "366:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "366:50:78"
                          },
                          "nodeType": "YulIf",
                          "src": "363:70:78"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "442:15:78",
                          "value": {
                            "name": "value",
                            "nodeType": "YulIdentifier",
                            "src": "452:5:78"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "442:6:78"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "466:12:78",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "476:2:78",
                            "type": "",
                            "value": "32"
                          },
                          "variables": [
                            {
                              "name": "_1",
                              "nodeType": "YulTypedName",
                              "src": "470:2:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "487:39:78",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "511:9:78"
                                  },
                                  {
                                    "name": "_1",
                                    "nodeType": "YulIdentifier",
                                    "src": "522:2:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "507:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "507:18:78"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "501:5:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "501:25:78"
                          },
                          "variables": [
                            {
                              "name": "offset",
                              "nodeType": "YulTypedName",
                              "src": "491:6:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "535:28:78",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "553:2:78",
                                    "type": "",
                                    "value": "64"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "557:1:78",
                                    "type": "",
                                    "value": "1"
                                  }
                                ],
                                "functionName": {
                                  "name": "shl",
                                  "nodeType": "YulIdentifier",
                                  "src": "549:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "549:10:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "561:1:78",
                                "type": "",
                                "value": "1"
                              }
                            ],
                            "functionName": {
                              "name": "sub",
                              "nodeType": "YulIdentifier",
                              "src": "545:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "545:18:78"
                          },
                          "variables": [
                            {
                              "name": "_2",
                              "nodeType": "YulTypedName",
                              "src": "539:2:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "590:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "599:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "602:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "592:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "592:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "592:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "offset",
                                "nodeType": "YulIdentifier",
                                "src": "578:6:78"
                              },
                              {
                                "name": "_2",
                                "nodeType": "YulIdentifier",
                                "src": "586:2:78"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "575:2:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "575:14:78"
                          },
                          "nodeType": "YulIf",
                          "src": "572:34:78"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "615:32:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "629:9:78"
                              },
                              {
                                "name": "offset",
                                "nodeType": "YulIdentifier",
                                "src": "640:6:78"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "625:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "625:22:78"
                          },
                          "variables": [
                            {
                              "name": "_3",
                              "nodeType": "YulTypedName",
                              "src": "619:2:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "695:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "704:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "707:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "697:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "697:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "697:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "name": "_3",
                                        "nodeType": "YulIdentifier",
                                        "src": "674:2:78"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "678:4:78",
                                        "type": "",
                                        "value": "0x1f"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "add",
                                      "nodeType": "YulIdentifier",
                                      "src": "670:3:78"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "670:13:78"
                                  },
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "685:7:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "slt",
                                  "nodeType": "YulIdentifier",
                                  "src": "666:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "666:27:78"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "659:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "659:35:78"
                          },
                          "nodeType": "YulIf",
                          "src": "656:55:78"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "720:19:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "_3",
                                "nodeType": "YulIdentifier",
                                "src": "736:2:78"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "730:5:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "730:9:78"
                          },
                          "variables": [
                            {
                              "name": "_4",
                              "nodeType": "YulTypedName",
                              "src": "724:2:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "762:22:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "panic_error_0x41",
                                    "nodeType": "YulIdentifier",
                                    "src": "764:16:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "764:18:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "764:18:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "_4",
                                "nodeType": "YulIdentifier",
                                "src": "754:2:78"
                              },
                              {
                                "name": "_2",
                                "nodeType": "YulIdentifier",
                                "src": "758:2:78"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "751:2:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "751:10:78"
                          },
                          "nodeType": "YulIf",
                          "src": "748:36:78"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "793:17:78",
                          "value": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "807:2:78",
                                "type": "",
                                "value": "31"
                              }
                            ],
                            "functionName": {
                              "name": "not",
                              "nodeType": "YulIdentifier",
                              "src": "803:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "803:7:78"
                          },
                          "variables": [
                            {
                              "name": "_5",
                              "nodeType": "YulTypedName",
                              "src": "797:2:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "819:23:78",
                          "value": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "839:2:78",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "833:5:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "833:9:78"
                          },
                          "variables": [
                            {
                              "name": "memPtr",
                              "nodeType": "YulTypedName",
                              "src": "823:6:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "851:71:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "memPtr",
                                "nodeType": "YulIdentifier",
                                "src": "873:6:78"
                              },
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "arguments": [
                                              {
                                                "name": "_4",
                                                "nodeType": "YulIdentifier",
                                                "src": "897:2:78"
                                              },
                                              {
                                                "kind": "number",
                                                "nodeType": "YulLiteral",
                                                "src": "901:4:78",
                                                "type": "",
                                                "value": "0x1f"
                                              }
                                            ],
                                            "functionName": {
                                              "name": "add",
                                              "nodeType": "YulIdentifier",
                                              "src": "893:3:78"
                                            },
                                            "nodeType": "YulFunctionCall",
                                            "src": "893:13:78"
                                          },
                                          {
                                            "name": "_5",
                                            "nodeType": "YulIdentifier",
                                            "src": "908:2:78"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "and",
                                          "nodeType": "YulIdentifier",
                                          "src": "889:3:78"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "889:22:78"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "913:2:78",
                                        "type": "",
                                        "value": "63"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "add",
                                      "nodeType": "YulIdentifier",
                                      "src": "885:3:78"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "885:31:78"
                                  },
                                  {
                                    "name": "_5",
                                    "nodeType": "YulIdentifier",
                                    "src": "918:2:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "881:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "881:40:78"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "869:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "869:53:78"
                          },
                          "variables": [
                            {
                              "name": "newFreePtr",
                              "nodeType": "YulTypedName",
                              "src": "855:10:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "981:22:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "panic_error_0x41",
                                    "nodeType": "YulIdentifier",
                                    "src": "983:16:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "983:18:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "983:18:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "newFreePtr",
                                    "nodeType": "YulIdentifier",
                                    "src": "940:10:78"
                                  },
                                  {
                                    "name": "_2",
                                    "nodeType": "YulIdentifier",
                                    "src": "952:2:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "gt",
                                  "nodeType": "YulIdentifier",
                                  "src": "937:2:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "937:18:78"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "newFreePtr",
                                    "nodeType": "YulIdentifier",
                                    "src": "960:10:78"
                                  },
                                  {
                                    "name": "memPtr",
                                    "nodeType": "YulIdentifier",
                                    "src": "972:6:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "lt",
                                  "nodeType": "YulIdentifier",
                                  "src": "957:2:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "957:22:78"
                              }
                            ],
                            "functionName": {
                              "name": "or",
                              "nodeType": "YulIdentifier",
                              "src": "934:2:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "934:46:78"
                          },
                          "nodeType": "YulIf",
                          "src": "931:72:78"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1019:2:78",
                                "type": "",
                                "value": "64"
                              },
                              {
                                "name": "newFreePtr",
                                "nodeType": "YulIdentifier",
                                "src": "1023:10:78"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "1012:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1012:22:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1012:22:78"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "memPtr",
                                "nodeType": "YulIdentifier",
                                "src": "1050:6:78"
                              },
                              {
                                "name": "_4",
                                "nodeType": "YulIdentifier",
                                "src": "1058:2:78"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "1043:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1043:18:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1043:18:78"
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1107:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1116:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1119:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1109:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1109:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1109:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "name": "_3",
                                        "nodeType": "YulIdentifier",
                                        "src": "1084:2:78"
                                      },
                                      {
                                        "name": "_4",
                                        "nodeType": "YulIdentifier",
                                        "src": "1088:2:78"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "add",
                                      "nodeType": "YulIdentifier",
                                      "src": "1080:3:78"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "1080:11:78"
                                  },
                                  {
                                    "name": "_1",
                                    "nodeType": "YulIdentifier",
                                    "src": "1093:2:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "1076:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1076:20:78"
                              },
                              {
                                "name": "dataEnd",
                                "nodeType": "YulIdentifier",
                                "src": "1098:7:78"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "1073:2:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1073:33:78"
                          },
                          "nodeType": "YulIf",
                          "src": "1070:53:78"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "1132:10:78",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "1141:1:78",
                            "type": "",
                            "value": "0"
                          },
                          "variables": [
                            {
                              "name": "i",
                              "nodeType": "YulTypedName",
                              "src": "1136:1:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1197:83:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "arguments": [
                                        {
                                          "arguments": [
                                            {
                                              "name": "memPtr",
                                              "nodeType": "YulIdentifier",
                                              "src": "1226:6:78"
                                            },
                                            {
                                              "name": "i",
                                              "nodeType": "YulIdentifier",
                                              "src": "1234:1:78"
                                            }
                                          ],
                                          "functionName": {
                                            "name": "add",
                                            "nodeType": "YulIdentifier",
                                            "src": "1222:3:78"
                                          },
                                          "nodeType": "YulFunctionCall",
                                          "src": "1222:14:78"
                                        },
                                        {
                                          "name": "_1",
                                          "nodeType": "YulIdentifier",
                                          "src": "1238:2:78"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "add",
                                        "nodeType": "YulIdentifier",
                                        "src": "1218:3:78"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "1218:23:78"
                                    },
                                    {
                                      "arguments": [
                                        {
                                          "arguments": [
                                            {
                                              "arguments": [
                                                {
                                                  "name": "_3",
                                                  "nodeType": "YulIdentifier",
                                                  "src": "1257:2:78"
                                                },
                                                {
                                                  "name": "i",
                                                  "nodeType": "YulIdentifier",
                                                  "src": "1261:1:78"
                                                }
                                              ],
                                              "functionName": {
                                                "name": "add",
                                                "nodeType": "YulIdentifier",
                                                "src": "1253:3:78"
                                              },
                                              "nodeType": "YulFunctionCall",
                                              "src": "1253:10:78"
                                            },
                                            {
                                              "name": "_1",
                                              "nodeType": "YulIdentifier",
                                              "src": "1265:2:78"
                                            }
                                          ],
                                          "functionName": {
                                            "name": "add",
                                            "nodeType": "YulIdentifier",
                                            "src": "1249:3:78"
                                          },
                                          "nodeType": "YulFunctionCall",
                                          "src": "1249:19:78"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "mload",
                                        "nodeType": "YulIdentifier",
                                        "src": "1243:5:78"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "1243:26:78"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "1211:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1211:59:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1211:59:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "i",
                                "nodeType": "YulIdentifier",
                                "src": "1162:1:78"
                              },
                              {
                                "name": "_4",
                                "nodeType": "YulIdentifier",
                                "src": "1165:2:78"
                              }
                            ],
                            "functionName": {
                              "name": "lt",
                              "nodeType": "YulIdentifier",
                              "src": "1159:2:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1159:9:78"
                          },
                          "nodeType": "YulForLoop",
                          "post": {
                            "nodeType": "YulBlock",
                            "src": "1169:19:78",
                            "statements": [
                              {
                                "nodeType": "YulAssignment",
                                "src": "1171:15:78",
                                "value": {
                                  "arguments": [
                                    {
                                      "name": "i",
                                      "nodeType": "YulIdentifier",
                                      "src": "1180:1:78"
                                    },
                                    {
                                      "name": "_1",
                                      "nodeType": "YulIdentifier",
                                      "src": "1183:2:78"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "add",
                                    "nodeType": "YulIdentifier",
                                    "src": "1176:3:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1176:10:78"
                                },
                                "variableNames": [
                                  {
                                    "name": "i",
                                    "nodeType": "YulIdentifier",
                                    "src": "1171:1:78"
                                  }
                                ]
                              }
                            ]
                          },
                          "pre": {
                            "nodeType": "YulBlock",
                            "src": "1155:3:78",
                            "statements": []
                          },
                          "src": "1151:129:78"
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1310:59:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "arguments": [
                                        {
                                          "arguments": [
                                            {
                                              "name": "memPtr",
                                              "nodeType": "YulIdentifier",
                                              "src": "1339:6:78"
                                            },
                                            {
                                              "name": "_4",
                                              "nodeType": "YulIdentifier",
                                              "src": "1347:2:78"
                                            }
                                          ],
                                          "functionName": {
                                            "name": "add",
                                            "nodeType": "YulIdentifier",
                                            "src": "1335:3:78"
                                          },
                                          "nodeType": "YulFunctionCall",
                                          "src": "1335:15:78"
                                        },
                                        {
                                          "name": "_1",
                                          "nodeType": "YulIdentifier",
                                          "src": "1352:2:78"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "add",
                                        "nodeType": "YulIdentifier",
                                        "src": "1331:3:78"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "1331:24:78"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1357:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "1324:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1324:35:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1324:35:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "i",
                                "nodeType": "YulIdentifier",
                                "src": "1295:1:78"
                              },
                              {
                                "name": "_4",
                                "nodeType": "YulIdentifier",
                                "src": "1298:2:78"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "1292:2:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1292:9:78"
                          },
                          "nodeType": "YulIf",
                          "src": "1289:80:78"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "1378:16:78",
                          "value": {
                            "name": "memPtr",
                            "nodeType": "YulIdentifier",
                            "src": "1388:6:78"
                          },
                          "variableNames": [
                            {
                              "name": "value1",
                              "nodeType": "YulIdentifier",
                              "src": "1378:6:78"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_addresst_string_memory_ptr_fromMemory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "212:9:78",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "223:7:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "235:6:78",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nodeType": "YulTypedName",
                        "src": "243:6:78",
                        "type": ""
                      }
                    ],
                    "src": "146:1254:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1460:325:78",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "1470:22:78",
                          "value": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1484:1:78",
                                "type": "",
                                "value": "1"
                              },
                              {
                                "name": "data",
                                "nodeType": "YulIdentifier",
                                "src": "1487:4:78"
                              }
                            ],
                            "functionName": {
                              "name": "shr",
                              "nodeType": "YulIdentifier",
                              "src": "1480:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1480:12:78"
                          },
                          "variableNames": [
                            {
                              "name": "length",
                              "nodeType": "YulIdentifier",
                              "src": "1470:6:78"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "1501:38:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "data",
                                "nodeType": "YulIdentifier",
                                "src": "1531:4:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1537:1:78",
                                "type": "",
                                "value": "1"
                              }
                            ],
                            "functionName": {
                              "name": "and",
                              "nodeType": "YulIdentifier",
                              "src": "1527:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1527:12:78"
                          },
                          "variables": [
                            {
                              "name": "outOfPlaceEncoding",
                              "nodeType": "YulTypedName",
                              "src": "1505:18:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1578:31:78",
                            "statements": [
                              {
                                "nodeType": "YulAssignment",
                                "src": "1580:27:78",
                                "value": {
                                  "arguments": [
                                    {
                                      "name": "length",
                                      "nodeType": "YulIdentifier",
                                      "src": "1594:6:78"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1602:4:78",
                                      "type": "",
                                      "value": "0x7f"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "and",
                                    "nodeType": "YulIdentifier",
                                    "src": "1590:3:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1590:17:78"
                                },
                                "variableNames": [
                                  {
                                    "name": "length",
                                    "nodeType": "YulIdentifier",
                                    "src": "1580:6:78"
                                  }
                                ]
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "outOfPlaceEncoding",
                                "nodeType": "YulIdentifier",
                                "src": "1558:18:78"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "1551:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1551:26:78"
                          },
                          "nodeType": "YulIf",
                          "src": "1548:61:78"
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1668:111:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1689:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "arguments": [
                                        {
                                          "kind": "number",
                                          "nodeType": "YulLiteral",
                                          "src": "1696:3:78",
                                          "type": "",
                                          "value": "224"
                                        },
                                        {
                                          "kind": "number",
                                          "nodeType": "YulLiteral",
                                          "src": "1701:10:78",
                                          "type": "",
                                          "value": "0x4e487b71"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "shl",
                                        "nodeType": "YulIdentifier",
                                        "src": "1692:3:78"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "1692:20:78"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "1682:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1682:31:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1682:31:78"
                              },
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1733:1:78",
                                      "type": "",
                                      "value": "4"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1736:4:78",
                                      "type": "",
                                      "value": "0x22"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "1726:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1726:15:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1726:15:78"
                              },
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1761:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1764:4:78",
                                      "type": "",
                                      "value": "0x24"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1754:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1754:15:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1754:15:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "outOfPlaceEncoding",
                                "nodeType": "YulIdentifier",
                                "src": "1624:18:78"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "length",
                                    "nodeType": "YulIdentifier",
                                    "src": "1647:6:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "1655:2:78",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "lt",
                                  "nodeType": "YulIdentifier",
                                  "src": "1644:2:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1644:14:78"
                              }
                            ],
                            "functionName": {
                              "name": "eq",
                              "nodeType": "YulIdentifier",
                              "src": "1621:2:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1621:38:78"
                          },
                          "nodeType": "YulIf",
                          "src": "1618:161:78"
                        }
                      ]
                    },
                    "name": "extract_byte_array_length",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "data",
                        "nodeType": "YulTypedName",
                        "src": "1440:4:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "length",
                        "nodeType": "YulTypedName",
                        "src": "1449:6:78",
                        "type": ""
                      }
                    ],
                    "src": "1405:380:78"
                  }
                ]
              },
              "contents": "{\n    { }\n    function panic_error_0x41()\n    {\n        mstore(0, shl(224, 0x4e487b71))\n        mstore(4, 0x41)\n        revert(0, 0x24)\n    }\n    function abi_decode_tuple_t_addresst_string_memory_ptr_fromMemory(headStart, dataEnd) -> value0, value1\n    {\n        if slt(sub(dataEnd, headStart), 64) { revert(0, 0) }\n        let value := mload(headStart)\n        if iszero(eq(value, and(value, sub(shl(160, 1), 1)))) { revert(0, 0) }\n        value0 := value\n        let _1 := 32\n        let offset := mload(add(headStart, _1))\n        let _2 := sub(shl(64, 1), 1)\n        if gt(offset, _2) { revert(0, 0) }\n        let _3 := add(headStart, offset)\n        if iszero(slt(add(_3, 0x1f), dataEnd)) { revert(0, 0) }\n        let _4 := mload(_3)\n        if gt(_4, _2) { panic_error_0x41() }\n        let _5 := not(31)\n        let memPtr := mload(64)\n        let newFreePtr := add(memPtr, and(add(and(add(_4, 0x1f), _5), 63), _5))\n        if or(gt(newFreePtr, _2), lt(newFreePtr, memPtr)) { panic_error_0x41() }\n        mstore(64, newFreePtr)\n        mstore(memPtr, _4)\n        if gt(add(add(_3, _4), _1), dataEnd) { revert(0, 0) }\n        let i := 0\n        for { } lt(i, _4) { i := add(i, _1) }\n        {\n            mstore(add(add(memPtr, i), _1), mload(add(add(_3, i), _1)))\n        }\n        if gt(i, _4)\n        {\n            mstore(add(add(memPtr, _4), _1), 0)\n        }\n        value1 := memPtr\n    }\n    function extract_byte_array_length(data) -> length\n    {\n        length := shr(1, data)\n        let outOfPlaceEncoding := and(data, 1)\n        if iszero(outOfPlaceEncoding) { length := and(length, 0x7f) }\n        if eq(outOfPlaceEncoding, lt(length, 32))\n        {\n            mstore(0, shl(224, 0x4e487b71))\n            mstore(4, 0x22)\n            revert(0, 0x24)\n        }\n    }\n}",
              "id": 78,
              "language": "Yul",
              "name": "#utility.yul"
            }
          ],
          "linkReferences": {},
          "object": "60806040523480156200001157600080fd5b50604051620011b3380380620011b3833981016040819052620000349162000129565b600080546001600160a01b0319166001600160a01b0384161790558051620000649060019060208401906200006d565b50505062000266565b8280546200007b9062000229565b90600052602060002090601f0160209004810192826200009f5760008555620000ea565b82601f10620000ba57805160ff1916838001178555620000ea565b82800160010185558215620000ea579182015b82811115620000ea578251825591602001919060010190620000cd565b50620000f8929150620000fc565b5090565b5b80821115620000f85760008155600101620000fd565b634e487b7160e01b600052604160045260246000fd5b600080604083850312156200013d57600080fd5b82516001600160a01b03811681146200015557600080fd5b602084810151919350906001600160401b03808211156200017557600080fd5b818601915086601f8301126200018a57600080fd5b8151818111156200019f576200019f62000113565b604051601f8201601f19908116603f01168101908382118183101715620001ca57620001ca62000113565b816040528281528986848701011115620001e357600080fd5b600093505b82841015620002075784840186015181850187015292850192620001e8565b82841115620002195760008684830101525b8096505050505050509250929050565b600181811c908216806200023e57607f821691505b602082108114156200026057634e487b7160e01b600052602260045260246000fd5b50919050565b610f3d80620002766000396000f3fe608060405234801561001057600080fd5b50600436106100c95760003560e01c8063461a4478116100815780639507d39a1161005b5780639507d39a146101a4578063b298e36b146101b7578063ccf8f969146101ca57600080fd5b8063461a4478146101695780634651d91e1461017c5780638da5cb5b1461018f57600080fd5b80632015276c116100b25780632015276c146100fe57806329061de214610111578063299ca4781461012457600080fd5b8063167fd681146100ce5780631f7b6d32146100e3575b600080fd5b6100e16100dc366004610c59565b6101e9565b005b6100eb61034d565b6040519081526020015b60405180910390f35b6100e161010c366004610c59565b610365565b6100e161011f366004610c85565b61043d565b6000546101449073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100f5565b610144610177366004610cd6565b610517565b6100e161018a366004610da5565b6105c4565b61019761069b565b6040516100f59190610dbe565b6100eb6101b2366004610da5565b610729565b6100e16101c5366004610da5565b61073d565b6101d2610814565b60405164ffffffffff1990911681526020016100f5565b61027c600180546101f990610e31565b80601f016020809104026020016040519081016040528092919081815260200182805461022590610e31565b80156102725780601f1061024757610100808354040283529160200191610272565b820191906000526020600020905b81548152906001019060200180831161025557829003601f168201915b5050505050610517565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461033d57604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e60648201526084015b60405180910390fd5b61034960028383610825565b5050565b6000610359600261090c565b64ffffffffff16905090565b610375600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461043157604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b61034960028383610957565b61044d600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461050957604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b6105146002826109e6565b50565b600080546040517fbf40fac100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091169063bf40fac19061056e908590600401610dbe565b60206040518083038186803b15801561058657600080fd5b505afa15801561059a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105be9190610e85565b92915050565b6105d4600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461069057604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b610514600282610a47565b600180546106a890610e31565b80601f01602080910402602001604051908101604052809291908181526020018280546106d490610e31565b80156107215780601f106106f657610100808354040283529160200191610721565b820191906000526020600020905b81548152906001019060200180831161070457829003601f168201915b505050505081565b60006105be600264ffffffffff8416610aa4565b61074d600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461080957604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b610514600282610b73565b60006108206002610bd0565b905090565b600061086784604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b9050806000015164ffffffffff168364ffffffffff16106108e4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f496e646578206f7574206f6620626f756e64732e0000000000000000000000006044820152606401610334565b64ffffffffff8316815264ffffffffff19821660208201526109068482610c1e565b50505050565b60008061094f83604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b519392505050565b600061099984604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b805164ffffffffff16600090815260018601602052604090208490558051909150816109c482610ebb565b64ffffffffff1690525064ffffffffff19821660208201526109068482610c1e565b6000610a2883604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b64ffffffffff19831660208201529050610a428382610c1e565b505050565b6000610a8983604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b9050610a42828260200151856108259092919063ffffffff16565b600080610ae784604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b805190915064ffffffffff168310610b5b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f496e646578206f7574206f6620626f756e64732e0000000000000000000000006044820152606401610334565b50506000908152600191909101602052604090205490565b6000610bb583604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b9050610a42828260200151856109579092919063ffffffff16565b600080610c1383604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b602001519392505050565b8051602082015183548183179291908314610c37578285555b5050505050565b803564ffffffffff1981168114610c5457600080fd5b919050565b60008060408385031215610c6c57600080fd5b82359150610c7c60208401610c3e565b90509250929050565b600060208284031215610c9757600080fd5b610ca082610c3e565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208284031215610ce857600080fd5b813567ffffffffffffffff80821115610d0057600080fd5b818401915084601f830112610d1457600080fd5b813581811115610d2657610d26610ca7565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715610d6c57610d6c610ca7565b81604052828152876020848701011115610d8557600080fd5b826020860160208301376000928101602001929092525095945050505050565b600060208284031215610db757600080fd5b5035919050565b600060208083528351808285015260005b81811015610deb57858101830151858201604001528201610dcf565b81811115610dfd576000604083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016929092016040019392505050565b600181811c90821680610e4557607f821691505b60208210811415610e7f577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b600060208284031215610e9757600080fd5b815173ffffffffffffffffffffffffffffffffffffffff81168114610ca057600080fd5b600064ffffffffff80831681811415610efd577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600101939250505056fea2646970667358221220e1995ee56c4c5e67de41c56ad510b16704727d3ab1fa5bb2e3c62b0bd7c0597564736f6c63430008090033",
          "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH3 0x11 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x40 MLOAD PUSH3 0x11B3 CODESIZE SUB DUP1 PUSH3 0x11B3 DUP4 CODECOPY DUP2 ADD PUSH1 0x40 DUP2 SWAP1 MSTORE PUSH3 0x34 SWAP2 PUSH3 0x129 JUMP JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 AND OR SWAP1 SSTORE DUP1 MLOAD PUSH3 0x64 SWAP1 PUSH1 0x1 SWAP1 PUSH1 0x20 DUP5 ADD SWAP1 PUSH3 0x6D JUMP JUMPDEST POP POP POP PUSH3 0x266 JUMP JUMPDEST DUP3 DUP1 SLOAD PUSH3 0x7B SWAP1 PUSH3 0x229 JUMP JUMPDEST SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 KECCAK256 SWAP1 PUSH1 0x1F ADD PUSH1 0x20 SWAP1 DIV DUP2 ADD SWAP3 DUP3 PUSH3 0x9F JUMPI PUSH1 0x0 DUP6 SSTORE PUSH3 0xEA JUMP JUMPDEST DUP3 PUSH1 0x1F LT PUSH3 0xBA JUMPI DUP1 MLOAD PUSH1 0xFF NOT AND DUP4 DUP1 ADD OR DUP6 SSTORE PUSH3 0xEA JUMP JUMPDEST DUP3 DUP1 ADD PUSH1 0x1 ADD DUP6 SSTORE DUP3 ISZERO PUSH3 0xEA JUMPI SWAP2 DUP3 ADD JUMPDEST DUP3 DUP2 GT ISZERO PUSH3 0xEA JUMPI DUP3 MLOAD DUP3 SSTORE SWAP2 PUSH1 0x20 ADD SWAP2 SWAP1 PUSH1 0x1 ADD SWAP1 PUSH3 0xCD JUMP JUMPDEST POP PUSH3 0xF8 SWAP3 SWAP2 POP PUSH3 0xFC JUMP JUMPDEST POP SWAP1 JUMP JUMPDEST JUMPDEST DUP1 DUP3 GT ISZERO PUSH3 0xF8 JUMPI PUSH1 0x0 DUP2 SSTORE PUSH1 0x1 ADD PUSH3 0xFD JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x40 DUP4 DUP6 SUB SLT ISZERO PUSH3 0x13D JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP3 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 EQ PUSH3 0x155 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x20 DUP5 DUP2 ADD MLOAD SWAP2 SWAP4 POP SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP1 DUP3 GT ISZERO PUSH3 0x175 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 DUP7 ADD SWAP2 POP DUP7 PUSH1 0x1F DUP4 ADD SLT PUSH3 0x18A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 MLOAD DUP2 DUP2 GT ISZERO PUSH3 0x19F JUMPI PUSH3 0x19F PUSH3 0x113 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1F DUP3 ADD PUSH1 0x1F NOT SWAP1 DUP2 AND PUSH1 0x3F ADD AND DUP2 ADD SWAP1 DUP4 DUP3 GT DUP2 DUP4 LT OR ISZERO PUSH3 0x1CA JUMPI PUSH3 0x1CA PUSH3 0x113 JUMP JUMPDEST DUP2 PUSH1 0x40 MSTORE DUP3 DUP2 MSTORE DUP10 DUP7 DUP5 DUP8 ADD ADD GT ISZERO PUSH3 0x1E3 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 SWAP4 POP JUMPDEST DUP3 DUP5 LT ISZERO PUSH3 0x207 JUMPI DUP5 DUP5 ADD DUP7 ADD MLOAD DUP2 DUP6 ADD DUP8 ADD MSTORE SWAP3 DUP6 ADD SWAP3 PUSH3 0x1E8 JUMP JUMPDEST DUP3 DUP5 GT ISZERO PUSH3 0x219 JUMPI PUSH1 0x0 DUP7 DUP5 DUP4 ADD ADD MSTORE JUMPDEST DUP1 SWAP7 POP POP POP POP POP POP POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH1 0x1 DUP2 DUP2 SHR SWAP1 DUP3 AND DUP1 PUSH3 0x23E JUMPI PUSH1 0x7F DUP3 AND SWAP2 POP JUMPDEST PUSH1 0x20 DUP3 LT DUP2 EQ ISZERO PUSH3 0x260 JUMPI PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x22 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH2 0xF3D DUP1 PUSH3 0x276 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0xC9 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x461A4478 GT PUSH2 0x81 JUMPI DUP1 PUSH4 0x9507D39A GT PUSH2 0x5B JUMPI DUP1 PUSH4 0x9507D39A EQ PUSH2 0x1A4 JUMPI DUP1 PUSH4 0xB298E36B EQ PUSH2 0x1B7 JUMPI DUP1 PUSH4 0xCCF8F969 EQ PUSH2 0x1CA JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 PUSH4 0x461A4478 EQ PUSH2 0x169 JUMPI DUP1 PUSH4 0x4651D91E EQ PUSH2 0x17C JUMPI DUP1 PUSH4 0x8DA5CB5B EQ PUSH2 0x18F JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 PUSH4 0x2015276C GT PUSH2 0xB2 JUMPI DUP1 PUSH4 0x2015276C EQ PUSH2 0xFE JUMPI DUP1 PUSH4 0x29061DE2 EQ PUSH2 0x111 JUMPI DUP1 PUSH4 0x299CA478 EQ PUSH2 0x124 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 PUSH4 0x167FD681 EQ PUSH2 0xCE JUMPI DUP1 PUSH4 0x1F7B6D32 EQ PUSH2 0xE3 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xE1 PUSH2 0xDC CALLDATASIZE PUSH1 0x4 PUSH2 0xC59 JUMP JUMPDEST PUSH2 0x1E9 JUMP JUMPDEST STOP JUMPDEST PUSH2 0xEB PUSH2 0x34D JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0xE1 PUSH2 0x10C CALLDATASIZE PUSH1 0x4 PUSH2 0xC59 JUMP JUMPDEST PUSH2 0x365 JUMP JUMPDEST PUSH2 0xE1 PUSH2 0x11F CALLDATASIZE PUSH1 0x4 PUSH2 0xC85 JUMP JUMPDEST PUSH2 0x43D JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH2 0x144 SWAP1 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD PUSH2 0xF5 JUMP JUMPDEST PUSH2 0x144 PUSH2 0x177 CALLDATASIZE PUSH1 0x4 PUSH2 0xCD6 JUMP JUMPDEST PUSH2 0x517 JUMP JUMPDEST PUSH2 0xE1 PUSH2 0x18A CALLDATASIZE PUSH1 0x4 PUSH2 0xDA5 JUMP JUMPDEST PUSH2 0x5C4 JUMP JUMPDEST PUSH2 0x197 PUSH2 0x69B JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0xF5 SWAP2 SWAP1 PUSH2 0xDBE JUMP JUMPDEST PUSH2 0xEB PUSH2 0x1B2 CALLDATASIZE PUSH1 0x4 PUSH2 0xDA5 JUMP JUMPDEST PUSH2 0x729 JUMP JUMPDEST PUSH2 0xE1 PUSH2 0x1C5 CALLDATASIZE PUSH1 0x4 PUSH2 0xDA5 JUMP JUMPDEST PUSH2 0x73D JUMP JUMPDEST PUSH2 0x1D2 PUSH2 0x814 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD PUSH2 0xF5 JUMP JUMPDEST PUSH2 0x27C PUSH1 0x1 DUP1 SLOAD PUSH2 0x1F9 SWAP1 PUSH2 0xE31 JUMP JUMPDEST DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP1 SLOAD PUSH2 0x225 SWAP1 PUSH2 0xE31 JUMP JUMPDEST DUP1 ISZERO PUSH2 0x272 JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x247 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x272 JUMP JUMPDEST DUP3 ADD SWAP2 SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 KECCAK256 SWAP1 JUMPDEST DUP2 SLOAD DUP2 MSTORE SWAP1 PUSH1 0x1 ADD SWAP1 PUSH1 0x20 ADD DUP1 DUP4 GT PUSH2 0x255 JUMPI DUP3 SWAP1 SUB PUSH1 0x1F AND DUP3 ADD SWAP2 JUMPDEST POP POP POP POP POP PUSH2 0x517 JUMP JUMPDEST PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ PUSH2 0x33D JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x24 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH32 0x436861696E53746F72616765436F6E7461696E65723A2046756E6374696F6E20 PUSH1 0x44 DUP3 ADD MSTORE PUSH32 0x63616E206F6E6C792062652063616C6C656420627920746865206F776E65722E PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH2 0x349 PUSH1 0x2 DUP4 DUP4 PUSH2 0x825 JUMP JUMPDEST POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0x359 PUSH1 0x2 PUSH2 0x90C JUMP JUMPDEST PUSH5 0xFFFFFFFFFF AND SWAP1 POP SWAP1 JUMP JUMPDEST PUSH2 0x375 PUSH1 0x1 DUP1 SLOAD PUSH2 0x1F9 SWAP1 PUSH2 0xE31 JUMP JUMPDEST PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ PUSH2 0x431 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x24 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH32 0x436861696E53746F72616765436F6E7461696E65723A2046756E6374696F6E20 PUSH1 0x44 DUP3 ADD MSTORE PUSH32 0x63616E206F6E6C792062652063616C6C656420627920746865206F776E65722E PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 ADD PUSH2 0x334 JUMP JUMPDEST PUSH2 0x349 PUSH1 0x2 DUP4 DUP4 PUSH2 0x957 JUMP JUMPDEST PUSH2 0x44D PUSH1 0x1 DUP1 SLOAD PUSH2 0x1F9 SWAP1 PUSH2 0xE31 JUMP JUMPDEST PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ PUSH2 0x509 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x24 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH32 0x436861696E53746F72616765436F6E7461696E65723A2046756E6374696F6E20 PUSH1 0x44 DUP3 ADD MSTORE PUSH32 0x63616E206F6E6C792062652063616C6C656420627920746865206F776E65722E PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 ADD PUSH2 0x334 JUMP JUMPDEST PUSH2 0x514 PUSH1 0x2 DUP3 PUSH2 0x9E6 JUMP JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH1 0x40 MLOAD PUSH32 0xBF40FAC100000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF SWAP1 SWAP2 AND SWAP1 PUSH4 0xBF40FAC1 SWAP1 PUSH2 0x56E SWAP1 DUP6 SWAP1 PUSH1 0x4 ADD PUSH2 0xDBE JUMP JUMPDEST PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x586 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x59A JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x5BE SWAP2 SWAP1 PUSH2 0xE85 JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH2 0x5D4 PUSH1 0x1 DUP1 SLOAD PUSH2 0x1F9 SWAP1 PUSH2 0xE31 JUMP JUMPDEST PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ PUSH2 0x690 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x24 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH32 0x436861696E53746F72616765436F6E7461696E65723A2046756E6374696F6E20 PUSH1 0x44 DUP3 ADD MSTORE PUSH32 0x63616E206F6E6C792062652063616C6C656420627920746865206F776E65722E PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 ADD PUSH2 0x334 JUMP JUMPDEST PUSH2 0x514 PUSH1 0x2 DUP3 PUSH2 0xA47 JUMP JUMPDEST PUSH1 0x1 DUP1 SLOAD PUSH2 0x6A8 SWAP1 PUSH2 0xE31 JUMP JUMPDEST DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP1 SLOAD PUSH2 0x6D4 SWAP1 PUSH2 0xE31 JUMP JUMPDEST DUP1 ISZERO PUSH2 0x721 JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x6F6 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x721 JUMP JUMPDEST DUP3 ADD SWAP2 SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 KECCAK256 SWAP1 JUMPDEST DUP2 SLOAD DUP2 MSTORE SWAP1 PUSH1 0x1 ADD SWAP1 PUSH1 0x20 ADD DUP1 DUP4 GT PUSH2 0x704 JUMPI DUP3 SWAP1 SUB PUSH1 0x1F AND DUP3 ADD SWAP2 JUMPDEST POP POP POP POP POP DUP2 JUMP JUMPDEST PUSH1 0x0 PUSH2 0x5BE PUSH1 0x2 PUSH5 0xFFFFFFFFFF DUP5 AND PUSH2 0xAA4 JUMP JUMPDEST PUSH2 0x74D PUSH1 0x1 DUP1 SLOAD PUSH2 0x1F9 SWAP1 PUSH2 0xE31 JUMP JUMPDEST PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ PUSH2 0x809 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x24 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH32 0x436861696E53746F72616765436F6E7461696E65723A2046756E6374696F6E20 PUSH1 0x44 DUP3 ADD MSTORE PUSH32 0x63616E206F6E6C792062652063616C6C656420627920746865206F776E65722E PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 ADD PUSH2 0x334 JUMP JUMPDEST PUSH2 0x514 PUSH1 0x2 DUP3 PUSH2 0xB73 JUMP JUMPDEST PUSH1 0x0 PUSH2 0x820 PUSH1 0x2 PUSH2 0xBD0 JUMP JUMPDEST SWAP1 POP SWAP1 JUMP JUMPDEST PUSH1 0x0 PUSH2 0x867 DUP5 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST SWAP1 POP DUP1 PUSH1 0x0 ADD MLOAD PUSH5 0xFFFFFFFFFF AND DUP4 PUSH5 0xFFFFFFFFFF AND LT PUSH2 0x8E4 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x14 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x496E646578206F7574206F6620626F756E64732E000000000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE PUSH1 0x64 ADD PUSH2 0x334 JUMP JUMPDEST PUSH5 0xFFFFFFFFFF DUP4 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT DUP3 AND PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x906 DUP5 DUP3 PUSH2 0xC1E JUMP JUMPDEST POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH2 0x94F DUP4 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST MLOAD SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0x999 DUP5 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST DUP1 MLOAD PUSH5 0xFFFFFFFFFF AND PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x1 DUP7 ADD PUSH1 0x20 MSTORE PUSH1 0x40 SWAP1 KECCAK256 DUP5 SWAP1 SSTORE DUP1 MLOAD SWAP1 SWAP2 POP DUP2 PUSH2 0x9C4 DUP3 PUSH2 0xEBB JUMP JUMPDEST PUSH5 0xFFFFFFFFFF AND SWAP1 MSTORE POP PUSH5 0xFFFFFFFFFF NOT DUP3 AND PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x906 DUP5 DUP3 PUSH2 0xC1E JUMP JUMPDEST PUSH1 0x0 PUSH2 0xA28 DUP4 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST PUSH5 0xFFFFFFFFFF NOT DUP4 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 POP PUSH2 0xA42 DUP4 DUP3 PUSH2 0xC1E JUMP JUMPDEST POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xA89 DUP4 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST SWAP1 POP PUSH2 0xA42 DUP3 DUP3 PUSH1 0x20 ADD MLOAD DUP6 PUSH2 0x825 SWAP1 SWAP3 SWAP2 SWAP1 PUSH4 0xFFFFFFFF AND JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH2 0xAE7 DUP5 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST DUP1 MLOAD SWAP1 SWAP2 POP PUSH5 0xFFFFFFFFFF AND DUP4 LT PUSH2 0xB5B JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x14 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x496E646578206F7574206F6620626F756E64732E000000000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE PUSH1 0x64 ADD PUSH2 0x334 JUMP JUMPDEST POP POP PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x1 SWAP2 SWAP1 SWAP2 ADD PUSH1 0x20 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SLOAD SWAP1 JUMP JUMPDEST PUSH1 0x0 PUSH2 0xBB5 DUP4 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST SWAP1 POP PUSH2 0xA42 DUP3 DUP3 PUSH1 0x20 ADD MLOAD DUP6 PUSH2 0x957 SWAP1 SWAP3 SWAP2 SWAP1 PUSH4 0xFFFFFFFF AND JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH2 0xC13 DUP4 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST PUSH1 0x20 ADD MLOAD SWAP4 SWAP3 POP POP POP JUMP JUMPDEST DUP1 MLOAD PUSH1 0x20 DUP3 ADD MLOAD DUP4 SLOAD DUP2 DUP4 OR SWAP3 SWAP2 SWAP1 DUP4 EQ PUSH2 0xC37 JUMPI DUP3 DUP6 SSTORE JUMPDEST POP POP POP POP POP JUMP JUMPDEST DUP1 CALLDATALOAD PUSH5 0xFFFFFFFFFF NOT DUP2 AND DUP2 EQ PUSH2 0xC54 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x40 DUP4 DUP6 SUB SLT ISZERO PUSH2 0xC6C JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP3 CALLDATALOAD SWAP2 POP PUSH2 0xC7C PUSH1 0x20 DUP5 ADD PUSH2 0xC3E JUMP JUMPDEST SWAP1 POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0xC97 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xCA0 DUP3 PUSH2 0xC3E JUMP JUMPDEST SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH32 0x4E487B7100000000000000000000000000000000000000000000000000000000 PUSH1 0x0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0xCE8 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP1 DUP3 GT ISZERO PUSH2 0xD00 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 DUP5 ADD SWAP2 POP DUP5 PUSH1 0x1F DUP4 ADD SLT PUSH2 0xD14 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD DUP2 DUP2 GT ISZERO PUSH2 0xD26 JUMPI PUSH2 0xD26 PUSH2 0xCA7 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1F DUP3 ADD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0 SWAP1 DUP2 AND PUSH1 0x3F ADD AND DUP2 ADD SWAP1 DUP4 DUP3 GT DUP2 DUP4 LT OR ISZERO PUSH2 0xD6C JUMPI PUSH2 0xD6C PUSH2 0xCA7 JUMP JUMPDEST DUP2 PUSH1 0x40 MSTORE DUP3 DUP2 MSTORE DUP8 PUSH1 0x20 DUP5 DUP8 ADD ADD GT ISZERO PUSH2 0xD85 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP3 PUSH1 0x20 DUP7 ADD PUSH1 0x20 DUP4 ADD CALLDATACOPY PUSH1 0x0 SWAP3 DUP2 ADD PUSH1 0x20 ADD SWAP3 SWAP1 SWAP3 MSTORE POP SWAP6 SWAP5 POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0xDB7 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP CALLDATALOAD SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP1 DUP4 MSTORE DUP4 MLOAD DUP1 DUP3 DUP6 ADD MSTORE PUSH1 0x0 JUMPDEST DUP2 DUP2 LT ISZERO PUSH2 0xDEB JUMPI DUP6 DUP2 ADD DUP4 ADD MLOAD DUP6 DUP3 ADD PUSH1 0x40 ADD MSTORE DUP3 ADD PUSH2 0xDCF JUMP JUMPDEST DUP2 DUP2 GT ISZERO PUSH2 0xDFD JUMPI PUSH1 0x0 PUSH1 0x40 DUP4 DUP8 ADD ADD MSTORE JUMPDEST POP PUSH1 0x1F ADD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0 AND SWAP3 SWAP1 SWAP3 ADD PUSH1 0x40 ADD SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x1 DUP2 DUP2 SHR SWAP1 DUP3 AND DUP1 PUSH2 0xE45 JUMPI PUSH1 0x7F DUP3 AND SWAP2 POP JUMPDEST PUSH1 0x20 DUP3 LT DUP2 EQ ISZERO PUSH2 0xE7F JUMPI PUSH32 0x4E487B7100000000000000000000000000000000000000000000000000000000 PUSH1 0x0 MSTORE PUSH1 0x22 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0xE97 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP2 AND DUP2 EQ PUSH2 0xCA0 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH5 0xFFFFFFFFFF DUP1 DUP4 AND DUP2 DUP2 EQ ISZERO PUSH2 0xEFD JUMPI PUSH32 0x4E487B7100000000000000000000000000000000000000000000000000000000 PUSH1 0x0 MSTORE PUSH1 0x11 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x1 ADD SWAP4 SWAP3 POP POP POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xE1 SWAP10 0x5E 0xE5 PUSH13 0x4C5E67DE41C56AD510B1670472 PUSH30 0x3AB1FA5BB2E3C62B0BD7C0597564736F6C63430008090033000000000000 ",
          "sourceMap": "989:2971:22:-:0;;;1540:145;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;533:17:52;:58;;-1:-1:-1;;;;;;533:58:52;-1:-1:-1;;;;;533:58:52;;;;;1664:14:22;;::::1;::::0;-1:-1:-1;;1664:14:22::1;::::0;::::1;::::0;::::1;:::i;:::-;;1540:145:::0;;989:2971;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;989:2971:22;;;-1:-1:-1;989:2971:22;:::i;:::-;;;:::o;:::-;;;;;;;;;;;;;;;14:127:78;75:10;70:3;66:20;63:1;56:31;106:4;103:1;96:15;130:4;127:1;120:15;146:1254;235:6;243;296:2;284:9;275:7;271:23;267:32;264:52;;;312:1;309;302:12;264:52;338:16;;-1:-1:-1;;;;;383:31:78;;373:42;;363:70;;429:1;426;419:12;363:70;476:2;507:18;;;501:25;452:5;;-1:-1:-1;476:2:78;-1:-1:-1;;;;;575:14:78;;;572:34;;;602:1;599;592:12;572:34;640:6;629:9;625:22;615:32;;685:7;678:4;674:2;670:13;666:27;656:55;;707:1;704;697:12;656:55;736:2;730:9;758:2;754;751:10;748:36;;;764:18;;:::i;:::-;839:2;833:9;807:2;893:13;;-1:-1:-1;;889:22:78;;;913:2;885:31;881:40;869:53;;;937:18;;;957:22;;;934:46;931:72;;;983:18;;:::i;:::-;1023:10;1019:2;1012:22;1058:2;1050:6;1043:18;1098:7;1093:2;1088;1084;1080:11;1076:20;1073:33;1070:53;;;1119:1;1116;1109:12;1070:53;1141:1;1132:10;;1151:129;1165:2;1162:1;1159:9;1151:129;;;1253:10;;;1249:19;;1243:26;1222:14;;;1218:23;;1211:59;1176:10;;;;1151:129;;;1298:2;1295:1;1292:9;1289:80;;;1357:1;1352:2;1347;1339:6;1335:15;1331:24;1324:35;1289:80;1388:6;1378:16;;;;;;;;146:1254;;;;;:::o;1405:380::-;1484:1;1480:12;;;;1527;;;1548:61;;1602:4;1594:6;1590:17;1580:27;;1548:61;1655:2;1647:6;1644:14;1624:18;1621:38;1618:161;;;1701:10;1696:3;1692:20;1689:1;1682:31;1736:4;1733:1;1726:15;1764:4;1761:1;1754:15;1618:161;;1405:380;;;:::o;:::-;989:2971:22;;;;;;"
        },
        "deployedBytecode": {
          "functionDebugData": {
            "@deleteElementsAfterInclusive_4342": {
              "entryPoint": 1476,
              "id": 4342,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "@deleteElementsAfterInclusive_4363": {
              "entryPoint": 489,
              "id": 4363,
              "parameterSlots": 2,
              "returnSlots": 0
            },
            "@deleteElementsAfterInclusive_9927": {
              "entryPoint": 2085,
              "id": 9927,
              "parameterSlots": 3,
              "returnSlots": 0
            },
            "@deleteElementsAfterInclusive_9952": {
              "entryPoint": 2631,
              "id": 9952,
              "parameterSlots": 2,
              "returnSlots": 0
            },
            "@getContext_10086": {
              "entryPoint": null,
              "id": 10086,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "@getExtraData_10021": {
              "entryPoint": 3024,
              "id": 10021,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "@getGlobalMetadata_4260": {
              "entryPoint": 2068,
              "id": 4260,
              "parameterSlots": 0,
              "returnSlots": 1
            },
            "@getLength_9972": {
              "entryPoint": 2316,
              "id": 9972,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "@get_4324": {
              "entryPoint": 1833,
              "id": 4324,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "@get_9882": {
              "entryPoint": 2724,
              "id": 9882,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "@length_4274": {
              "entryPoint": 845,
              "id": 4274,
              "parameterSlots": 0,
              "returnSlots": 1
            },
            "@libAddressManager_7659": {
              "entryPoint": null,
              "id": 7659,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@owner_4202": {
              "entryPoint": 1691,
              "id": 4202,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@push_4289": {
              "entryPoint": 1853,
              "id": 4289,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "@push_4307": {
              "entryPoint": 869,
              "id": 4307,
              "parameterSlots": 2,
              "returnSlots": 0
            },
            "@push_9825": {
              "entryPoint": 2391,
              "id": 9825,
              "parameterSlots": 3,
              "returnSlots": 0
            },
            "@push_9850": {
              "entryPoint": 2931,
              "id": 9850,
              "parameterSlots": 2,
              "returnSlots": 0
            },
            "@resolve_7686": {
              "entryPoint": 1303,
              "id": 7686,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "@setContext_10058": {
              "entryPoint": 3102,
              "id": 10058,
              "parameterSlots": 2,
              "returnSlots": 0
            },
            "@setExtraData_10001": {
              "entryPoint": 2534,
              "id": 10001,
              "parameterSlots": 2,
              "returnSlots": 0
            },
            "@setGlobalMetadata_4249": {
              "entryPoint": 1085,
              "id": 4249,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "abi_decode_bytes27": {
              "entryPoint": 3134,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_address_fromMemory": {
              "entryPoint": 3717,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_bytes27": {
              "entryPoint": 3205,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_bytes32": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_bytes32t_bytes27": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 2
            },
            "abi_decode_tuple_t_string_memory_ptr": {
              "entryPoint": 3286,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_uint256": {
              "entryPoint": 3493,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_uint256t_bytes27": {
              "entryPoint": 3161,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 2
            },
            "abi_encode_tuple_t_address__to_t_address__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_bytes27__to_t_bytes27__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_bytes32__to_t_bytes32__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_contract$_Lib_AddressManager_$7651__to_t_address__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_string_memory_ptr__to_t_string_memory_ptr__fromStack_reversed": {
              "entryPoint": 3518,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_stringliteral_143cf364958987156b6741652451092dcf9a89a975ee67246c378a63b18871c5__to_t_string_memory_ptr__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_stringliteral_566cb80bd1eccf9c1c669aefc3700c326fa85115d56a7f073b4a813f46f088f8__to_t_string_memory_ptr__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "extract_byte_array_length": {
              "entryPoint": 3633,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "increment_t_uint40": {
              "entryPoint": 3771,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "panic_error_0x41": {
              "entryPoint": 3239,
              "id": null,
              "parameterSlots": 0,
              "returnSlots": 0
            }
          },
          "generatedSources": [
            {
              "ast": {
                "nodeType": "YulBlock",
                "src": "0:6163:78",
                "statements": [
                  {
                    "nodeType": "YulBlock",
                    "src": "6:3:78",
                    "statements": []
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "63:171:78",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "73:29:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "offset",
                                "nodeType": "YulIdentifier",
                                "src": "95:6:78"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "82:12:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "82:20:78"
                          },
                          "variableNames": [
                            {
                              "name": "value",
                              "nodeType": "YulIdentifier",
                              "src": "73:5:78"
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "212:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "221:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "224:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "214:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "214:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "214:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "124:5:78"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "value",
                                        "nodeType": "YulIdentifier",
                                        "src": "135:5:78"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "142:66:78",
                                        "type": "",
                                        "value": "0xffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "and",
                                      "nodeType": "YulIdentifier",
                                      "src": "131:3:78"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "131:78:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "eq",
                                  "nodeType": "YulIdentifier",
                                  "src": "121:2:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "121:89:78"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "114:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "114:97:78"
                          },
                          "nodeType": "YulIf",
                          "src": "111:117:78"
                        }
                      ]
                    },
                    "name": "abi_decode_bytes27",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "offset",
                        "nodeType": "YulTypedName",
                        "src": "42:6:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "53:5:78",
                        "type": ""
                      }
                    ],
                    "src": "14:220:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "326:167:78",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "372:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "381:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "384:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "374:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "374:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "374:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "347:7:78"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "356:9:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "343:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "343:23:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "368:2:78",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "339:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "339:32:78"
                          },
                          "nodeType": "YulIf",
                          "src": "336:52:78"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "397:33:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "420:9:78"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "407:12:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "407:23:78"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "397:6:78"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "439:48:78",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "472:9:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "483:2:78",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "468:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "468:18:78"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_bytes27",
                              "nodeType": "YulIdentifier",
                              "src": "449:18:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "449:38:78"
                          },
                          "variableNames": [
                            {
                              "name": "value1",
                              "nodeType": "YulIdentifier",
                              "src": "439:6:78"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_uint256t_bytes27",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "284:9:78",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "295:7:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "307:6:78",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nodeType": "YulTypedName",
                        "src": "315:6:78",
                        "type": ""
                      }
                    ],
                    "src": "239:254:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "599:76:78",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "609:26:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "621:9:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "632:2:78",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "617:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "617:18:78"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "609:4:78"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "651:9:78"
                              },
                              {
                                "name": "value0",
                                "nodeType": "YulIdentifier",
                                "src": "662:6:78"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "644:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "644:25:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "644:25:78"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "568:9:78",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "579:6:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "590:4:78",
                        "type": ""
                      }
                    ],
                    "src": "498:177:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "767:167:78",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "813:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "822:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "825:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "815:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "815:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "815:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "788:7:78"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "797:9:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "784:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "784:23:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "809:2:78",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "780:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "780:32:78"
                          },
                          "nodeType": "YulIf",
                          "src": "777:52:78"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "838:33:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "861:9:78"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "848:12:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "848:23:78"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "838:6:78"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "880:48:78",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "913:9:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "924:2:78",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "909:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "909:18:78"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_bytes27",
                              "nodeType": "YulIdentifier",
                              "src": "890:18:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "890:38:78"
                          },
                          "variableNames": [
                            {
                              "name": "value1",
                              "nodeType": "YulIdentifier",
                              "src": "880:6:78"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_bytes32t_bytes27",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "725:9:78",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "736:7:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "748:6:78",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nodeType": "YulTypedName",
                        "src": "756:6:78",
                        "type": ""
                      }
                    ],
                    "src": "680:254:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1009:116:78",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1055:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1064:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1067:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1057:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1057:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1057:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "1030:7:78"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "1039:9:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "1026:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1026:23:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1051:2:78",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "1022:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1022:32:78"
                          },
                          "nodeType": "YulIf",
                          "src": "1019:52:78"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "1080:39:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1109:9:78"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_bytes27",
                              "nodeType": "YulIdentifier",
                              "src": "1090:18:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1090:29:78"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "1080:6:78"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_bytes27",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "975:9:78",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "986:7:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "998:6:78",
                        "type": ""
                      }
                    ],
                    "src": "939:186:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1258:125:78",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "1268:26:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1280:9:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1291:2:78",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "1276:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1276:18:78"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "1268:4:78"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1310:9:78"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nodeType": "YulIdentifier",
                                    "src": "1325:6:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "1333:42:78",
                                    "type": "",
                                    "value": "0xffffffffffffffffffffffffffffffffffffffff"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "1321:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1321:55:78"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "1303:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1303:74:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1303:74:78"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_contract$_Lib_AddressManager_$7651__to_t_address__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "1227:9:78",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "1238:6:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "1249:4:78",
                        "type": ""
                      }
                    ],
                    "src": "1130:253:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1420:152:78",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1437:1:78",
                                "type": "",
                                "value": "0"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1440:77:78",
                                "type": "",
                                "value": "35408467139433450592217433187231851964531694900788300625387963629091585785856"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "1430:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1430:88:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1430:88:78"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1534:1:78",
                                "type": "",
                                "value": "4"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1537:4:78",
                                "type": "",
                                "value": "0x41"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "1527:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1527:15:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1527:15:78"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1558:1:78",
                                "type": "",
                                "value": "0"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1561:4:78",
                                "type": "",
                                "value": "0x24"
                              }
                            ],
                            "functionName": {
                              "name": "revert",
                              "nodeType": "YulIdentifier",
                              "src": "1551:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1551:15:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1551:15:78"
                        }
                      ]
                    },
                    "name": "panic_error_0x41",
                    "nodeType": "YulFunctionDefinition",
                    "src": "1388:184:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1657:901:78",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1703:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1712:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1715:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1705:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1705:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1705:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "1678:7:78"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "1687:9:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "1674:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1674:23:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1699:2:78",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "1670:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1670:32:78"
                          },
                          "nodeType": "YulIf",
                          "src": "1667:52:78"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "1728:37:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1755:9:78"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "1742:12:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1742:23:78"
                          },
                          "variables": [
                            {
                              "name": "offset",
                              "nodeType": "YulTypedName",
                              "src": "1732:6:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "1774:28:78",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "1784:18:78",
                            "type": "",
                            "value": "0xffffffffffffffff"
                          },
                          "variables": [
                            {
                              "name": "_1",
                              "nodeType": "YulTypedName",
                              "src": "1778:2:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1829:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1838:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1841:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1831:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1831:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1831:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "offset",
                                "nodeType": "YulIdentifier",
                                "src": "1817:6:78"
                              },
                              {
                                "name": "_1",
                                "nodeType": "YulIdentifier",
                                "src": "1825:2:78"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "1814:2:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1814:14:78"
                          },
                          "nodeType": "YulIf",
                          "src": "1811:34:78"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "1854:32:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1868:9:78"
                              },
                              {
                                "name": "offset",
                                "nodeType": "YulIdentifier",
                                "src": "1879:6:78"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "1864:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1864:22:78"
                          },
                          "variables": [
                            {
                              "name": "_2",
                              "nodeType": "YulTypedName",
                              "src": "1858:2:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1934:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1943:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1946:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1936:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1936:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1936:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "name": "_2",
                                        "nodeType": "YulIdentifier",
                                        "src": "1913:2:78"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "1917:4:78",
                                        "type": "",
                                        "value": "0x1f"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "add",
                                      "nodeType": "YulIdentifier",
                                      "src": "1909:3:78"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "1909:13:78"
                                  },
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "1924:7:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "slt",
                                  "nodeType": "YulIdentifier",
                                  "src": "1905:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1905:27:78"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "1898:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1898:35:78"
                          },
                          "nodeType": "YulIf",
                          "src": "1895:55:78"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "1959:26:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "_2",
                                "nodeType": "YulIdentifier",
                                "src": "1982:2:78"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "1969:12:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1969:16:78"
                          },
                          "variables": [
                            {
                              "name": "_3",
                              "nodeType": "YulTypedName",
                              "src": "1963:2:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "2008:22:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "panic_error_0x41",
                                    "nodeType": "YulIdentifier",
                                    "src": "2010:16:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "2010:18:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "2010:18:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "_3",
                                "nodeType": "YulIdentifier",
                                "src": "2000:2:78"
                              },
                              {
                                "name": "_1",
                                "nodeType": "YulIdentifier",
                                "src": "2004:2:78"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "1997:2:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1997:10:78"
                          },
                          "nodeType": "YulIf",
                          "src": "1994:36:78"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "2039:76:78",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "2049:66:78",
                            "type": "",
                            "value": "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0"
                          },
                          "variables": [
                            {
                              "name": "_4",
                              "nodeType": "YulTypedName",
                              "src": "2043:2:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "2124:23:78",
                          "value": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2144:2:78",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "2138:5:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2138:9:78"
                          },
                          "variables": [
                            {
                              "name": "memPtr",
                              "nodeType": "YulTypedName",
                              "src": "2128:6:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "2156:71:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "memPtr",
                                "nodeType": "YulIdentifier",
                                "src": "2178:6:78"
                              },
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "arguments": [
                                              {
                                                "name": "_3",
                                                "nodeType": "YulIdentifier",
                                                "src": "2202:2:78"
                                              },
                                              {
                                                "kind": "number",
                                                "nodeType": "YulLiteral",
                                                "src": "2206:4:78",
                                                "type": "",
                                                "value": "0x1f"
                                              }
                                            ],
                                            "functionName": {
                                              "name": "add",
                                              "nodeType": "YulIdentifier",
                                              "src": "2198:3:78"
                                            },
                                            "nodeType": "YulFunctionCall",
                                            "src": "2198:13:78"
                                          },
                                          {
                                            "name": "_4",
                                            "nodeType": "YulIdentifier",
                                            "src": "2213:2:78"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "and",
                                          "nodeType": "YulIdentifier",
                                          "src": "2194:3:78"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "2194:22:78"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "2218:2:78",
                                        "type": "",
                                        "value": "63"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "add",
                                      "nodeType": "YulIdentifier",
                                      "src": "2190:3:78"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "2190:31:78"
                                  },
                                  {
                                    "name": "_4",
                                    "nodeType": "YulIdentifier",
                                    "src": "2223:2:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "2186:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2186:40:78"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "2174:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2174:53:78"
                          },
                          "variables": [
                            {
                              "name": "newFreePtr",
                              "nodeType": "YulTypedName",
                              "src": "2160:10:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "2286:22:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "panic_error_0x41",
                                    "nodeType": "YulIdentifier",
                                    "src": "2288:16:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "2288:18:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "2288:18:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "newFreePtr",
                                    "nodeType": "YulIdentifier",
                                    "src": "2245:10:78"
                                  },
                                  {
                                    "name": "_1",
                                    "nodeType": "YulIdentifier",
                                    "src": "2257:2:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "gt",
                                  "nodeType": "YulIdentifier",
                                  "src": "2242:2:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2242:18:78"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "newFreePtr",
                                    "nodeType": "YulIdentifier",
                                    "src": "2265:10:78"
                                  },
                                  {
                                    "name": "memPtr",
                                    "nodeType": "YulIdentifier",
                                    "src": "2277:6:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "lt",
                                  "nodeType": "YulIdentifier",
                                  "src": "2262:2:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2262:22:78"
                              }
                            ],
                            "functionName": {
                              "name": "or",
                              "nodeType": "YulIdentifier",
                              "src": "2239:2:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2239:46:78"
                          },
                          "nodeType": "YulIf",
                          "src": "2236:72:78"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2324:2:78",
                                "type": "",
                                "value": "64"
                              },
                              {
                                "name": "newFreePtr",
                                "nodeType": "YulIdentifier",
                                "src": "2328:10:78"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2317:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2317:22:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2317:22:78"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "memPtr",
                                "nodeType": "YulIdentifier",
                                "src": "2355:6:78"
                              },
                              {
                                "name": "_3",
                                "nodeType": "YulIdentifier",
                                "src": "2363:2:78"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2348:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2348:18:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2348:18:78"
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "2412:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "2421:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "2424:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "2414:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "2414:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "2414:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "name": "_2",
                                        "nodeType": "YulIdentifier",
                                        "src": "2389:2:78"
                                      },
                                      {
                                        "name": "_3",
                                        "nodeType": "YulIdentifier",
                                        "src": "2393:2:78"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "add",
                                      "nodeType": "YulIdentifier",
                                      "src": "2385:3:78"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "2385:11:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "2398:2:78",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "2381:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2381:20:78"
                              },
                              {
                                "name": "dataEnd",
                                "nodeType": "YulIdentifier",
                                "src": "2403:7:78"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "2378:2:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2378:33:78"
                          },
                          "nodeType": "YulIf",
                          "src": "2375:53:78"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "memPtr",
                                    "nodeType": "YulIdentifier",
                                    "src": "2454:6:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "2462:2:78",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "2450:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2450:15:78"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "_2",
                                    "nodeType": "YulIdentifier",
                                    "src": "2471:2:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "2475:2:78",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "2467:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2467:11:78"
                              },
                              {
                                "name": "_3",
                                "nodeType": "YulIdentifier",
                                "src": "2480:2:78"
                              }
                            ],
                            "functionName": {
                              "name": "calldatacopy",
                              "nodeType": "YulIdentifier",
                              "src": "2437:12:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2437:46:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2437:46:78"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "name": "memPtr",
                                        "nodeType": "YulIdentifier",
                                        "src": "2507:6:78"
                                      },
                                      {
                                        "name": "_3",
                                        "nodeType": "YulIdentifier",
                                        "src": "2515:2:78"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "add",
                                      "nodeType": "YulIdentifier",
                                      "src": "2503:3:78"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "2503:15:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "2520:2:78",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "2499:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2499:24:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2525:1:78",
                                "type": "",
                                "value": "0"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2492:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2492:35:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2492:35:78"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "2536:16:78",
                          "value": {
                            "name": "memPtr",
                            "nodeType": "YulIdentifier",
                            "src": "2546:6:78"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "2536:6:78"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_string_memory_ptr",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "1623:9:78",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "1634:7:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "1646:6:78",
                        "type": ""
                      }
                    ],
                    "src": "1577:981:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "2664:125:78",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "2674:26:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "2686:9:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2697:2:78",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "2682:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2682:18:78"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "2674:4:78"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "2716:9:78"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nodeType": "YulIdentifier",
                                    "src": "2731:6:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "2739:42:78",
                                    "type": "",
                                    "value": "0xffffffffffffffffffffffffffffffffffffffff"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "2727:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2727:55:78"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2709:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2709:74:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2709:74:78"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_address__to_t_address__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "2633:9:78",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "2644:6:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "2655:4:78",
                        "type": ""
                      }
                    ],
                    "src": "2563:226:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "2864:110:78",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "2910:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "2919:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "2922:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "2912:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "2912:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "2912:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "2885:7:78"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "2894:9:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "2881:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2881:23:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2906:2:78",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "2877:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2877:32:78"
                          },
                          "nodeType": "YulIf",
                          "src": "2874:52:78"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "2935:33:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "2958:9:78"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "2945:12:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2945:23:78"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "2935:6:78"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_uint256",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "2830:9:78",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "2841:7:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "2853:6:78",
                        "type": ""
                      }
                    ],
                    "src": "2794:180:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "3100:535:78",
                      "statements": [
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "3110:12:78",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "3120:2:78",
                            "type": "",
                            "value": "32"
                          },
                          "variables": [
                            {
                              "name": "_1",
                              "nodeType": "YulTypedName",
                              "src": "3114:2:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "3138:9:78"
                              },
                              {
                                "name": "_1",
                                "nodeType": "YulIdentifier",
                                "src": "3149:2:78"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "3131:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3131:21:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3131:21:78"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "3161:27:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "value0",
                                "nodeType": "YulIdentifier",
                                "src": "3181:6:78"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "3175:5:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3175:13:78"
                          },
                          "variables": [
                            {
                              "name": "length",
                              "nodeType": "YulTypedName",
                              "src": "3165:6:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "3208:9:78"
                                  },
                                  {
                                    "name": "_1",
                                    "nodeType": "YulIdentifier",
                                    "src": "3219:2:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "3204:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3204:18:78"
                              },
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "3224:6:78"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "3197:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3197:34:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3197:34:78"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "3240:10:78",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "3249:1:78",
                            "type": "",
                            "value": "0"
                          },
                          "variables": [
                            {
                              "name": "i",
                              "nodeType": "YulTypedName",
                              "src": "3244:1:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "3309:90:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "arguments": [
                                        {
                                          "arguments": [
                                            {
                                              "name": "headStart",
                                              "nodeType": "YulIdentifier",
                                              "src": "3338:9:78"
                                            },
                                            {
                                              "name": "i",
                                              "nodeType": "YulIdentifier",
                                              "src": "3349:1:78"
                                            }
                                          ],
                                          "functionName": {
                                            "name": "add",
                                            "nodeType": "YulIdentifier",
                                            "src": "3334:3:78"
                                          },
                                          "nodeType": "YulFunctionCall",
                                          "src": "3334:17:78"
                                        },
                                        {
                                          "kind": "number",
                                          "nodeType": "YulLiteral",
                                          "src": "3353:2:78",
                                          "type": "",
                                          "value": "64"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "add",
                                        "nodeType": "YulIdentifier",
                                        "src": "3330:3:78"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "3330:26:78"
                                    },
                                    {
                                      "arguments": [
                                        {
                                          "arguments": [
                                            {
                                              "arguments": [
                                                {
                                                  "name": "value0",
                                                  "nodeType": "YulIdentifier",
                                                  "src": "3372:6:78"
                                                },
                                                {
                                                  "name": "i",
                                                  "nodeType": "YulIdentifier",
                                                  "src": "3380:1:78"
                                                }
                                              ],
                                              "functionName": {
                                                "name": "add",
                                                "nodeType": "YulIdentifier",
                                                "src": "3368:3:78"
                                              },
                                              "nodeType": "YulFunctionCall",
                                              "src": "3368:14:78"
                                            },
                                            {
                                              "name": "_1",
                                              "nodeType": "YulIdentifier",
                                              "src": "3384:2:78"
                                            }
                                          ],
                                          "functionName": {
                                            "name": "add",
                                            "nodeType": "YulIdentifier",
                                            "src": "3364:3:78"
                                          },
                                          "nodeType": "YulFunctionCall",
                                          "src": "3364:23:78"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "mload",
                                        "nodeType": "YulIdentifier",
                                        "src": "3358:5:78"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "3358:30:78"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "3323:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "3323:66:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "3323:66:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "i",
                                "nodeType": "YulIdentifier",
                                "src": "3270:1:78"
                              },
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "3273:6:78"
                              }
                            ],
                            "functionName": {
                              "name": "lt",
                              "nodeType": "YulIdentifier",
                              "src": "3267:2:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3267:13:78"
                          },
                          "nodeType": "YulForLoop",
                          "post": {
                            "nodeType": "YulBlock",
                            "src": "3281:19:78",
                            "statements": [
                              {
                                "nodeType": "YulAssignment",
                                "src": "3283:15:78",
                                "value": {
                                  "arguments": [
                                    {
                                      "name": "i",
                                      "nodeType": "YulIdentifier",
                                      "src": "3292:1:78"
                                    },
                                    {
                                      "name": "_1",
                                      "nodeType": "YulIdentifier",
                                      "src": "3295:2:78"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "add",
                                    "nodeType": "YulIdentifier",
                                    "src": "3288:3:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "3288:10:78"
                                },
                                "variableNames": [
                                  {
                                    "name": "i",
                                    "nodeType": "YulIdentifier",
                                    "src": "3283:1:78"
                                  }
                                ]
                              }
                            ]
                          },
                          "pre": {
                            "nodeType": "YulBlock",
                            "src": "3263:3:78",
                            "statements": []
                          },
                          "src": "3259:140:78"
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "3433:66:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "arguments": [
                                        {
                                          "arguments": [
                                            {
                                              "name": "headStart",
                                              "nodeType": "YulIdentifier",
                                              "src": "3462:9:78"
                                            },
                                            {
                                              "name": "length",
                                              "nodeType": "YulIdentifier",
                                              "src": "3473:6:78"
                                            }
                                          ],
                                          "functionName": {
                                            "name": "add",
                                            "nodeType": "YulIdentifier",
                                            "src": "3458:3:78"
                                          },
                                          "nodeType": "YulFunctionCall",
                                          "src": "3458:22:78"
                                        },
                                        {
                                          "kind": "number",
                                          "nodeType": "YulLiteral",
                                          "src": "3482:2:78",
                                          "type": "",
                                          "value": "64"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "add",
                                        "nodeType": "YulIdentifier",
                                        "src": "3454:3:78"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "3454:31:78"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "3487:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "3447:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "3447:42:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "3447:42:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "i",
                                "nodeType": "YulIdentifier",
                                "src": "3414:1:78"
                              },
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "3417:6:78"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "3411:2:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3411:13:78"
                          },
                          "nodeType": "YulIf",
                          "src": "3408:91:78"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "3508:121:78",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "3524:9:78"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "name": "length",
                                            "nodeType": "YulIdentifier",
                                            "src": "3543:6:78"
                                          },
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "3551:2:78",
                                            "type": "",
                                            "value": "31"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "add",
                                          "nodeType": "YulIdentifier",
                                          "src": "3539:3:78"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "3539:15:78"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "3556:66:78",
                                        "type": "",
                                        "value": "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "and",
                                      "nodeType": "YulIdentifier",
                                      "src": "3535:3:78"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "3535:88:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "3520:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3520:104:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3626:2:78",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "3516:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3516:113:78"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "3508:4:78"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_string_memory_ptr__to_t_string_memory_ptr__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "3069:9:78",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "3080:6:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "3091:4:78",
                        "type": ""
                      }
                    ],
                    "src": "2979:656:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "3741:76:78",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "3751:26:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "3763:9:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3774:2:78",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "3759:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3759:18:78"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "3751:4:78"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "3793:9:78"
                              },
                              {
                                "name": "value0",
                                "nodeType": "YulIdentifier",
                                "src": "3804:6:78"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "3786:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3786:25:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3786:25:78"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_bytes32__to_t_bytes32__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "3710:9:78",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "3721:6:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "3732:4:78",
                        "type": ""
                      }
                    ],
                    "src": "3640:177:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "3892:110:78",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "3938:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "3947:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "3950:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "3940:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "3940:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "3940:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "3913:7:78"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "3922:9:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "3909:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3909:23:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3934:2:78",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "3905:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3905:32:78"
                          },
                          "nodeType": "YulIf",
                          "src": "3902:52:78"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "3963:33:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "3986:9:78"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "3973:12:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3973:23:78"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "3963:6:78"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_bytes32",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "3858:9:78",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "3869:7:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "3881:6:78",
                        "type": ""
                      }
                    ],
                    "src": "3822:180:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "4108:149:78",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "4118:26:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "4130:9:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "4141:2:78",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "4126:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4126:18:78"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "4118:4:78"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "4160:9:78"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nodeType": "YulIdentifier",
                                    "src": "4175:6:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "4183:66:78",
                                    "type": "",
                                    "value": "0xffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "4171:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4171:79:78"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "4153:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4153:98:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "4153:98:78"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_bytes27__to_t_bytes27__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "4077:9:78",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "4088:6:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "4099:4:78",
                        "type": ""
                      }
                    ],
                    "src": "4007:250:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "4317:382:78",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "4327:22:78",
                          "value": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "4341:1:78",
                                "type": "",
                                "value": "1"
                              },
                              {
                                "name": "data",
                                "nodeType": "YulIdentifier",
                                "src": "4344:4:78"
                              }
                            ],
                            "functionName": {
                              "name": "shr",
                              "nodeType": "YulIdentifier",
                              "src": "4337:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4337:12:78"
                          },
                          "variableNames": [
                            {
                              "name": "length",
                              "nodeType": "YulIdentifier",
                              "src": "4327:6:78"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "4358:38:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "data",
                                "nodeType": "YulIdentifier",
                                "src": "4388:4:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "4394:1:78",
                                "type": "",
                                "value": "1"
                              }
                            ],
                            "functionName": {
                              "name": "and",
                              "nodeType": "YulIdentifier",
                              "src": "4384:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4384:12:78"
                          },
                          "variables": [
                            {
                              "name": "outOfPlaceEncoding",
                              "nodeType": "YulTypedName",
                              "src": "4362:18:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "4435:31:78",
                            "statements": [
                              {
                                "nodeType": "YulAssignment",
                                "src": "4437:27:78",
                                "value": {
                                  "arguments": [
                                    {
                                      "name": "length",
                                      "nodeType": "YulIdentifier",
                                      "src": "4451:6:78"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4459:4:78",
                                      "type": "",
                                      "value": "0x7f"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "and",
                                    "nodeType": "YulIdentifier",
                                    "src": "4447:3:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "4447:17:78"
                                },
                                "variableNames": [
                                  {
                                    "name": "length",
                                    "nodeType": "YulIdentifier",
                                    "src": "4437:6:78"
                                  }
                                ]
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "outOfPlaceEncoding",
                                "nodeType": "YulIdentifier",
                                "src": "4415:18:78"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "4408:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4408:26:78"
                          },
                          "nodeType": "YulIf",
                          "src": "4405:61:78"
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "4525:168:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4546:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4549:77:78",
                                      "type": "",
                                      "value": "35408467139433450592217433187231851964531694900788300625387963629091585785856"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "4539:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "4539:88:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "4539:88:78"
                              },
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4647:1:78",
                                      "type": "",
                                      "value": "4"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4650:4:78",
                                      "type": "",
                                      "value": "0x22"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "4640:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "4640:15:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "4640:15:78"
                              },
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4675:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4678:4:78",
                                      "type": "",
                                      "value": "0x24"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "4668:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "4668:15:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "4668:15:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "outOfPlaceEncoding",
                                "nodeType": "YulIdentifier",
                                "src": "4481:18:78"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "length",
                                    "nodeType": "YulIdentifier",
                                    "src": "4504:6:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "4512:2:78",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "lt",
                                  "nodeType": "YulIdentifier",
                                  "src": "4501:2:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4501:14:78"
                              }
                            ],
                            "functionName": {
                              "name": "eq",
                              "nodeType": "YulIdentifier",
                              "src": "4478:2:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4478:38:78"
                          },
                          "nodeType": "YulIf",
                          "src": "4475:218:78"
                        }
                      ]
                    },
                    "name": "extract_byte_array_length",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "data",
                        "nodeType": "YulTypedName",
                        "src": "4297:4:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "length",
                        "nodeType": "YulTypedName",
                        "src": "4306:6:78",
                        "type": ""
                      }
                    ],
                    "src": "4262:437:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "4878:254:78",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "4895:9:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "4906:2:78",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "4888:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4888:21:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "4888:21:78"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "4929:9:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "4940:2:78",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "4925:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4925:18:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "4945:2:78",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "4918:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4918:30:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "4918:30:78"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "4968:9:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "4979:2:78",
                                    "type": "",
                                    "value": "64"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "4964:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4964:18:78"
                              },
                              {
                                "hexValue": "436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e20",
                                "kind": "string",
                                "nodeType": "YulLiteral",
                                "src": "4984:34:78",
                                "type": "",
                                "value": "ChainStorageContainer: Function "
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "4957:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4957:62:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "4957:62:78"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "5039:9:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "5050:2:78",
                                    "type": "",
                                    "value": "96"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "5035:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "5035:18:78"
                              },
                              {
                                "hexValue": "63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e",
                                "kind": "string",
                                "nodeType": "YulLiteral",
                                "src": "5055:34:78",
                                "type": "",
                                "value": "can only be called by the owner."
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "5028:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5028:62:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "5028:62:78"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "5099:27:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "5111:9:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5122:3:78",
                                "type": "",
                                "value": "128"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "5107:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5107:19:78"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "5099:4:78"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_stringliteral_143cf364958987156b6741652451092dcf9a89a975ee67246c378a63b18871c5__to_t_string_memory_ptr__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "4855:9:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "4869:4:78",
                        "type": ""
                      }
                    ],
                    "src": "4704:428:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "5218:232:78",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "5264:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "5273:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "5276:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "5266:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "5266:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "5266:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "5239:7:78"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "5248:9:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "5235:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "5235:23:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5260:2:78",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "5231:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5231:32:78"
                          },
                          "nodeType": "YulIf",
                          "src": "5228:52:78"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "5289:29:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "5308:9:78"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "5302:5:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5302:16:78"
                          },
                          "variables": [
                            {
                              "name": "value",
                              "nodeType": "YulTypedName",
                              "src": "5293:5:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "5404:16:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "5413:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "5416:1:78",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "5406:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "5406:12:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "5406:12:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "5340:5:78"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "value",
                                        "nodeType": "YulIdentifier",
                                        "src": "5351:5:78"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "5358:42:78",
                                        "type": "",
                                        "value": "0xffffffffffffffffffffffffffffffffffffffff"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "and",
                                      "nodeType": "YulIdentifier",
                                      "src": "5347:3:78"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "5347:54:78"
                                  }
                                ],
                                "functionName": {
                                  "name": "eq",
                                  "nodeType": "YulIdentifier",
                                  "src": "5337:2:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "5337:65:78"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "5330:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5330:73:78"
                          },
                          "nodeType": "YulIf",
                          "src": "5327:93:78"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "5429:15:78",
                          "value": {
                            "name": "value",
                            "nodeType": "YulIdentifier",
                            "src": "5439:5:78"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "5429:6:78"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_address_fromMemory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "5184:9:78",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "5195:7:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "5207:6:78",
                        "type": ""
                      }
                    ],
                    "src": "5137:313:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "5629:170:78",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "5646:9:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5657:2:78",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "5639:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5639:21:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "5639:21:78"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "5680:9:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "5691:2:78",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "5676:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "5676:18:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5696:2:78",
                                "type": "",
                                "value": "20"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "5669:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5669:30:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "5669:30:78"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "5719:9:78"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "5730:2:78",
                                    "type": "",
                                    "value": "64"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "5715:3:78"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "5715:18:78"
                              },
                              {
                                "hexValue": "496e646578206f7574206f6620626f756e64732e",
                                "kind": "string",
                                "nodeType": "YulLiteral",
                                "src": "5735:22:78",
                                "type": "",
                                "value": "Index out of bounds."
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "5708:6:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5708:50:78"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "5708:50:78"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "5767:26:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "5779:9:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5790:2:78",
                                "type": "",
                                "value": "96"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "5775:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5775:18:78"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "5767:4:78"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_stringliteral_566cb80bd1eccf9c1c669aefc3700c326fa85115d56a7f073b4a813f46f088f8__to_t_string_memory_ptr__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "5606:9:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "5620:4:78",
                        "type": ""
                      }
                    ],
                    "src": "5455:344:78"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "5850:311:78",
                      "statements": [
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "5860:22:78",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "5870:12:78",
                            "type": "",
                            "value": "0xffffffffff"
                          },
                          "variables": [
                            {
                              "name": "_1",
                              "nodeType": "YulTypedName",
                              "src": "5864:2:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "5891:29:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "value",
                                "nodeType": "YulIdentifier",
                                "src": "5910:5:78"
                              },
                              {
                                "name": "_1",
                                "nodeType": "YulIdentifier",
                                "src": "5917:2:78"
                              }
                            ],
                            "functionName": {
                              "name": "and",
                              "nodeType": "YulIdentifier",
                              "src": "5906:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5906:14:78"
                          },
                          "variables": [
                            {
                              "name": "value_1",
                              "nodeType": "YulTypedName",
                              "src": "5895:7:78",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "5956:168:78",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "5977:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "5980:77:78",
                                      "type": "",
                                      "value": "35408467139433450592217433187231851964531694900788300625387963629091585785856"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "5970:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "5970:88:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "5970:88:78"
                              },
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "6078:1:78",
                                      "type": "",
                                      "value": "4"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "6081:4:78",
                                      "type": "",
                                      "value": "0x11"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "6071:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "6071:15:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "6071:15:78"
                              },
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "6106:1:78",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "6109:4:78",
                                      "type": "",
                                      "value": "0x24"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "6099:6:78"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "6099:15:78"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "6099:15:78"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "value_1",
                                "nodeType": "YulIdentifier",
                                "src": "5935:7:78"
                              },
                              {
                                "name": "_1",
                                "nodeType": "YulIdentifier",
                                "src": "5944:2:78"
                              }
                            ],
                            "functionName": {
                              "name": "eq",
                              "nodeType": "YulIdentifier",
                              "src": "5932:2:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5932:15:78"
                          },
                          "nodeType": "YulIf",
                          "src": "5929:195:78"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "6133:22:78",
                          "value": {
                            "arguments": [
                              {
                                "name": "value_1",
                                "nodeType": "YulIdentifier",
                                "src": "6144:7:78"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "6153:1:78",
                                "type": "",
                                "value": "1"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "6140:3:78"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "6140:15:78"
                          },
                          "variableNames": [
                            {
                              "name": "ret",
                              "nodeType": "YulIdentifier",
                              "src": "6133:3:78"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "increment_t_uint40",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "5832:5:78",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "ret",
                        "nodeType": "YulTypedName",
                        "src": "5842:3:78",
                        "type": ""
                      }
                    ],
                    "src": "5804:357:78"
                  }
                ]
              },
              "contents": "{\n    { }\n    function abi_decode_bytes27(offset) -> value\n    {\n        value := calldataload(offset)\n        if iszero(eq(value, and(value, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000))) { revert(0, 0) }\n    }\n    function abi_decode_tuple_t_uint256t_bytes27(headStart, dataEnd) -> value0, value1\n    {\n        if slt(sub(dataEnd, headStart), 64) { revert(0, 0) }\n        value0 := calldataload(headStart)\n        value1 := abi_decode_bytes27(add(headStart, 32))\n    }\n    function abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, value0)\n    }\n    function abi_decode_tuple_t_bytes32t_bytes27(headStart, dataEnd) -> value0, value1\n    {\n        if slt(sub(dataEnd, headStart), 64) { revert(0, 0) }\n        value0 := calldataload(headStart)\n        value1 := abi_decode_bytes27(add(headStart, 32))\n    }\n    function abi_decode_tuple_t_bytes27(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        value0 := abi_decode_bytes27(headStart)\n    }\n    function abi_encode_tuple_t_contract$_Lib_AddressManager_$7651__to_t_address__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, and(value0, 0xffffffffffffffffffffffffffffffffffffffff))\n    }\n    function panic_error_0x41()\n    {\n        mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)\n        mstore(4, 0x41)\n        revert(0, 0x24)\n    }\n    function abi_decode_tuple_t_string_memory_ptr(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        let offset := calldataload(headStart)\n        let _1 := 0xffffffffffffffff\n        if gt(offset, _1) { revert(0, 0) }\n        let _2 := add(headStart, offset)\n        if iszero(slt(add(_2, 0x1f), dataEnd)) { revert(0, 0) }\n        let _3 := calldataload(_2)\n        if gt(_3, _1) { panic_error_0x41() }\n        let _4 := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\n        let memPtr := mload(64)\n        let newFreePtr := add(memPtr, and(add(and(add(_3, 0x1f), _4), 63), _4))\n        if or(gt(newFreePtr, _1), lt(newFreePtr, memPtr)) { panic_error_0x41() }\n        mstore(64, newFreePtr)\n        mstore(memPtr, _3)\n        if gt(add(add(_2, _3), 32), dataEnd) { revert(0, 0) }\n        calldatacopy(add(memPtr, 32), add(_2, 32), _3)\n        mstore(add(add(memPtr, _3), 32), 0)\n        value0 := memPtr\n    }\n    function abi_encode_tuple_t_address__to_t_address__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, and(value0, 0xffffffffffffffffffffffffffffffffffffffff))\n    }\n    function abi_decode_tuple_t_uint256(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        value0 := calldataload(headStart)\n    }\n    function abi_encode_tuple_t_string_memory_ptr__to_t_string_memory_ptr__fromStack_reversed(headStart, value0) -> tail\n    {\n        let _1 := 32\n        mstore(headStart, _1)\n        let length := mload(value0)\n        mstore(add(headStart, _1), length)\n        let i := 0\n        for { } lt(i, length) { i := add(i, _1) }\n        {\n            mstore(add(add(headStart, i), 64), mload(add(add(value0, i), _1)))\n        }\n        if gt(i, length)\n        {\n            mstore(add(add(headStart, length), 64), 0)\n        }\n        tail := add(add(headStart, and(add(length, 31), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0)), 64)\n    }\n    function abi_encode_tuple_t_bytes32__to_t_bytes32__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, value0)\n    }\n    function abi_decode_tuple_t_bytes32(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        value0 := calldataload(headStart)\n    }\n    function abi_encode_tuple_t_bytes27__to_t_bytes27__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, and(value0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000))\n    }\n    function extract_byte_array_length(data) -> length\n    {\n        length := shr(1, data)\n        let outOfPlaceEncoding := and(data, 1)\n        if iszero(outOfPlaceEncoding) { length := and(length, 0x7f) }\n        if eq(outOfPlaceEncoding, lt(length, 32))\n        {\n            mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)\n            mstore(4, 0x22)\n            revert(0, 0x24)\n        }\n    }\n    function abi_encode_tuple_t_stringliteral_143cf364958987156b6741652451092dcf9a89a975ee67246c378a63b18871c5__to_t_string_memory_ptr__fromStack_reversed(headStart) -> tail\n    {\n        mstore(headStart, 32)\n        mstore(add(headStart, 32), 64)\n        mstore(add(headStart, 64), \"ChainStorageContainer: Function \")\n        mstore(add(headStart, 96), \"can only be called by the owner.\")\n        tail := add(headStart, 128)\n    }\n    function abi_decode_tuple_t_address_fromMemory(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        let value := mload(headStart)\n        if iszero(eq(value, and(value, 0xffffffffffffffffffffffffffffffffffffffff))) { revert(0, 0) }\n        value0 := value\n    }\n    function abi_encode_tuple_t_stringliteral_566cb80bd1eccf9c1c669aefc3700c326fa85115d56a7f073b4a813f46f088f8__to_t_string_memory_ptr__fromStack_reversed(headStart) -> tail\n    {\n        mstore(headStart, 32)\n        mstore(add(headStart, 32), 20)\n        mstore(add(headStart, 64), \"Index out of bounds.\")\n        tail := add(headStart, 96)\n    }\n    function increment_t_uint40(value) -> ret\n    {\n        let _1 := 0xffffffffff\n        let value_1 := and(value, _1)\n        if eq(value_1, _1)\n        {\n            mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)\n            mstore(4, 0x11)\n            revert(0, 0x24)\n        }\n        ret := add(value_1, 1)\n    }\n}",
              "id": 78,
              "language": "Yul",
              "name": "#utility.yul"
            }
          ],
          "immutableReferences": {},
          "linkReferences": {},
          "object": "608060405234801561001057600080fd5b50600436106100c95760003560e01c8063461a4478116100815780639507d39a1161005b5780639507d39a146101a4578063b298e36b146101b7578063ccf8f969146101ca57600080fd5b8063461a4478146101695780634651d91e1461017c5780638da5cb5b1461018f57600080fd5b80632015276c116100b25780632015276c146100fe57806329061de214610111578063299ca4781461012457600080fd5b8063167fd681146100ce5780631f7b6d32146100e3575b600080fd5b6100e16100dc366004610c59565b6101e9565b005b6100eb61034d565b6040519081526020015b60405180910390f35b6100e161010c366004610c59565b610365565b6100e161011f366004610c85565b61043d565b6000546101449073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100f5565b610144610177366004610cd6565b610517565b6100e161018a366004610da5565b6105c4565b61019761069b565b6040516100f59190610dbe565b6100eb6101b2366004610da5565b610729565b6100e16101c5366004610da5565b61073d565b6101d2610814565b60405164ffffffffff1990911681526020016100f5565b61027c600180546101f990610e31565b80601f016020809104026020016040519081016040528092919081815260200182805461022590610e31565b80156102725780601f1061024757610100808354040283529160200191610272565b820191906000526020600020905b81548152906001019060200180831161025557829003601f168201915b5050505050610517565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461033d57604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e60648201526084015b60405180910390fd5b61034960028383610825565b5050565b6000610359600261090c565b64ffffffffff16905090565b610375600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461043157604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b61034960028383610957565b61044d600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461050957604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b6105146002826109e6565b50565b600080546040517fbf40fac100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091169063bf40fac19061056e908590600401610dbe565b60206040518083038186803b15801561058657600080fd5b505afa15801561059a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105be9190610e85565b92915050565b6105d4600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461069057604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b610514600282610a47565b600180546106a890610e31565b80601f01602080910402602001604051908101604052809291908181526020018280546106d490610e31565b80156107215780601f106106f657610100808354040283529160200191610721565b820191906000526020600020905b81548152906001019060200180831161070457829003601f168201915b505050505081565b60006105be600264ffffffffff8416610aa4565b61074d600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461080957604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b610514600282610b73565b60006108206002610bd0565b905090565b600061086784604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b9050806000015164ffffffffff168364ffffffffff16106108e4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f496e646578206f7574206f6620626f756e64732e0000000000000000000000006044820152606401610334565b64ffffffffff8316815264ffffffffff19821660208201526109068482610c1e565b50505050565b60008061094f83604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b519392505050565b600061099984604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b805164ffffffffff16600090815260018601602052604090208490558051909150816109c482610ebb565b64ffffffffff1690525064ffffffffff19821660208201526109068482610c1e565b6000610a2883604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b64ffffffffff19831660208201529050610a428382610c1e565b505050565b6000610a8983604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b9050610a42828260200151856108259092919063ffffffff16565b600080610ae784604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b805190915064ffffffffff168310610b5b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f496e646578206f7574206f6620626f756e64732e0000000000000000000000006044820152606401610334565b50506000908152600191909101602052604090205490565b6000610bb583604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b9050610a42828260200151856109579092919063ffffffff16565b600080610c1383604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b602001519392505050565b8051602082015183548183179291908314610c37578285555b5050505050565b803564ffffffffff1981168114610c5457600080fd5b919050565b60008060408385031215610c6c57600080fd5b82359150610c7c60208401610c3e565b90509250929050565b600060208284031215610c9757600080fd5b610ca082610c3e565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208284031215610ce857600080fd5b813567ffffffffffffffff80821115610d0057600080fd5b818401915084601f830112610d1457600080fd5b813581811115610d2657610d26610ca7565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715610d6c57610d6c610ca7565b81604052828152876020848701011115610d8557600080fd5b826020860160208301376000928101602001929092525095945050505050565b600060208284031215610db757600080fd5b5035919050565b600060208083528351808285015260005b81811015610deb57858101830151858201604001528201610dcf565b81811115610dfd576000604083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016929092016040019392505050565b600181811c90821680610e4557607f821691505b60208210811415610e7f577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b600060208284031215610e9757600080fd5b815173ffffffffffffffffffffffffffffffffffffffff81168114610ca057600080fd5b600064ffffffffff80831681811415610efd577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600101939250505056fea2646970667358221220e1995ee56c4c5e67de41c56ad510b16704727d3ab1fa5bb2e3c62b0bd7c0597564736f6c63430008090033",
          "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0xC9 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x461A4478 GT PUSH2 0x81 JUMPI DUP1 PUSH4 0x9507D39A GT PUSH2 0x5B JUMPI DUP1 PUSH4 0x9507D39A EQ PUSH2 0x1A4 JUMPI DUP1 PUSH4 0xB298E36B EQ PUSH2 0x1B7 JUMPI DUP1 PUSH4 0xCCF8F969 EQ PUSH2 0x1CA JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 PUSH4 0x461A4478 EQ PUSH2 0x169 JUMPI DUP1 PUSH4 0x4651D91E EQ PUSH2 0x17C JUMPI DUP1 PUSH4 0x8DA5CB5B EQ PUSH2 0x18F JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 PUSH4 0x2015276C GT PUSH2 0xB2 JUMPI DUP1 PUSH4 0x2015276C EQ PUSH2 0xFE JUMPI DUP1 PUSH4 0x29061DE2 EQ PUSH2 0x111 JUMPI DUP1 PUSH4 0x299CA478 EQ PUSH2 0x124 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 PUSH4 0x167FD681 EQ PUSH2 0xCE JUMPI DUP1 PUSH4 0x1F7B6D32 EQ PUSH2 0xE3 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xE1 PUSH2 0xDC CALLDATASIZE PUSH1 0x4 PUSH2 0xC59 JUMP JUMPDEST PUSH2 0x1E9 JUMP JUMPDEST STOP JUMPDEST PUSH2 0xEB PUSH2 0x34D JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0xE1 PUSH2 0x10C CALLDATASIZE PUSH1 0x4 PUSH2 0xC59 JUMP JUMPDEST PUSH2 0x365 JUMP JUMPDEST PUSH2 0xE1 PUSH2 0x11F CALLDATASIZE PUSH1 0x4 PUSH2 0xC85 JUMP JUMPDEST PUSH2 0x43D JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH2 0x144 SWAP1 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD PUSH2 0xF5 JUMP JUMPDEST PUSH2 0x144 PUSH2 0x177 CALLDATASIZE PUSH1 0x4 PUSH2 0xCD6 JUMP JUMPDEST PUSH2 0x517 JUMP JUMPDEST PUSH2 0xE1 PUSH2 0x18A CALLDATASIZE PUSH1 0x4 PUSH2 0xDA5 JUMP JUMPDEST PUSH2 0x5C4 JUMP JUMPDEST PUSH2 0x197 PUSH2 0x69B JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0xF5 SWAP2 SWAP1 PUSH2 0xDBE JUMP JUMPDEST PUSH2 0xEB PUSH2 0x1B2 CALLDATASIZE PUSH1 0x4 PUSH2 0xDA5 JUMP JUMPDEST PUSH2 0x729 JUMP JUMPDEST PUSH2 0xE1 PUSH2 0x1C5 CALLDATASIZE PUSH1 0x4 PUSH2 0xDA5 JUMP JUMPDEST PUSH2 0x73D JUMP JUMPDEST PUSH2 0x1D2 PUSH2 0x814 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD PUSH2 0xF5 JUMP JUMPDEST PUSH2 0x27C PUSH1 0x1 DUP1 SLOAD PUSH2 0x1F9 SWAP1 PUSH2 0xE31 JUMP JUMPDEST DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP1 SLOAD PUSH2 0x225 SWAP1 PUSH2 0xE31 JUMP JUMPDEST DUP1 ISZERO PUSH2 0x272 JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x247 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x272 JUMP JUMPDEST DUP3 ADD SWAP2 SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 KECCAK256 SWAP1 JUMPDEST DUP2 SLOAD DUP2 MSTORE SWAP1 PUSH1 0x1 ADD SWAP1 PUSH1 0x20 ADD DUP1 DUP4 GT PUSH2 0x255 JUMPI DUP3 SWAP1 SUB PUSH1 0x1F AND DUP3 ADD SWAP2 JUMPDEST POP POP POP POP POP PUSH2 0x517 JUMP JUMPDEST PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ PUSH2 0x33D JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x24 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH32 0x436861696E53746F72616765436F6E7461696E65723A2046756E6374696F6E20 PUSH1 0x44 DUP3 ADD MSTORE PUSH32 0x63616E206F6E6C792062652063616C6C656420627920746865206F776E65722E PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH2 0x349 PUSH1 0x2 DUP4 DUP4 PUSH2 0x825 JUMP JUMPDEST POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0x359 PUSH1 0x2 PUSH2 0x90C JUMP JUMPDEST PUSH5 0xFFFFFFFFFF AND SWAP1 POP SWAP1 JUMP JUMPDEST PUSH2 0x375 PUSH1 0x1 DUP1 SLOAD PUSH2 0x1F9 SWAP1 PUSH2 0xE31 JUMP JUMPDEST PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ PUSH2 0x431 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x24 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH32 0x436861696E53746F72616765436F6E7461696E65723A2046756E6374696F6E20 PUSH1 0x44 DUP3 ADD MSTORE PUSH32 0x63616E206F6E6C792062652063616C6C656420627920746865206F776E65722E PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 ADD PUSH2 0x334 JUMP JUMPDEST PUSH2 0x349 PUSH1 0x2 DUP4 DUP4 PUSH2 0x957 JUMP JUMPDEST PUSH2 0x44D PUSH1 0x1 DUP1 SLOAD PUSH2 0x1F9 SWAP1 PUSH2 0xE31 JUMP JUMPDEST PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ PUSH2 0x509 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x24 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH32 0x436861696E53746F72616765436F6E7461696E65723A2046756E6374696F6E20 PUSH1 0x44 DUP3 ADD MSTORE PUSH32 0x63616E206F6E6C792062652063616C6C656420627920746865206F776E65722E PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 ADD PUSH2 0x334 JUMP JUMPDEST PUSH2 0x514 PUSH1 0x2 DUP3 PUSH2 0x9E6 JUMP JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH1 0x40 MLOAD PUSH32 0xBF40FAC100000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF SWAP1 SWAP2 AND SWAP1 PUSH4 0xBF40FAC1 SWAP1 PUSH2 0x56E SWAP1 DUP6 SWAP1 PUSH1 0x4 ADD PUSH2 0xDBE JUMP JUMPDEST PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x586 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x59A JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x5BE SWAP2 SWAP1 PUSH2 0xE85 JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH2 0x5D4 PUSH1 0x1 DUP1 SLOAD PUSH2 0x1F9 SWAP1 PUSH2 0xE31 JUMP JUMPDEST PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ PUSH2 0x690 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x24 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH32 0x436861696E53746F72616765436F6E7461696E65723A2046756E6374696F6E20 PUSH1 0x44 DUP3 ADD MSTORE PUSH32 0x63616E206F6E6C792062652063616C6C656420627920746865206F776E65722E PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 ADD PUSH2 0x334 JUMP JUMPDEST PUSH2 0x514 PUSH1 0x2 DUP3 PUSH2 0xA47 JUMP JUMPDEST PUSH1 0x1 DUP1 SLOAD PUSH2 0x6A8 SWAP1 PUSH2 0xE31 JUMP JUMPDEST DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP1 SLOAD PUSH2 0x6D4 SWAP1 PUSH2 0xE31 JUMP JUMPDEST DUP1 ISZERO PUSH2 0x721 JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x6F6 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x721 JUMP JUMPDEST DUP3 ADD SWAP2 SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 KECCAK256 SWAP1 JUMPDEST DUP2 SLOAD DUP2 MSTORE SWAP1 PUSH1 0x1 ADD SWAP1 PUSH1 0x20 ADD DUP1 DUP4 GT PUSH2 0x704 JUMPI DUP3 SWAP1 SUB PUSH1 0x1F AND DUP3 ADD SWAP2 JUMPDEST POP POP POP POP POP DUP2 JUMP JUMPDEST PUSH1 0x0 PUSH2 0x5BE PUSH1 0x2 PUSH5 0xFFFFFFFFFF DUP5 AND PUSH2 0xAA4 JUMP JUMPDEST PUSH2 0x74D PUSH1 0x1 DUP1 SLOAD PUSH2 0x1F9 SWAP1 PUSH2 0xE31 JUMP JUMPDEST PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ PUSH2 0x809 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x24 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH32 0x436861696E53746F72616765436F6E7461696E65723A2046756E6374696F6E20 PUSH1 0x44 DUP3 ADD MSTORE PUSH32 0x63616E206F6E6C792062652063616C6C656420627920746865206F776E65722E PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 ADD PUSH2 0x334 JUMP JUMPDEST PUSH2 0x514 PUSH1 0x2 DUP3 PUSH2 0xB73 JUMP JUMPDEST PUSH1 0x0 PUSH2 0x820 PUSH1 0x2 PUSH2 0xBD0 JUMP JUMPDEST SWAP1 POP SWAP1 JUMP JUMPDEST PUSH1 0x0 PUSH2 0x867 DUP5 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST SWAP1 POP DUP1 PUSH1 0x0 ADD MLOAD PUSH5 0xFFFFFFFFFF AND DUP4 PUSH5 0xFFFFFFFFFF AND LT PUSH2 0x8E4 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x14 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x496E646578206F7574206F6620626F756E64732E000000000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE PUSH1 0x64 ADD PUSH2 0x334 JUMP JUMPDEST PUSH5 0xFFFFFFFFFF DUP4 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT DUP3 AND PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x906 DUP5 DUP3 PUSH2 0xC1E JUMP JUMPDEST POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH2 0x94F DUP4 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST MLOAD SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0x999 DUP5 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST DUP1 MLOAD PUSH5 0xFFFFFFFFFF AND PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x1 DUP7 ADD PUSH1 0x20 MSTORE PUSH1 0x40 SWAP1 KECCAK256 DUP5 SWAP1 SSTORE DUP1 MLOAD SWAP1 SWAP2 POP DUP2 PUSH2 0x9C4 DUP3 PUSH2 0xEBB JUMP JUMPDEST PUSH5 0xFFFFFFFFFF AND SWAP1 MSTORE POP PUSH5 0xFFFFFFFFFF NOT DUP3 AND PUSH1 0x20 DUP3 ADD MSTORE PUSH2 0x906 DUP5 DUP3 PUSH2 0xC1E JUMP JUMPDEST PUSH1 0x0 PUSH2 0xA28 DUP4 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST PUSH5 0xFFFFFFFFFF NOT DUP4 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 POP PUSH2 0xA42 DUP4 DUP3 PUSH2 0xC1E JUMP JUMPDEST POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xA89 DUP4 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST SWAP1 POP PUSH2 0xA42 DUP3 DUP3 PUSH1 0x20 ADD MLOAD DUP6 PUSH2 0x825 SWAP1 SWAP3 SWAP2 SWAP1 PUSH4 0xFFFFFFFF AND JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH2 0xAE7 DUP5 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST DUP1 MLOAD SWAP1 SWAP2 POP PUSH5 0xFFFFFFFFFF AND DUP4 LT PUSH2 0xB5B JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x14 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x496E646578206F7574206F6620626F756E64732E000000000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE PUSH1 0x64 ADD PUSH2 0x334 JUMP JUMPDEST POP POP PUSH1 0x0 SWAP1 DUP2 MSTORE PUSH1 0x1 SWAP2 SWAP1 SWAP2 ADD PUSH1 0x20 MSTORE PUSH1 0x40 SWAP1 KECCAK256 SLOAD SWAP1 JUMP JUMPDEST PUSH1 0x0 PUSH2 0xBB5 DUP4 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST SWAP1 POP PUSH2 0xA42 DUP3 DUP3 PUSH1 0x20 ADD MLOAD DUP6 PUSH2 0x957 SWAP1 SWAP3 SWAP2 SWAP1 PUSH4 0xFFFFFFFF AND JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH2 0xC13 DUP4 PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD MSTORE POP SLOAD PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH5 0xFFFFFFFFFF DUP3 AND DUP2 MSTORE PUSH5 0xFFFFFFFFFF NOT SWAP1 SWAP2 AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST PUSH1 0x20 ADD MLOAD SWAP4 SWAP3 POP POP POP JUMP JUMPDEST DUP1 MLOAD PUSH1 0x20 DUP3 ADD MLOAD DUP4 SLOAD DUP2 DUP4 OR SWAP3 SWAP2 SWAP1 DUP4 EQ PUSH2 0xC37 JUMPI DUP3 DUP6 SSTORE JUMPDEST POP POP POP POP POP JUMP JUMPDEST DUP1 CALLDATALOAD PUSH5 0xFFFFFFFFFF NOT DUP2 AND DUP2 EQ PUSH2 0xC54 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x40 DUP4 DUP6 SUB SLT ISZERO PUSH2 0xC6C JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP3 CALLDATALOAD SWAP2 POP PUSH2 0xC7C PUSH1 0x20 DUP5 ADD PUSH2 0xC3E JUMP JUMPDEST SWAP1 POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0xC97 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xCA0 DUP3 PUSH2 0xC3E JUMP JUMPDEST SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH32 0x4E487B7100000000000000000000000000000000000000000000000000000000 PUSH1 0x0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0xCE8 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP1 DUP3 GT ISZERO PUSH2 0xD00 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 DUP5 ADD SWAP2 POP DUP5 PUSH1 0x1F DUP4 ADD SLT PUSH2 0xD14 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD DUP2 DUP2 GT ISZERO PUSH2 0xD26 JUMPI PUSH2 0xD26 PUSH2 0xCA7 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1F DUP3 ADD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0 SWAP1 DUP2 AND PUSH1 0x3F ADD AND DUP2 ADD SWAP1 DUP4 DUP3 GT DUP2 DUP4 LT OR ISZERO PUSH2 0xD6C JUMPI PUSH2 0xD6C PUSH2 0xCA7 JUMP JUMPDEST DUP2 PUSH1 0x40 MSTORE DUP3 DUP2 MSTORE DUP8 PUSH1 0x20 DUP5 DUP8 ADD ADD GT ISZERO PUSH2 0xD85 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP3 PUSH1 0x20 DUP7 ADD PUSH1 0x20 DUP4 ADD CALLDATACOPY PUSH1 0x0 SWAP3 DUP2 ADD PUSH1 0x20 ADD SWAP3 SWAP1 SWAP3 MSTORE POP SWAP6 SWAP5 POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0xDB7 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP CALLDATALOAD SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP1 DUP4 MSTORE DUP4 MLOAD DUP1 DUP3 DUP6 ADD MSTORE PUSH1 0x0 JUMPDEST DUP2 DUP2 LT ISZERO PUSH2 0xDEB JUMPI DUP6 DUP2 ADD DUP4 ADD MLOAD DUP6 DUP3 ADD PUSH1 0x40 ADD MSTORE DUP3 ADD PUSH2 0xDCF JUMP JUMPDEST DUP2 DUP2 GT ISZERO PUSH2 0xDFD JUMPI PUSH1 0x0 PUSH1 0x40 DUP4 DUP8 ADD ADD MSTORE JUMPDEST POP PUSH1 0x1F ADD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0 AND SWAP3 SWAP1 SWAP3 ADD PUSH1 0x40 ADD SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x1 DUP2 DUP2 SHR SWAP1 DUP3 AND DUP1 PUSH2 0xE45 JUMPI PUSH1 0x7F DUP3 AND SWAP2 POP JUMPDEST PUSH1 0x20 DUP3 LT DUP2 EQ ISZERO PUSH2 0xE7F JUMPI PUSH32 0x4E487B7100000000000000000000000000000000000000000000000000000000 PUSH1 0x0 MSTORE PUSH1 0x22 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0xE97 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP2 AND DUP2 EQ PUSH2 0xCA0 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH5 0xFFFFFFFFFF DUP1 DUP4 AND DUP2 DUP2 EQ ISZERO PUSH2 0xEFD JUMPI PUSH32 0x4E487B7100000000000000000000000000000000000000000000000000000000 PUSH1 0x0 MSTORE PUSH1 0x11 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x1 ADD SWAP4 SWAP3 POP POP POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xE1 SWAP10 0x5E 0xE5 PUSH13 0x4C5E67DE41C56AD510B1670472 PUSH30 0x3AB1FA5BB2E3C62B0BD7C0597564736F6C63430008090033000000000000 ",
          "sourceMap": "989:2971:22:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3757:201;;;;;;:::i;:::-;;:::i;:::-;;2623:99;;;:::i;:::-;;;644:25:78;;;632:2;617:18;2623:99:22;;;;;;;;3037:127;;;;;;:::i;:::-;;:::i;2160:129::-;;;;;;:::i;:::-;;:::i;284:43:52:-;;;;;;;;;;;;1333:42:78;1321:55;;;1303:74;;1291:2;1276:18;284:43:52;1130:253:78;865:127:52;;;;;;:::i;:::-;;:::i;3503:139:22:-;;;;;;:::i;:::-;;:::i;1236:19::-;;;:::i;:::-;;;;;;;:::i;3279:109::-;;;;;;:::i;:::-;;:::i;2837:85::-;;;;;;:::i;:::-;;:::i;2404:104::-;;;:::i;:::-;;;-1:-1:-1;;4171:79:78;;;4153:98;;4141:2;4126:18;2404:104:22;4007:250:78;3757:201:22;1843:14;1851:5;1843:14;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:7;:14::i;:::-;1829:28;;:10;:28;;;1808:139;;;;;;;;4906:2:78;1808:139:22;;;4888:21:78;4925:18;;;4918:30;;;;4984:34;4964:18;;;4957:62;5055:34;5035:18;;;5028:62;5107:19;;1808:139:22;;;;;;;;;3883:68:::1;:6;3926::::0;3935:15;3883:35:::1;:68::i;:::-;3757:201:::0;;:::o;2623:99::-;2662:7;2696:18;:6;:16;:18::i;:::-;2688:27;;2681:34;;2623:99;:::o;3037:127::-;1843:14;1851:5;1843:14;;;;;:::i;:::-;1829:28;;:10;:28;;;1808:139;;;;;;;;4906:2:78;1808:139:22;;;4888:21:78;4925:18;;;4918:30;;;;4984:34;4964:18;;;4957:62;5055:34;5035:18;;;5028:62;5107:19;;1808:139:22;4704:428:78;1808:139:22;3120:37:::1;:6;3132:7:::0;3141:15;3120:11:::1;:37::i;2160:129::-:0;1843:14;1851:5;1843:14;;;;;:::i;:::-;1829:28;;:10;:28;;;1808:139;;;;;;;;4906:2:78;1808:139:22;;;4888:21:78;4925:18;;;4918:30;;;;4984:34;4964:18;;;4957:62;5055:34;5035:18;;;5028:62;5107:19;;1808:139:22;4704:428:78;1808:139:22;2246:36:::1;:6;2266:15:::0;2246:19:::1;:36::i;:::-;2160:129:::0;:::o;865:127:52:-;924:7;950:17;;:35;;;;;:17;;;;;:28;;:35;;979:5;;950:35;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;943:42;865:127;-1:-1:-1;;865:127:52:o;3503:139:22:-;1843:14;1851:5;1843:14;;;;;:::i;:::-;1829:28;;:10;:28;;;1808:139;;;;;;;;4906:2:78;1808:139:22;;;4888:21:78;4925:18;;;4918:30;;;;4984:34;4964:18;;;4957:62;5055:34;5035:18;;;5028:62;5107:19;;1808:139:22;4704:428:78;1808:139:22;3584:51:::1;:6;3627::::0;3584:35:::1;:51::i;1236:19::-:0;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;3279:109::-;3329:7;3355:26;:6;:26;;;:10;:26::i;2837:85::-;1843:14;1851:5;1843:14;;;;;:::i;:::-;1829:28;;:10;:28;;;1808:139;;;;;;;;4906:2:78;1808:139:22;;;4888:21:78;4925:18;;;4918:30;;;;4984:34;4964:18;;;4957:62;5055:34;5035:18;;;5028:62;5107:19;;1808:139:22;4704:428:78;1808:139:22;2895:20:::1;:6;2907:7:::0;2895:11:::1;:20::i;2404:104::-:0;2454:7;2480:21;:6;:19;:21::i;:::-;2473:28;;2404:104;:::o;2732:416:58:-;2876:24;2903:18;:5;-1:-1:-1;;;;;;;;;;;;;;;;;;5313:13:58;5724:55;;;;;;;;;5465:66;5419:126;;5724:55;;-1:-1:-1;;5571:126:58;;;5724:55;;;;;5198:588;2903:18;2876:45;;2949:3;:10;;;2940:19;;:6;:19;;;2932:52;;;;;;;5657:2:78;2932:52:58;;;5639:21:78;5696:2;5676:18;;;5669:30;5735:22;5715:18;;;5708:50;5775:18;;2932:52:58;5455:344:78;2932:52:58;3055:19;;;;;-1:-1:-1;;3084:26:58;;:13;;;:26;3120:21;:5;3055:3;3120:16;:21::i;:::-;2866:282;2732:416;;;:::o;3696:161::-;3760:6;3778:24;3805:18;:5;-1:-1:-1;;;;;;;;;;;;;;;;;;5313:13:58;5724:55;;;;;;;;;5465:66;5419:126;;5724:55;;-1:-1:-1;;5571:126:58;;;5724:55;;;;;5198:588;3805:18;3840:10;;3696:161;-1:-1:-1;;;3696:161:58:o;1322:387::-;1443:24;1470:18;:5;-1:-1:-1;;;;;;;;;;;;;;;;;;5313:13:58;5724:55;;;;;;;;;5465:66;5419:126;;5724:55;;-1:-1:-1;;5571:126:58;;;5724:55;;;;;5198:588;1470:18;1509:10;;1499:21;;;;;;:9;;;:21;;;;;:30;;;1623:12;;1443:45;;-1:-1:-1;1443:45:58;1623:12;;;:::i;:::-;;;;;-1:-1:-1;;;1645:26:58;;:13;;;:26;1681:21;:5;1645:3;1681:16;:21::i;4007:202::-;4090:24;4117:18;:5;-1:-1:-1;;;;;;;;;;;;;;;;;;5313:13:58;5724:55;;;;;;;;;5465:66;5419:126;;5724:55;;-1:-1:-1;;5571:126:58;;;5724:55;;;;;5198:588;4117:18;-1:-1:-1;;4145:26:58;;:13;;;:26;4090:45;-1:-1:-1;4181:21:58;:5;4090:45;4181:16;:21::i;:::-;4080:129;4007:202;;:::o;3343:213::-;3437:24;3464:18;:5;-1:-1:-1;;;;;;;;;;;;;;;;;;5313:13:58;5724:55;;;;;;;;;5465:66;5419:126;;5724:55;;-1:-1:-1;;5571:126:58;;;5724:55;;;;;5198:588;3464:18;3437:45;;3492:57;3527:6;3535:3;:13;;;3492:5;:34;;:57;;;;;:::i;2241:243::-;2315:7;2334:24;2361:18;:5;-1:-1:-1;;;;;;;;;;;;;;;;;;5313:13:58;5724:55;;;;;;;;;5465:66;5419:126;;5724:55;;-1:-1:-1;;5571:126:58;;;5724:55;;;;;5198:588;2361:18;2407:10;;2334:45;;-1:-1:-1;2398:19:58;;;;2390:52;;;;;;;5657:2:78;2390:52:58;;;5639:21:78;5696:2;5676:18;;;5669:30;5735:22;5715:18;;;5708:50;5775:18;;2390:52:58;5455:344:78;2390:52:58;-1:-1:-1;;2460:17:58;;;;:9;;;;;:17;;;;;;;2241:243::o;1865:167::-;1936:24;1963:18;:5;-1:-1:-1;;;;;;;;;;;;;;;;;;5313:13:58;5724:55;;;;;;;;;5465:66;5419:126;;5724:55;;-1:-1:-1;;5571:126:58;;;5724:55;;;;;5198:588;1963:18;1936:45;;1992:33;2003:6;2011:3;:13;;;1992:5;:10;;:33;;;;;:::i;4359:168::-;4426:7;4445:24;4472:18;:5;-1:-1:-1;;;;;;;;;;;;;;;;;;5313:13:58;5724:55;;;;;;;;;5465:66;5419:126;;5724:55;;-1:-1:-1;;5571:126:58;;;5724:55;;;;;5198:588;4472:18;4507:13;;;;4359:168;-1:-1:-1;;;4359:168:58:o;4670:384::-;4799:11;;4840:14;;;;4974:13;;4928:22;;;;4799:11;4840:14;4974:24;;4970:78;;5014:23;;;4970:78;4748:306;;;4670:384;;:::o;14:220:78:-;82:20;;-1:-1:-1;;131:78:78;;121:89;;111:117;;224:1;221;214:12;111:117;14:220;;;:::o;239:254::-;307:6;315;368:2;356:9;347:7;343:23;339:32;336:52;;;384:1;381;374:12;336:52;420:9;407:23;397:33;;449:38;483:2;472:9;468:18;449:38;:::i;:::-;439:48;;239:254;;;;;:::o;939:186::-;998:6;1051:2;1039:9;1030:7;1026:23;1022:32;1019:52;;;1067:1;1064;1057:12;1019:52;1090:29;1109:9;1090:29;:::i;:::-;1080:39;939:186;-1:-1:-1;;;939:186:78:o;1388:184::-;1440:77;1437:1;1430:88;1537:4;1534:1;1527:15;1561:4;1558:1;1551:15;1577:981;1646:6;1699:2;1687:9;1678:7;1674:23;1670:32;1667:52;;;1715:1;1712;1705:12;1667:52;1755:9;1742:23;1784:18;1825:2;1817:6;1814:14;1811:34;;;1841:1;1838;1831:12;1811:34;1879:6;1868:9;1864:22;1854:32;;1924:7;1917:4;1913:2;1909:13;1905:27;1895:55;;1946:1;1943;1936:12;1895:55;1982:2;1969:16;2004:2;2000;1997:10;1994:36;;;2010:18;;:::i;:::-;2144:2;2138:9;2206:4;2198:13;;2049:66;2194:22;;;2218:2;2190:31;2186:40;2174:53;;;2242:18;;;2262:22;;;2239:46;2236:72;;;2288:18;;:::i;:::-;2328:10;2324:2;2317:22;2363:2;2355:6;2348:18;2403:7;2398:2;2393;2389;2385:11;2381:20;2378:33;2375:53;;;2424:1;2421;2414:12;2375:53;2480:2;2475;2471;2467:11;2462:2;2454:6;2450:15;2437:46;2525:1;2503:15;;;2520:2;2499:24;2492:35;;;;-1:-1:-1;2507:6:78;1577:981;-1:-1:-1;;;;;1577:981:78:o;2794:180::-;2853:6;2906:2;2894:9;2885:7;2881:23;2877:32;2874:52;;;2922:1;2919;2912:12;2874:52;-1:-1:-1;2945:23:78;;2794:180;-1:-1:-1;2794:180:78:o;2979:656::-;3091:4;3120:2;3149;3138:9;3131:21;3181:6;3175:13;3224:6;3219:2;3208:9;3204:18;3197:34;3249:1;3259:140;3273:6;3270:1;3267:13;3259:140;;;3368:14;;;3364:23;;3358:30;3334:17;;;3353:2;3330:26;3323:66;3288:10;;3259:140;;;3417:6;3414:1;3411:13;3408:91;;;3487:1;3482:2;3473:6;3462:9;3458:22;3454:31;3447:42;3408:91;-1:-1:-1;3551:2:78;3539:15;3556:66;3535:88;3520:104;;;;3626:2;3516:113;;2979:656;-1:-1:-1;;;2979:656:78:o;4262:437::-;4341:1;4337:12;;;;4384;;;4405:61;;4459:4;4451:6;4447:17;4437:27;;4405:61;4512:2;4504:6;4501:14;4481:18;4478:38;4475:218;;;4549:77;4546:1;4539:88;4650:4;4647:1;4640:15;4678:4;4675:1;4668:15;4475:218;;4262:437;;;:::o;5137:313::-;5207:6;5260:2;5248:9;5239:7;5235:23;5231:32;5228:52;;;5276:1;5273;5266:12;5228:52;5308:9;5302:16;5358:42;5351:5;5347:54;5340:5;5337:65;5327:93;;5416:1;5413;5406:12;5804:357;5842:3;5870:12;5917:2;5910:5;5906:14;5944:2;5935:7;5932:15;5929:195;;;5980:77;5977:1;5970:88;6081:4;6078:1;6071:15;6109:4;6106:1;6099:15;5929:195;6153:1;6140:15;;5804:357;-1:-1:-1;;;5804:357:78:o"
        },
        "gasEstimates": {
          "creation": {
            "codeDepositCost": "780200",
            "executionCost": "infinite",
            "totalCost": "infinite"
          },
          "external": {
            "deleteElementsAfterInclusive(uint256)": "infinite",
            "deleteElementsAfterInclusive(uint256,bytes27)": "infinite",
            "get(uint256)": "4824",
            "getGlobalMetadata()": "2596",
            "length()": "2553",
            "libAddressManager()": "2380",
            "owner()": "infinite",
            "push(bytes32)": "infinite",
            "push(bytes32,bytes27)": "infinite",
            "resolve(string)": "infinite",
            "setGlobalMetadata(bytes27)": "infinite"
          }
        },
        "methodIdentifiers": {
          "deleteElementsAfterInclusive(uint256)": "4651d91e",
          "deleteElementsAfterInclusive(uint256,bytes27)": "167fd681",
          "get(uint256)": "9507d39a",
          "getGlobalMetadata()": "ccf8f969",
          "length()": "1f7b6d32",
          "libAddressManager()": "299ca478",
          "owner()": "8da5cb5b",
          "push(bytes32)": "b298e36b",
          "push(bytes32,bytes27)": "2015276c",
          "resolve(string)": "461a4478",
          "setGlobalMetadata(bytes27)": "29061de2"
        }
      },
      "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_libAddressManager\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_owner\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"bytes27\",\"name\":\"_globalMetadata\",\"type\":\"bytes27\"}],\"name\":\"deleteElementsAfterInclusive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"deleteElementsAfterInclusive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"get\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalMetadata\",\"outputs\":[{\"internalType\":\"bytes27\",\"name\":\"\",\"type\":\"bytes27\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"libAddressManager\",\"outputs\":[{\"internalType\":\"contract Lib_AddressManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_object\",\"type\":\"bytes32\"},{\"internalType\":\"bytes27\",\"name\":\"_globalMetadata\",\"type\":\"bytes27\"}],\"name\":\"push\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_object\",\"type\":\"bytes32\"}],\"name\":\"push\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes27\",\"name\":\"_globalMetadata\",\"type\":\"bytes27\"}],\"name\":\"setGlobalMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"The Chain Storage Container provides its owner contract with read, write and delete functionality. This provides gas efficiency gains by enabling it to overwrite storage slots which can no longer be used in a fraud proof due to the fraud window having passed, and the associated chain state or transactions being finalized. Three distinct Chain Storage Containers will be deployed on Layer 1: 1. Stores transaction batches for the Canonical Transaction Chain 2. Stores queued transactions for the Canonical Transaction Chain 3. Stores chain state batches for the State Commitment Chain\",\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_libAddressManager\":\"Address of the Address Manager.\",\"_owner\":\"Name of the contract that owns this container (will be resolved later).\"}},\"deleteElementsAfterInclusive(uint256)\":{\"params\":{\"_index\":\"Object index to delete from.\"}},\"deleteElementsAfterInclusive(uint256,bytes27)\":{\"params\":{\"_globalMetadata\":\"New global metadata for the container.\",\"_index\":\"Object index to delete from.\"}},\"get(uint256)\":{\"params\":{\"_index\":\"Index of the particular object to access.\"},\"returns\":{\"_0\":\"32 byte object value.\"}},\"getGlobalMetadata()\":{\"returns\":{\"_0\":\"Container global metadata field.\"}},\"length()\":{\"returns\":{\"_0\":\"Number of objects in the container.\"}},\"push(bytes32)\":{\"params\":{\"_object\":\"A 32 byte value to insert into the container.\"}},\"push(bytes32,bytes27)\":{\"params\":{\"_globalMetadata\":\"New global metadata for the container.\",\"_object\":\"A 32 byte value to insert into the container.\"}},\"resolve(string)\":{\"params\":{\"_name\":\"Name to resolve an address for.\"},\"returns\":{\"_0\":\"Address associated with the given name.\"}},\"setGlobalMetadata(bytes27)\":{\"params\":{\"_globalMetadata\":\"New global metadata to set.\"}}},\"title\":\"ChainStorageContainer\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"deleteElementsAfterInclusive(uint256)\":{\"notice\":\"Removes all objects after and including a given index.\"},\"deleteElementsAfterInclusive(uint256,bytes27)\":{\"notice\":\"Removes all objects after and including a given index. Also allows setting the global metadata field.\"},\"get(uint256)\":{\"notice\":\"Retrieves an object from the container.\"},\"getGlobalMetadata()\":{\"notice\":\"Retrieves the container's global metadata field.\"},\"length()\":{\"notice\":\"Retrieves the number of objects stored in the container.\"},\"push(bytes32)\":{\"notice\":\"Pushes an object into the container.\"},\"push(bytes32,bytes27)\":{\"notice\":\"Pushes an object into the container. Function allows setting the global metadata since we'll need to touch the \\\"length\\\" storage slot anyway, which also contains the global metadata (it's an optimization).\"},\"resolve(string)\":{\"notice\":\"Resolves the address associated with a given name.\"},\"setGlobalMetadata(bytes27)\":{\"notice\":\"Sets the container's global metadata field. We're using `bytes27` here because we use five bytes to maintain the length of the underlying data structure, meaning we have an extra 27 bytes to store arbitrary data.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/L1/rollup/ChainStorageContainer.sol\":\"ChainStorageContainer\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x6bb804a310218875e89d12c053e94a13a4607cdf7cc2052f3e52bd32a0dc50a1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x90565a39ae45c80f0468dc96c7b20d0afc3055f344c8203a0c9258239f350b9f\",\"license\":\"MIT\"},\"contracts/L1/rollup/ChainStorageContainer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_Buffer } from \\\"../../libraries/utils/Lib_Buffer.sol\\\";\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\n\\n/* Interface Imports */\\nimport { IChainStorageContainer } from \\\"./IChainStorageContainer.sol\\\";\\n\\n/**\\n * @title ChainStorageContainer\\n * @dev The Chain Storage Container provides its owner contract with read, write and delete\\n * functionality. This provides gas efficiency gains by enabling it to overwrite storage slots which\\n * can no longer be used in a fraud proof due to the fraud window having passed, and the associated\\n * chain state or transactions being finalized.\\n * Three distinct Chain Storage Containers will be deployed on Layer 1:\\n * 1. Stores transaction batches for the Canonical Transaction Chain\\n * 2. Stores queued transactions for the Canonical Transaction Chain\\n * 3. Stores chain state batches for the State Commitment Chain\\n *\\n */\\ncontract ChainStorageContainer is IChainStorageContainer, Lib_AddressResolver {\\n    /*************\\n     * Libraries *\\n     *************/\\n\\n    using Lib_Buffer for Lib_Buffer.Buffer;\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    string public owner;\\n    Lib_Buffer.Buffer internal buffer;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Address Manager.\\n     * @param _owner Name of the contract that owns this container (will be resolved later).\\n     */\\n    constructor(address _libAddressManager, string memory _owner)\\n        Lib_AddressResolver(_libAddressManager)\\n    {\\n        owner = _owner;\\n    }\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == resolve(owner),\\n            \\\"ChainStorageContainer: Function can only be called by the owner.\\\"\\n        );\\n        _;\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function setGlobalMetadata(bytes27 _globalMetadata) public onlyOwner {\\n        return buffer.setExtraData(_globalMetadata);\\n    }\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function getGlobalMetadata() public view returns (bytes27) {\\n        return buffer.getExtraData();\\n    }\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function length() public view returns (uint256) {\\n        return uint256(buffer.getLength());\\n    }\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function push(bytes32 _object) public onlyOwner {\\n        buffer.push(_object);\\n    }\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function push(bytes32 _object, bytes27 _globalMetadata) public onlyOwner {\\n        buffer.push(_object, _globalMetadata);\\n    }\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function get(uint256 _index) public view returns (bytes32) {\\n        return buffer.get(uint40(_index));\\n    }\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function deleteElementsAfterInclusive(uint256 _index) public onlyOwner {\\n        buffer.deleteElementsAfterInclusive(uint40(_index));\\n    }\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata)\\n        public\\n        onlyOwner\\n    {\\n        buffer.deleteElementsAfterInclusive(uint40(_index), _globalMetadata);\\n    }\\n}\\n\",\"keccak256\":\"0x5acd889488ab8eab50d5527d1b18b00214a3242acbf9d89fbeaf188322f81a58\",\"license\":\"MIT\"},\"contracts/L1/rollup/IChainStorageContainer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title IChainStorageContainer\\n */\\ninterface IChainStorageContainer {\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\\n     * 27 bytes to store arbitrary data.\\n     * @param _globalMetadata New global metadata to set.\\n     */\\n    function setGlobalMetadata(bytes27 _globalMetadata) external;\\n\\n    /**\\n     * Retrieves the container's global metadata field.\\n     * @return Container global metadata field.\\n     */\\n    function getGlobalMetadata() external view returns (bytes27);\\n\\n    /**\\n     * Retrieves the number of objects stored in the container.\\n     * @return Number of objects in the container.\\n     */\\n    function length() external view returns (uint256);\\n\\n    /**\\n     * Pushes an object into the container.\\n     * @param _object A 32 byte value to insert into the container.\\n     */\\n    function push(bytes32 _object) external;\\n\\n    /**\\n     * Pushes an object into the container. Function allows setting the global metadata since\\n     * we'll need to touch the \\\"length\\\" storage slot anyway, which also contains the global\\n     * metadata (it's an optimization).\\n     * @param _object A 32 byte value to insert into the container.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function push(bytes32 _object, bytes27 _globalMetadata) external;\\n\\n    /**\\n     * Retrieves an object from the container.\\n     * @param _index Index of the particular object to access.\\n     * @return 32 byte object value.\\n     */\\n    function get(uint256 _index) external view returns (bytes32);\\n\\n    /**\\n     * Removes all objects after and including a given index.\\n     * @param _index Object index to delete from.\\n     */\\n    function deleteElementsAfterInclusive(uint256 _index) external;\\n\\n    /**\\n     * Removes all objects after and including a given index. Also allows setting the global\\n     * metadata field.\\n     * @param _index Object index to delete from.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata) external;\\n}\\n\",\"keccak256\":\"0xe55ad72572ec47dc09a02228d0c5a438571c76a41d16d92b35add057811977ce\",\"license\":\"MIT\"},\"contracts/libraries/resolver/Lib_AddressManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* External Imports */\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(string indexed _name, address _newAddress, address _oldAddress);\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    mapping(bytes32 => address) private addresses;\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Changes the address associated with a particular name.\\n     * @param _name String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(_name, _address, oldAddress);\\n    }\\n\\n    /**\\n     * Retrieves the address associated with a given name.\\n     * @param _name Name to retrieve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(string memory _name) external view returns (address) {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Computes the hash of a name.\\n     * @param _name Name to compute a hash for.\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\",\"keccak256\":\"0xcde9b29429d512c549f7c1b8a033f161fa71c18cda08b241748663854196ae14\",\"license\":\"MIT\"},\"contracts/libraries/resolver/Lib_AddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_AddressManager } from \\\"./Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title Lib_AddressResolver\\n */\\nabstract contract Lib_AddressResolver {\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    Lib_AddressManager public libAddressManager;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Lib_AddressManager.\\n     */\\n    constructor(address _libAddressManager) {\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Resolves the address associated with a given name.\\n     * @param _name Name to resolve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function resolve(string memory _name) public view returns (address) {\\n        return libAddressManager.getAddress(_name);\\n    }\\n}\\n\",\"keccak256\":\"0x515c4db671a28e2fe180201f6d11c0208c05f582ca3489fb6b8e81c27659bc62\",\"license\":\"MIT\"},\"contracts/libraries/utils/Lib_Buffer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_Buffer\\n * @dev This library implements a bytes32 storage array with some additional gas-optimized\\n * functionality. In particular, it encodes its length as a uint40, and tightly packs this with an\\n * overwritable \\\"extra data\\\" field so we can store more information with a single SSTORE.\\n */\\nlibrary Lib_Buffer {\\n    /*************\\n     * Libraries *\\n     *************/\\n\\n    using Lib_Buffer for Buffer;\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct Buffer {\\n        bytes32 context;\\n        mapping(uint256 => bytes32) buf;\\n    }\\n\\n    struct BufferContext {\\n        // Stores the length of the array. Uint40 is way more elements than we'll ever reasonably\\n        // need in an array and we get an extra 27 bytes of extra data to play with.\\n        uint40 length;\\n        // Arbitrary extra data that can be modified whenever the length is updated. Useful for\\n        // squeezing out some gas optimizations.\\n        bytes27 extraData;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Pushes a single element to the buffer.\\n     * @param _self Buffer to access.\\n     * @param _value Value to push to the buffer.\\n     * @param _extraData Global extra data.\\n     */\\n    function push(\\n        Buffer storage _self,\\n        bytes32 _value,\\n        bytes27 _extraData\\n    ) internal {\\n        BufferContext memory ctx = _self.getContext();\\n\\n        _self.buf[ctx.length] = _value;\\n\\n        // Bump the global index and insert our extra data, then save the context.\\n        ctx.length++;\\n        ctx.extraData = _extraData;\\n        _self.setContext(ctx);\\n    }\\n\\n    /**\\n     * Pushes a single element to the buffer.\\n     * @param _self Buffer to access.\\n     * @param _value Value to push to the buffer.\\n     */\\n    function push(Buffer storage _self, bytes32 _value) internal {\\n        BufferContext memory ctx = _self.getContext();\\n\\n        _self.push(_value, ctx.extraData);\\n    }\\n\\n    /**\\n     * Retrieves an element from the buffer.\\n     * @param _self Buffer to access.\\n     * @param _index Element index to retrieve.\\n     * @return Value of the element at the given index.\\n     */\\n    function get(Buffer storage _self, uint256 _index) internal view returns (bytes32) {\\n        BufferContext memory ctx = _self.getContext();\\n\\n        require(_index < ctx.length, \\\"Index out of bounds.\\\");\\n\\n        return _self.buf[_index];\\n    }\\n\\n    /**\\n     * Deletes all elements after (and including) a given index.\\n     * @param _self Buffer to access.\\n     * @param _index Index of the element to delete from (inclusive).\\n     * @param _extraData Optional global extra data.\\n     */\\n    function deleteElementsAfterInclusive(\\n        Buffer storage _self,\\n        uint40 _index,\\n        bytes27 _extraData\\n    ) internal {\\n        BufferContext memory ctx = _self.getContext();\\n\\n        require(_index < ctx.length, \\\"Index out of bounds.\\\");\\n\\n        // Set our length and extra data, save the context.\\n        ctx.length = _index;\\n        ctx.extraData = _extraData;\\n        _self.setContext(ctx);\\n    }\\n\\n    /**\\n     * Deletes all elements after (and including) a given index.\\n     * @param _self Buffer to access.\\n     * @param _index Index of the element to delete from (inclusive).\\n     */\\n    function deleteElementsAfterInclusive(Buffer storage _self, uint40 _index) internal {\\n        BufferContext memory ctx = _self.getContext();\\n        _self.deleteElementsAfterInclusive(_index, ctx.extraData);\\n    }\\n\\n    /**\\n     * Retrieves the current global index.\\n     * @param _self Buffer to access.\\n     * @return Current global index.\\n     */\\n    function getLength(Buffer storage _self) internal view returns (uint40) {\\n        BufferContext memory ctx = _self.getContext();\\n        return ctx.length;\\n    }\\n\\n    /**\\n     * Changes current global extra data.\\n     * @param _self Buffer to access.\\n     * @param _extraData New global extra data.\\n     */\\n    function setExtraData(Buffer storage _self, bytes27 _extraData) internal {\\n        BufferContext memory ctx = _self.getContext();\\n        ctx.extraData = _extraData;\\n        _self.setContext(ctx);\\n    }\\n\\n    /**\\n     * Retrieves the current global extra data.\\n     * @param _self Buffer to access.\\n     * @return Current global extra data.\\n     */\\n    function getExtraData(Buffer storage _self) internal view returns (bytes27) {\\n        BufferContext memory ctx = _self.getContext();\\n        return ctx.extraData;\\n    }\\n\\n    /**\\n     * Sets the current buffer context.\\n     * @param _self Buffer to access.\\n     * @param _ctx Current buffer context.\\n     */\\n    function setContext(Buffer storage _self, BufferContext memory _ctx) internal {\\n        bytes32 context;\\n        uint40 length = _ctx.length;\\n        bytes27 extraData = _ctx.extraData;\\n        assembly {\\n            context := length\\n            context := or(context, extraData)\\n        }\\n\\n        if (_self.context != context) {\\n            _self.context = context;\\n        }\\n    }\\n\\n    /**\\n     * Retrieves the current buffer context.\\n     * @param _self Buffer to access.\\n     * @return Current buffer context.\\n     */\\n    function getContext(Buffer storage _self) internal view returns (BufferContext memory) {\\n        bytes32 context = _self.context;\\n        uint40 length;\\n        bytes27 extraData;\\n        assembly {\\n            length := and(\\n                context,\\n                0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF\\n            )\\n            extraData := and(\\n                context,\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000\\n            )\\n        }\\n\\n        return BufferContext({ length: length, extraData: extraData });\\n    }\\n}\\n\",\"keccak256\":\"0x38917b618db448e356c76c999ce9aaca094541eb1f9bc65b06b8d4d84308f056\",\"license\":\"MIT\"}},\"version\":1}",
      "storageLayout": {
        "storage": [
          {
            "astId": 7659,
            "contract": "contracts/L1/rollup/ChainStorageContainer.sol:ChainStorageContainer",
            "label": "libAddressManager",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(Lib_AddressManager)7651"
          },
          {
            "astId": 4202,
            "contract": "contracts/L1/rollup/ChainStorageContainer.sol:ChainStorageContainer",
            "label": "owner",
            "offset": 0,
            "slot": "1",
            "type": "t_string_storage"
          },
          {
            "astId": 4205,
            "contract": "contracts/L1/rollup/ChainStorageContainer.sol:ChainStorageContainer",
            "label": "buffer",
            "offset": 0,
            "slot": "2",
            "type": "t_struct(Buffer)9775_storage"
          }
        ],
        "types": {
          "t_bytes32": {
            "encoding": "inplace",
            "label": "bytes32",
            "numberOfBytes": "32"
          },
          "t_contract(Lib_AddressManager)7651": {
            "encoding": "inplace",
            "label": "contract Lib_AddressManager",
            "numberOfBytes": "20"
          },
          "t_mapping(t_uint256,t_bytes32)": {
            "encoding": "mapping",
            "key": "t_uint256",
            "label": "mapping(uint256 => bytes32)",
            "numberOfBytes": "32",
            "value": "t_bytes32"
          },
          "t_string_storage": {
            "encoding": "bytes",
            "label": "string",
            "numberOfBytes": "32"
          },
          "t_struct(Buffer)9775_storage": {
            "encoding": "inplace",
            "label": "struct Lib_Buffer.Buffer",
            "members": [
              {
                "astId": 9770,
                "contract": "contracts/L1/rollup/ChainStorageContainer.sol:ChainStorageContainer",
                "label": "context",
                "offset": 0,
                "slot": "0",
                "type": "t_bytes32"
              },
              {
                "astId": 9774,
                "contract": "contracts/L1/rollup/ChainStorageContainer.sol:ChainStorageContainer",
                "label": "buf",
                "offset": 0,
                "slot": "1",
                "type": "t_mapping(t_uint256,t_bytes32)"
              }
            ],
            "numberOfBytes": "64"
          },
          "t_uint256": {
            "encoding": "inplace",
            "label": "uint256",
            "numberOfBytes": "32"
          }
        }
      },
      "userdoc": {
        "kind": "user",
        "methods": {
          "deleteElementsAfterInclusive(uint256)": {
            "notice": "Removes all objects after and including a given index."
          },
          "deleteElementsAfterInclusive(uint256,bytes27)": {
            "notice": "Removes all objects after and including a given index. Also allows setting the global metadata field."
          },
          "get(uint256)": {
            "notice": "Retrieves an object from the container."
          },
          "getGlobalMetadata()": {
            "notice": "Retrieves the container's global metadata field."
          },
          "length()": {
            "notice": "Retrieves the number of objects stored in the container."
          },
          "push(bytes32)": {
            "notice": "Pushes an object into the container."
          },
          "push(bytes32,bytes27)": {
            "notice": "Pushes an object into the container. Function allows setting the global metadata since we'll need to touch the \"length\" storage slot anyway, which also contains the global metadata (it's an optimization)."
          },
          "resolve(string)": {
            "notice": "Resolves the address associated with a given name."
          },
          "setGlobalMetadata(bytes27)": {
            "notice": "Sets the container's global metadata field. We're using `bytes27` here because we use five bytes to maintain the length of the underlying data structure, meaning we have an extra 27 bytes to store arbitrary data."
          }
        },
        "version": 1
      },
      "solcInput": "{\n  \"language\": \"Solidity\",\n  \"sources\": {\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\n    },\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal initializer {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\n    },\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal initializer {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal initializer {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\n    },\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/Address.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/Context.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\\n        if (result.length < 32) return false;\\n        return success && abi.decode(result, (bool));\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\n    },\n    \"contracts/chugsplash/interfaces/iL1ChugSplashDeployer.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title iL1ChugSplashDeployer\\n */\\ninterface iL1ChugSplashDeployer {\\n    function isUpgrading() external view returns (bool);\\n}\\n\"\n    },\n    \"contracts/chugsplash/L1ChugSplashProxy.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport { iL1ChugSplashDeployer } from \\\"./interfaces/iL1ChugSplashDeployer.sol\\\";\\n\\n/**\\n * @title L1ChugSplashProxy\\n * @dev Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added\\n * functions `setCode` and `setStorage` for changing the code or storage of the contract. Nifty!\\n *\\n * Note for future developers: do NOT make anything in this contract 'public' unless you know what\\n * you're doing. Anything public can potentially have a function signature that conflicts with a\\n * signature attached to the implementation contract. Public functions SHOULD always have the\\n * 'proxyCallIfNotOwner' modifier unless there's some *really* good reason not to have that\\n * modifier. And there almost certainly is not a good reason to not have that modifier. Beware!\\n */\\ncontract L1ChugSplashProxy {\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    // \\\"Magic\\\" prefix. When prepended to some arbitrary bytecode and used to create a contract, the\\n    // appended bytecode will be deployed as given.\\n    bytes13 internal constant DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;\\n\\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n    bytes32 internal constant IMPLEMENTATION_KEY =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    // bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\\n    bytes32 internal constant OWNER_KEY =\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _owner Address of the initial contract owner.\\n     */\\n    constructor(address _owner) {\\n        _setOwner(_owner);\\n    }\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    /**\\n     * Blocks a function from being called when the parent signals that the system should be paused\\n     * via an isUpgrading function.\\n     */\\n    modifier onlyWhenNotPaused() {\\n        address owner = _getOwner();\\n\\n        // We do a low-level call because there's no guarantee that the owner actually *is* an\\n        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and\\n        // it turns out that it isn't the right type of contract.\\n        (bool success, bytes memory returndata) = owner.staticcall(\\n            abi.encodeWithSelector(iL1ChugSplashDeployer.isUpgrading.selector)\\n        );\\n\\n        // If the call was unsuccessful then we assume that there's no \\\"isUpgrading\\\" method and we\\n        // can just continue as normal. We also expect that the return value is exactly 32 bytes\\n        // long. If this isn't the case then we can safely ignore the result.\\n        if (success && returndata.length == 32) {\\n            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the\\n            // case that the isUpgrading function returned something other than 0 or 1. But we only\\n            // really care about the case where this value is 0 (= false).\\n            uint256 ret = abi.decode(returndata, (uint256));\\n            require(ret == 0, \\\"L1ChugSplashProxy: system is currently being upgraded\\\");\\n        }\\n\\n        _;\\n    }\\n\\n    /**\\n     * Makes a proxy call instead of triggering the given function when the caller is either the\\n     * owner or the zero address. Caller can only ever be the zero address if this function is\\n     * being called off-chain via eth_call, which is totally fine and can be convenient for\\n     * client-side tooling. Avoids situations where the proxy and implementation share a sighash\\n     * and the proxy function ends up being called instead of the implementation one.\\n     *\\n     * Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If there's a\\n     * way for someone to send a transaction with msg.sender == address(0) in any real context then\\n     * we have much bigger problems. Primary reason to include this additional allowed sender is\\n     * because the owner address can be changed dynamically and we do not want clients to have to\\n     * keep track of the current owner in order to make an eth_call that doesn't trigger the\\n     * proxied contract.\\n     */\\n    // slither-disable-next-line incorrect-modifier\\n    modifier proxyCallIfNotOwner() {\\n        if (msg.sender == _getOwner() || msg.sender == address(0)) {\\n            _;\\n        } else {\\n            // This WILL halt the call frame on completion.\\n            _doProxyCall();\\n        }\\n    }\\n\\n    /*********************\\n     * Fallback Function *\\n     *********************/\\n\\n    // slither-disable-next-line locked-ether\\n    fallback() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sets the code that should be running behind this proxy. Note that this scheme is a bit\\n     * different from the standard proxy scheme where one would typically deploy the code\\n     * separately and then set the implementation address. We're doing it this way because it gives\\n     * us a lot more freedom on the client side. Can only be triggered by the contract owner.\\n     * @param _code New contract code to run inside this contract.\\n     */\\n    // slither-disable-next-line external-function\\n    function setCode(bytes memory _code) public proxyCallIfNotOwner {\\n        // Get the code hash of the current implementation.\\n        address implementation = _getImplementation();\\n\\n        // If the code hash matches the new implementation then we return early.\\n        if (keccak256(_code) == _getAccountCodeHash(implementation)) {\\n            return;\\n        }\\n\\n        // Create the deploycode by appending the magic prefix.\\n        bytes memory deploycode = abi.encodePacked(DEPLOY_CODE_PREFIX, _code);\\n\\n        // Deploy the code and set the new implementation address.\\n        address newImplementation;\\n        assembly {\\n            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))\\n        }\\n\\n        // Check that the code was actually deployed correctly. I'm not sure if you can ever\\n        // actually fail this check. Should only happen if the contract creation from above runs\\n        // out of gas but this parent execution thread does NOT run out of gas. Seems like we\\n        // should be doing this check anyway though.\\n        require(\\n            _getAccountCodeHash(newImplementation) == keccak256(_code),\\n            \\\"L1ChugSplashProxy: code was not correctly deployed.\\\"\\n        );\\n\\n        _setImplementation(newImplementation);\\n    }\\n\\n    /**\\n     * Modifies some storage slot within the proxy contract. Gives us a lot of power to perform\\n     * upgrades in a more transparent way. Only callable by the owner.\\n     * @param _key Storage key to modify.\\n     * @param _value New value for the storage key.\\n     */\\n    // slither-disable-next-line external-function\\n    function setStorage(bytes32 _key, bytes32 _value) public proxyCallIfNotOwner {\\n        assembly {\\n            sstore(_key, _value)\\n        }\\n    }\\n\\n    /**\\n     * Changes the owner of the proxy contract. Only callable by the owner.\\n     * @param _owner New owner of the proxy contract.\\n     */\\n    // slither-disable-next-line external-function\\n    function setOwner(address _owner) public proxyCallIfNotOwner {\\n        _setOwner(_owner);\\n    }\\n\\n    /**\\n     * Queries the owner of the proxy contract. Can only be called by the owner OR by making an\\n     * eth_call and setting the \\\"from\\\" address to address(0).\\n     * @return Owner address.\\n     */\\n    // slither-disable-next-line external-function\\n    function getOwner() public proxyCallIfNotOwner returns (address) {\\n        return _getOwner();\\n    }\\n\\n    /**\\n     * Queries the implementation address. Can only be called by the owner OR by making an\\n     * eth_call and setting the \\\"from\\\" address to address(0).\\n     * @return Implementation address.\\n     */\\n    // slither-disable-next-line external-function\\n    function getImplementation() public proxyCallIfNotOwner returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Sets the implementation address.\\n     * @param _implementation New implementation address.\\n     */\\n    function _setImplementation(address _implementation) internal {\\n        assembly {\\n            sstore(IMPLEMENTATION_KEY, _implementation)\\n        }\\n    }\\n\\n    /**\\n     * Queries the implementation address.\\n     * @return Implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        address implementation;\\n        assembly {\\n            implementation := sload(IMPLEMENTATION_KEY)\\n        }\\n        return implementation;\\n    }\\n\\n    /**\\n     * Changes the owner of the proxy contract.\\n     * @param _owner New owner of the proxy contract.\\n     */\\n    function _setOwner(address _owner) internal {\\n        assembly {\\n            sstore(OWNER_KEY, _owner)\\n        }\\n    }\\n\\n    /**\\n     * Queries the owner of the proxy contract.\\n     * @return Owner address.\\n     */\\n    function _getOwner() internal view returns (address) {\\n        address owner;\\n        assembly {\\n            owner := sload(OWNER_KEY)\\n        }\\n        return owner;\\n    }\\n\\n    /**\\n     * Gets the code hash for a given account.\\n     * @param _account Address of the account to get a code hash for.\\n     * @return Code hash for the account.\\n     */\\n    function _getAccountCodeHash(address _account) internal view returns (bytes32) {\\n        bytes32 codeHash;\\n        assembly {\\n            codeHash := extcodehash(_account)\\n        }\\n        return codeHash;\\n    }\\n\\n    /**\\n     * Performs the proxy call via a delegatecall.\\n     */\\n    function _doProxyCall() internal onlyWhenNotPaused {\\n        address implementation = _getImplementation();\\n\\n        require(implementation != address(0), \\\"L1ChugSplashProxy: implementation is not set yet\\\");\\n\\n        assembly {\\n            // Copy calldata into memory at 0x0....calldatasize.\\n            calldatacopy(0x0, 0x0, calldatasize())\\n\\n            // Perform the delegatecall, make sure to pass all available gas.\\n            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)\\n\\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\\n            // overwrite the calldata that we just copied into memory but that doesn't really\\n            // matter because we'll be returning in a second anyway.\\n            returndatacopy(0x0, 0x0, returndatasize())\\n\\n            // Success == 0 means a revert. We'll revert too and pass the data up.\\n            if iszero(success) {\\n                revert(0x0, returndatasize())\\n            }\\n\\n            // Otherwise we'll just return and pass the data up.\\n            return(0x0, returndatasize())\\n        }\\n    }\\n}\\n\"\n    },\n    \"contracts/L1/deployment/AddressDictator.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport { Lib_AddressManager } from \\\"../../libraries/resolver/Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title AddressDictator\\n * @dev The AddressDictator (glory to Arstotzka) is a contract that allows us to safely manipulate\\n *      many different addresses in the AddressManager without transferring ownership of the\\n *      AddressManager to a hot wallet or hardware wallet.\\n */\\ncontract AddressDictator {\\n    /*********\\n     * Types *\\n     *********/\\n\\n    struct NamedAddress {\\n        string name;\\n        address addr;\\n    }\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    Lib_AddressManager public manager;\\n    address public finalOwner;\\n    NamedAddress[] namedAddresses;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _manager Address of the AddressManager contract.\\n     * @param _finalOwner Address to transfer AddressManager ownership to afterwards.\\n     * @param _names Array of names to associate an address with.\\n     * @param _addresses Array of addresses to associate with the name.\\n     */\\n    constructor(\\n        Lib_AddressManager _manager,\\n        address _finalOwner,\\n        string[] memory _names,\\n        address[] memory _addresses\\n    ) {\\n        manager = _manager;\\n        finalOwner = _finalOwner;\\n        require(\\n            _names.length == _addresses.length,\\n            \\\"AddressDictator: Must provide an equal number of names and addresses.\\\"\\n        );\\n        for (uint256 i = 0; i < _names.length; i++) {\\n            namedAddresses.push(NamedAddress({ name: _names[i], addr: _addresses[i] }));\\n        }\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Called to finalize the transfer, this function is callable by anyone, but will only result in\\n     * an upgrade if this contract is the owner Address Manager.\\n     */\\n    // slither-disable-next-line calls-loop\\n    function setAddresses() external {\\n        for (uint256 i = 0; i < namedAddresses.length; i++) {\\n            manager.setAddress(namedAddresses[i].name, namedAddresses[i].addr);\\n        }\\n        // note that this will revert if _finalOwner == currentOwner\\n        manager.transferOwnership(finalOwner);\\n    }\\n\\n    /**\\n     * Transfers ownership of this contract to the finalOwner.\\n     * Only callable by the Final Owner, which is intended to be our multisig.\\n     * This function shouldn't be necessary, but it gives a sense of reassurance that we can recover\\n     * if something really surprising goes wrong.\\n     */\\n    function returnOwnership() external {\\n        require(msg.sender == finalOwner, \\\"AddressDictator: only callable by finalOwner\\\");\\n        manager.transferOwnership(finalOwner);\\n    }\\n\\n    /******************\\n     * View Functions *\\n     ******************/\\n\\n    /**\\n     * Returns the full namedAddresses array.\\n     */\\n    function getNamedAddresses() external view returns (NamedAddress[] memory) {\\n        return namedAddresses;\\n    }\\n}\\n\"\n    },\n    \"contracts/L1/deployment/ChugSplashDictator.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport { L1ChugSplashProxy } from \\\"../../chugsplash/L1ChugSplashProxy.sol\\\";\\nimport { iL1ChugSplashDeployer } from \\\"../../chugsplash/interfaces/iL1ChugSplashDeployer.sol\\\";\\n\\n/**\\n * @title ChugSplashDictator\\n * @dev Like the AddressDictator, but specifically for the Proxy__OVM_L1StandardBridge. We're\\n *      working on a generalized version of this but this is good enough for the moment.\\n */\\ncontract ChugSplashDictator is iL1ChugSplashDeployer {\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    // slither-disable-next-line constable-states\\n    bool public isUpgrading = true;\\n    L1ChugSplashProxy public target;\\n    address public finalOwner;\\n    bytes32 public codeHash;\\n    bytes32 public messengerSlotKey;\\n    bytes32 public messengerSlotVal;\\n    bytes32 public bridgeSlotKey;\\n    bytes32 public bridgeSlotVal;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    constructor(\\n        L1ChugSplashProxy _target,\\n        address _finalOwner,\\n        bytes32 _codeHash,\\n        bytes32 _messengerSlotKey,\\n        bytes32 _messengerSlotVal,\\n        bytes32 _bridgeSlotKey,\\n        bytes32 _bridgeSlotVal\\n    ) {\\n        target = _target;\\n        finalOwner = _finalOwner;\\n        codeHash = _codeHash;\\n        messengerSlotKey = _messengerSlotKey;\\n        messengerSlotVal = _messengerSlotVal;\\n        bridgeSlotKey = _bridgeSlotKey;\\n        bridgeSlotVal = _bridgeSlotVal;\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function doActions(bytes memory _code) external {\\n        require(keccak256(_code) == codeHash, \\\"ChugSplashDictator: Incorrect code hash.\\\");\\n\\n        target.setCode(_code);\\n        target.setStorage(messengerSlotKey, messengerSlotVal);\\n        target.setStorage(bridgeSlotKey, bridgeSlotVal);\\n        target.setOwner(finalOwner);\\n    }\\n\\n    /**\\n     * Transfers ownership of this contract to the finalOwner.\\n     * Only callable by the finalOwner, which is intended to be our multisig.\\n     * This function shouldn't be necessary, but it gives a sense of reassurance that we can\\n     * recover if something really surprising goes wrong.\\n     */\\n    function returnOwnership() external {\\n        require(msg.sender == finalOwner, \\\"ChugSplashDictator: only callable by finalOwner\\\");\\n\\n        target.setOwner(finalOwner);\\n    }\\n}\\n\"\n    },\n    \"contracts/L1/messaging/IL1CrossDomainMessenger.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/* Interface Imports */\\nimport { ICrossDomainMessenger } from \\\"../../libraries/bridge/ICrossDomainMessenger.sol\\\";\\n\\n/**\\n * @title IL1CrossDomainMessenger\\n */\\ninterface IL1CrossDomainMessenger is ICrossDomainMessenger {\\n    /*******************\\n     * Data Structures *\\n     *******************/\\n\\n    struct L2MessageInclusionProof {\\n        bytes32 stateRoot;\\n        Lib_OVMCodec.ChainBatchHeader stateRootBatchHeader;\\n        Lib_OVMCodec.ChainInclusionProof stateRootProof;\\n        bytes stateTrieWitness;\\n        bytes storageTrieWitness;\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Relays a cross domain message to a contract.\\n     * @param _target Target contract address.\\n     * @param _sender Message sender address.\\n     * @param _message Message to send to the target.\\n     * @param _messageNonce Nonce for the provided message.\\n     * @param _proof Inclusion proof for the given message.\\n     */\\n    function relayMessage(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _messageNonce,\\n        L2MessageInclusionProof memory _proof\\n    ) external;\\n\\n    /**\\n     * Replays a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _sender Original sender address.\\n     * @param _message Message to send to the target.\\n     * @param _queueIndex CTC Queue index for the message to replay.\\n     * @param _oldGasLimit Original gas limit used to send the message.\\n     * @param _newGasLimit New gas limit to be used for this message.\\n     */\\n    function replayMessage(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _queueIndex,\\n        uint32 _oldGasLimit,\\n        uint32 _newGasLimit\\n    ) external;\\n}\\n\"\n    },\n    \"contracts/L1/messaging/IL1ERC20Bridge.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title IL1ERC20Bridge\\n */\\ninterface IL1ERC20Bridge {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event ERC20DepositInitiated(\\n        address indexed _l1Token,\\n        address indexed _l2Token,\\n        address indexed _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes _data\\n    );\\n\\n    event ERC20WithdrawalFinalized(\\n        address indexed _l1Token,\\n        address indexed _l2Token,\\n        address indexed _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes _data\\n    );\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * @dev get the address of the corresponding L2 bridge contract.\\n     * @return Address of the corresponding L2 bridge contract.\\n     */\\n    function l2TokenBridge() external returns (address);\\n\\n    /**\\n     * @dev deposit an amount of the ERC20 to the caller's balance on L2.\\n     * @param _l1Token Address of the L1 ERC20 we are depositing\\n     * @param _l2Token Address of the L1 respective L2 ERC20\\n     * @param _amount Amount of the ERC20 to deposit\\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\\n     * @param _data Optional data to forward to L2. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function depositERC20(\\n        address _l1Token,\\n        address _l2Token,\\n        uint256 _amount,\\n        uint32 _l2Gas,\\n        bytes calldata _data\\n    ) external;\\n\\n    /**\\n     * @dev deposit an amount of ERC20 to a recipient's balance on L2.\\n     * @param _l1Token Address of the L1 ERC20 we are depositing\\n     * @param _l2Token Address of the L1 respective L2 ERC20\\n     * @param _to L2 address to credit the withdrawal to.\\n     * @param _amount Amount of the ERC20 to deposit.\\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\\n     * @param _data Optional data to forward to L2. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function depositERC20To(\\n        address _l1Token,\\n        address _l2Token,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _l2Gas,\\n        bytes calldata _data\\n    ) external;\\n\\n    /*************************\\n     * Cross-chain Functions *\\n     *************************/\\n\\n    /**\\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\\n     * L1 ERC20 token.\\n     * This call will fail if the initialized withdrawal from L2 has not been finalized.\\n     *\\n     * @param _l1Token Address of L1 token to finalizeWithdrawal for.\\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\\n     * @param _from L2 address initiating the transfer.\\n     * @param _to L1 address to credit the withdrawal to.\\n     * @param _amount Amount of the ERC20 to deposit.\\n     * @param _data Data provided by the sender on L2. This data is provided\\n     *   solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *   length, these contracts provide no guarantees about its content.\\n     */\\n    function finalizeERC20Withdrawal(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external;\\n}\\n\"\n    },\n    \"contracts/L1/messaging/IL1StandardBridge.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\nimport \\\"./IL1ERC20Bridge.sol\\\";\\n\\n/**\\n * @title IL1StandardBridge\\n */\\ninterface IL1StandardBridge is IL1ERC20Bridge {\\n    /**********\\n     * Events *\\n     **********/\\n    event ETHDepositInitiated(\\n        address indexed _from,\\n        address indexed _to,\\n        uint256 _amount,\\n        bytes _data\\n    );\\n\\n    event ETHWithdrawalFinalized(\\n        address indexed _from,\\n        address indexed _to,\\n        uint256 _amount,\\n        bytes _data\\n    );\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * @dev Deposit an amount of the ETH to the caller's balance on L2.\\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\\n     * @param _data Optional data to forward to L2. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable;\\n\\n    /**\\n     * @dev Deposit an amount of ETH to a recipient's balance on L2.\\n     * @param _to L2 address to credit the withdrawal to.\\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\\n     * @param _data Optional data to forward to L2. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function depositETHTo(\\n        address _to,\\n        uint32 _l2Gas,\\n        bytes calldata _data\\n    ) external payable;\\n\\n    /*************************\\n     * Cross-chain Functions *\\n     *************************/\\n\\n    /**\\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\\n     * L1 ETH token. Since only the xDomainMessenger can call this function, it will never be called\\n     * before the withdrawal is finalized.\\n     * @param _from L2 address initiating the transfer.\\n     * @param _to L1 address to credit the withdrawal to.\\n     * @param _amount Amount of the ERC20 to deposit.\\n     * @param _data Optional data to forward to L2. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function finalizeETHWithdrawal(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external;\\n}\\n\"\n    },\n    \"contracts/L1/messaging/L1CrossDomainMessenger.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { AddressAliasHelper } from \\\"../../standards/AddressAliasHelper.sol\\\";\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\nimport { Lib_AddressManager } from \\\"../../libraries/resolver/Lib_AddressManager.sol\\\";\\nimport { Lib_SecureMerkleTrie } from \\\"../../libraries/trie/Lib_SecureMerkleTrie.sol\\\";\\nimport { Lib_DefaultValues } from \\\"../../libraries/constants/Lib_DefaultValues.sol\\\";\\nimport { Lib_PredeployAddresses } from \\\"../../libraries/constants/Lib_PredeployAddresses.sol\\\";\\nimport { Lib_CrossDomainUtils } from \\\"../../libraries/bridge/Lib_CrossDomainUtils.sol\\\";\\n\\n/* Interface Imports */\\nimport { IL1CrossDomainMessenger } from \\\"./IL1CrossDomainMessenger.sol\\\";\\nimport { ICanonicalTransactionChain } from \\\"../rollup/ICanonicalTransactionChain.sol\\\";\\nimport { IStateCommitmentChain } from \\\"../rollup/IStateCommitmentChain.sol\\\";\\n\\n/* External Imports */\\nimport {\\n    OwnableUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport {\\n    PausableUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport {\\n    ReentrancyGuardUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\n/**\\n * @title L1CrossDomainMessenger\\n * @dev The L1 Cross Domain Messenger contract sends messages from L1 to L2, and relays messages\\n * from L2 onto L1. In the event that a message sent from L1 to L2 is rejected for exceeding the L2\\n * epoch gas limit, it can be resubmitted via this contract's replay function.\\n *\\n */\\ncontract L1CrossDomainMessenger is\\n    IL1CrossDomainMessenger,\\n    Lib_AddressResolver,\\n    OwnableUpgradeable,\\n    PausableUpgradeable,\\n    ReentrancyGuardUpgradeable\\n{\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event MessageBlocked(bytes32 indexed _xDomainCalldataHash);\\n\\n    event MessageAllowed(bytes32 indexed _xDomainCalldataHash);\\n\\n    /**********************\\n     * Contract Variables *\\n     **********************/\\n\\n    mapping(bytes32 => bool) public blockedMessages;\\n    mapping(bytes32 => bool) public relayedMessages;\\n    mapping(bytes32 => bool) public successfulMessages;\\n\\n    address internal xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * This contract is intended to be behind a delegate proxy.\\n     * We pass the zero address to the address resolver just to satisfy the constructor.\\n     * We still need to set this value in initialize().\\n     */\\n    constructor() Lib_AddressResolver(address(0)) {}\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Address Manager.\\n     */\\n    // slither-disable-next-line external-function\\n    function initialize(address _libAddressManager) public initializer {\\n        require(\\n            address(libAddressManager) == address(0),\\n            \\\"L1CrossDomainMessenger already intialized.\\\"\\n        );\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\\n\\n        // Initialize upgradable OZ contracts\\n        __Context_init_unchained(); // Context is a dependency for both Ownable and Pausable\\n        __Ownable_init_unchained();\\n        __Pausable_init_unchained();\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    /**\\n     * Pause relaying.\\n     */\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    /**\\n     * Block a message.\\n     * @param _xDomainCalldataHash Hash of the message to block.\\n     */\\n    function blockMessage(bytes32 _xDomainCalldataHash) external onlyOwner {\\n        blockedMessages[_xDomainCalldataHash] = true;\\n        emit MessageBlocked(_xDomainCalldataHash);\\n    }\\n\\n    /**\\n     * Allow a message.\\n     * @param _xDomainCalldataHash Hash of the message to block.\\n     */\\n    function allowMessage(bytes32 _xDomainCalldataHash) external onlyOwner {\\n        blockedMessages[_xDomainCalldataHash] = false;\\n        emit MessageAllowed(_xDomainCalldataHash);\\n    }\\n\\n    // slither-disable-next-line external-function\\n    function xDomainMessageSender() public view returns (address) {\\n        require(\\n            xDomainMsgSender != Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER,\\n            \\\"xDomainMessageSender is not set\\\"\\n        );\\n        return xDomainMsgSender;\\n    }\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    // slither-disable-next-line external-function\\n    function sendMessage(\\n        address _target,\\n        bytes memory _message,\\n        uint32 _gasLimit\\n    ) public {\\n        address ovmCanonicalTransactionChain = resolve(\\\"CanonicalTransactionChain\\\");\\n        // Use the CTC queue length as nonce\\n        uint40 nonce = ICanonicalTransactionChain(ovmCanonicalTransactionChain).getQueueLength();\\n\\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\\n            _target,\\n            msg.sender,\\n            _message,\\n            nonce\\n        );\\n\\n        // slither-disable-next-line reentrancy-events\\n        _sendXDomainMessage(ovmCanonicalTransactionChain, xDomainCalldata, _gasLimit);\\n\\n        // slither-disable-next-line reentrancy-events\\n        emit SentMessage(_target, msg.sender, _message, nonce, _gasLimit);\\n    }\\n\\n    /**\\n     * Relays a cross domain message to a contract.\\n     * @inheritdoc IL1CrossDomainMessenger\\n     */\\n    // slither-disable-next-line external-function\\n    function relayMessage(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _messageNonce,\\n        L2MessageInclusionProof memory _proof\\n    ) public nonReentrant whenNotPaused {\\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\\n            _target,\\n            _sender,\\n            _message,\\n            _messageNonce\\n        );\\n\\n        require(\\n            _verifyXDomainMessage(xDomainCalldata, _proof) == true,\\n            \\\"Provided message could not be verified.\\\"\\n        );\\n\\n        bytes32 xDomainCalldataHash = keccak256(xDomainCalldata);\\n\\n        require(\\n            successfulMessages[xDomainCalldataHash] == false,\\n            \\\"Provided message has already been received.\\\"\\n        );\\n\\n        require(\\n            blockedMessages[xDomainCalldataHash] == false,\\n            \\\"Provided message has been blocked.\\\"\\n        );\\n\\n        require(\\n            _target != resolve(\\\"CanonicalTransactionChain\\\"),\\n            \\\"Cannot send L2->L1 messages to L1 system contracts.\\\"\\n        );\\n\\n        xDomainMsgSender = _sender;\\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events, reentrancy-benign\\n        (bool success, ) = _target.call(_message);\\n        // slither-disable-next-line reentrancy-benign\\n        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\\n\\n        // Mark the message as received if the call was successful. Ensures that a message can be\\n        // relayed multiple times in the case that the call reverted.\\n        if (success == true) {\\n            // slither-disable-next-line reentrancy-no-eth\\n            successfulMessages[xDomainCalldataHash] = true;\\n            // slither-disable-next-line reentrancy-events\\n            emit RelayedMessage(xDomainCalldataHash);\\n        } else {\\n            // slither-disable-next-line reentrancy-events\\n            emit FailedRelayedMessage(xDomainCalldataHash);\\n        }\\n\\n        // Store an identifier that can be used to prove that the given message was relayed by some\\n        // user. Gives us an easy way to pay relayers for their work.\\n        bytes32 relayId = keccak256(abi.encodePacked(xDomainCalldata, msg.sender, block.number));\\n        // slither-disable-next-line reentrancy-benign\\n        relayedMessages[relayId] = true;\\n    }\\n\\n    /**\\n     * Replays a cross domain message to the target messenger.\\n     * @inheritdoc IL1CrossDomainMessenger\\n     */\\n    // slither-disable-next-line external-function\\n    function replayMessage(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _queueIndex,\\n        uint32 _oldGasLimit,\\n        uint32 _newGasLimit\\n    ) public {\\n        // Verify that the message is in the queue:\\n        address canonicalTransactionChain = resolve(\\\"CanonicalTransactionChain\\\");\\n        Lib_OVMCodec.QueueElement memory element = ICanonicalTransactionChain(\\n            canonicalTransactionChain\\n        ).getQueueElement(_queueIndex);\\n\\n        // Compute the calldata that was originally used to send the message.\\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\\n            _target,\\n            _sender,\\n            _message,\\n            _queueIndex\\n        );\\n\\n        // Compute the transactionHash\\n        bytes32 transactionHash = keccak256(\\n            abi.encode(\\n                AddressAliasHelper.applyL1ToL2Alias(address(this)),\\n                Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,\\n                _oldGasLimit,\\n                xDomainCalldata\\n            )\\n        );\\n\\n        // Now check that the provided message data matches the one in the queue element.\\n        require(\\n            transactionHash == element.transactionHash,\\n            \\\"Provided message has not been enqueued.\\\"\\n        );\\n\\n        // Send the same message but with the new gas limit.\\n        _sendXDomainMessage(canonicalTransactionChain, xDomainCalldata, _newGasLimit);\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Verifies that the given message is valid.\\n     * @param _xDomainCalldata Calldata to verify.\\n     * @param _proof Inclusion proof for the message.\\n     * @return Whether or not the provided message is valid.\\n     */\\n    function _verifyXDomainMessage(\\n        bytes memory _xDomainCalldata,\\n        L2MessageInclusionProof memory _proof\\n    ) internal view returns (bool) {\\n        return (_verifyStateRootProof(_proof) && _verifyStorageProof(_xDomainCalldata, _proof));\\n    }\\n\\n    /**\\n     * Verifies that the state root within an inclusion proof is valid.\\n     * @param _proof Message inclusion proof.\\n     * @return Whether or not the provided proof is valid.\\n     */\\n    function _verifyStateRootProof(L2MessageInclusionProof memory _proof)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        IStateCommitmentChain ovmStateCommitmentChain = IStateCommitmentChain(\\n            resolve(\\\"StateCommitmentChain\\\")\\n        );\\n\\n        return (ovmStateCommitmentChain.insideFraudProofWindow(_proof.stateRootBatchHeader) ==\\n            false &&\\n            ovmStateCommitmentChain.verifyStateCommitment(\\n                _proof.stateRoot,\\n                _proof.stateRootBatchHeader,\\n                _proof.stateRootProof\\n            ));\\n    }\\n\\n    /**\\n     * Verifies that the storage proof within an inclusion proof is valid.\\n     * @param _xDomainCalldata Encoded message calldata.\\n     * @param _proof Message inclusion proof.\\n     * @return Whether or not the provided proof is valid.\\n     */\\n    function _verifyStorageProof(\\n        bytes memory _xDomainCalldata,\\n        L2MessageInclusionProof memory _proof\\n    ) internal view returns (bool) {\\n        bytes32 storageKey = keccak256(\\n            abi.encodePacked(\\n                keccak256(\\n                    abi.encodePacked(\\n                        _xDomainCalldata,\\n                        Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER\\n                    )\\n                ),\\n                uint256(0)\\n            )\\n        );\\n\\n        (bool exists, bytes memory encodedMessagePassingAccount) = Lib_SecureMerkleTrie.get(\\n            abi.encodePacked(Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER),\\n            _proof.stateTrieWitness,\\n            _proof.stateRoot\\n        );\\n\\n        require(\\n            exists == true,\\n            \\\"Message passing predeploy has not been initialized or invalid proof provided.\\\"\\n        );\\n\\n        Lib_OVMCodec.EVMAccount memory account = Lib_OVMCodec.decodeEVMAccount(\\n            encodedMessagePassingAccount\\n        );\\n\\n        return\\n            Lib_SecureMerkleTrie.verifyInclusionProof(\\n                abi.encodePacked(storageKey),\\n                abi.encodePacked(uint8(1)),\\n                _proof.storageTrieWitness,\\n                account.storageRoot\\n            );\\n    }\\n\\n    /**\\n     * Sends a cross domain message.\\n     * @param _canonicalTransactionChain Address of the CanonicalTransactionChain instance.\\n     * @param _message Message to send.\\n     * @param _gasLimit OVM gas limit for the message.\\n     */\\n    function _sendXDomainMessage(\\n        address _canonicalTransactionChain,\\n        bytes memory _message,\\n        uint256 _gasLimit\\n    ) internal {\\n        // slither-disable-next-line reentrancy-events\\n        ICanonicalTransactionChain(_canonicalTransactionChain).enqueue(\\n            Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,\\n            _gasLimit,\\n            _message\\n        );\\n    }\\n}\\n\"\n    },\n    \"contracts/L1/messaging/L1StandardBridge.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Interface Imports */\\nimport { IL1StandardBridge } from \\\"./IL1StandardBridge.sol\\\";\\nimport { IL1ERC20Bridge } from \\\"./IL1ERC20Bridge.sol\\\";\\nimport { IL2ERC20Bridge } from \\\"../../L2/messaging/IL2ERC20Bridge.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/* Library Imports */\\nimport { CrossDomainEnabled } from \\\"../../libraries/bridge/CrossDomainEnabled.sol\\\";\\nimport { Lib_PredeployAddresses } from \\\"../../libraries/constants/Lib_PredeployAddresses.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/**\\n * @title L1StandardBridge\\n * @dev The L1 ETH and ERC20 Bridge is a contract which stores deposited L1 funds and standard\\n * tokens that are in use on L2. It synchronizes a corresponding L2 Bridge, informing it of deposits\\n * and listening to it for newly finalized withdrawals.\\n *\\n */\\ncontract L1StandardBridge is IL1StandardBridge, CrossDomainEnabled {\\n    using SafeERC20 for IERC20;\\n\\n    /********************************\\n     * External Contract References *\\n     ********************************/\\n\\n    address public l2TokenBridge;\\n\\n    // Maps L1 token to L2 token to balance of the L1 token deposited\\n    mapping(address => mapping(address => uint256)) public deposits;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    // This contract lives behind a proxy, so the constructor parameters will go unused.\\n    constructor() CrossDomainEnabled(address(0)) {}\\n\\n    /******************\\n     * Initialization *\\n     ******************/\\n\\n    /**\\n     * @param _l1messenger L1 Messenger address being used for cross-chain communications.\\n     * @param _l2TokenBridge L2 standard bridge address.\\n     */\\n    // slither-disable-next-line external-function\\n    function initialize(address _l1messenger, address _l2TokenBridge) public {\\n        require(messenger == address(0), \\\"Contract has already been initialized.\\\");\\n        messenger = _l1messenger;\\n        l2TokenBridge = _l2TokenBridge;\\n    }\\n\\n    /**************\\n     * Depositing *\\n     **************/\\n\\n    /** @dev Modifier requiring sender to be EOA.  This check could be bypassed by a malicious\\n     *  contract via initcode, but it takes care of the user error we want to avoid.\\n     */\\n    modifier onlyEOA() {\\n        // Used to stop deposits from contracts (avoid accidentally lost tokens)\\n        require(!Address.isContract(msg.sender), \\\"Account not EOA\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev This function can be called with no data\\n     * to deposit an amount of ETH to the caller's balance on L2.\\n     * Since the receive function doesn't take data, a conservative\\n     * default amount is forwarded to L2.\\n     */\\n    receive() external payable onlyEOA {\\n        _initiateETHDeposit(msg.sender, msg.sender, 200_000, bytes(\\\"\\\"));\\n    }\\n\\n    /**\\n     * @inheritdoc IL1StandardBridge\\n     */\\n    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable onlyEOA {\\n        _initiateETHDeposit(msg.sender, msg.sender, _l2Gas, _data);\\n    }\\n\\n    /**\\n     * @inheritdoc IL1StandardBridge\\n     */\\n    function depositETHTo(\\n        address _to,\\n        uint32 _l2Gas,\\n        bytes calldata _data\\n    ) external payable {\\n        _initiateETHDeposit(msg.sender, _to, _l2Gas, _data);\\n    }\\n\\n    /**\\n     * @dev Performs the logic for deposits by storing the ETH and informing the L2 ETH Gateway of\\n     * the deposit.\\n     * @param _from Account to pull the deposit from on L1.\\n     * @param _to Account to give the deposit to on L2.\\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\\n     * @param _data Optional data to forward to L2. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function _initiateETHDeposit(\\n        address _from,\\n        address _to,\\n        uint32 _l2Gas,\\n        bytes memory _data\\n    ) internal {\\n        // Construct calldata for finalizeDeposit call\\n        bytes memory message = abi.encodeWithSelector(\\n            IL2ERC20Bridge.finalizeDeposit.selector,\\n            address(0),\\n            Lib_PredeployAddresses.OVM_ETH,\\n            _from,\\n            _to,\\n            msg.value,\\n            _data\\n        );\\n\\n        // Send calldata into L2\\n        // slither-disable-next-line reentrancy-events\\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\\n\\n        // slither-disable-next-line reentrancy-events\\n        emit ETHDepositInitiated(_from, _to, msg.value, _data);\\n    }\\n\\n    /**\\n     * @inheritdoc IL1ERC20Bridge\\n     */\\n    function depositERC20(\\n        address _l1Token,\\n        address _l2Token,\\n        uint256 _amount,\\n        uint32 _l2Gas,\\n        bytes calldata _data\\n    ) external virtual onlyEOA {\\n        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, msg.sender, _amount, _l2Gas, _data);\\n    }\\n\\n    /**\\n     * @inheritdoc IL1ERC20Bridge\\n     */\\n    function depositERC20To(\\n        address _l1Token,\\n        address _l2Token,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _l2Gas,\\n        bytes calldata _data\\n    ) external virtual {\\n        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, _to, _amount, _l2Gas, _data);\\n    }\\n\\n    /**\\n     * @dev Performs the logic for deposits by informing the L2 Deposited Token\\n     * contract of the deposit and calling a handler to lock the L1 funds. (e.g. transferFrom)\\n     *\\n     * @param _l1Token Address of the L1 ERC20 we are depositing\\n     * @param _l2Token Address of the L1 respective L2 ERC20\\n     * @param _from Account to pull the deposit from on L1\\n     * @param _to Account to give the deposit to on L2\\n     * @param _amount Amount of the ERC20 to deposit.\\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\\n     * @param _data Optional data to forward to L2. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function _initiateERC20Deposit(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _l2Gas,\\n        bytes calldata _data\\n    ) internal {\\n        // When a deposit is initiated on L1, the L1 Bridge transfers the funds to itself for future\\n        // withdrawals. The use of safeTransferFrom enables support of \\\"broken tokens\\\" which do not\\n        // return a boolean value.\\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\\n        IERC20(_l1Token).safeTransferFrom(_from, address(this), _amount);\\n\\n        // Construct calldata for _l2Token.finalizeDeposit(_to, _amount)\\n        bytes memory message = abi.encodeWithSelector(\\n            IL2ERC20Bridge.finalizeDeposit.selector,\\n            _l1Token,\\n            _l2Token,\\n            _from,\\n            _to,\\n            _amount,\\n            _data\\n        );\\n\\n        // Send calldata into L2\\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\\n\\n        // slither-disable-next-line reentrancy-benign\\n        deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] + _amount;\\n\\n        // slither-disable-next-line reentrancy-events\\n        emit ERC20DepositInitiated(_l1Token, _l2Token, _from, _to, _amount, _data);\\n    }\\n\\n    /*************************\\n     * Cross-chain Functions *\\n     *************************/\\n\\n    /**\\n     * @inheritdoc IL1StandardBridge\\n     */\\n    function finalizeETHWithdrawal(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external onlyFromCrossDomainAccount(l2TokenBridge) {\\n        // slither-disable-next-line reentrancy-events\\n        (bool success, ) = _to.call{ value: _amount }(new bytes(0));\\n        require(success, \\\"TransferHelper::safeTransferETH: ETH transfer failed\\\");\\n\\n        // slither-disable-next-line reentrancy-events\\n        emit ETHWithdrawalFinalized(_from, _to, _amount, _data);\\n    }\\n\\n    /**\\n     * @inheritdoc IL1ERC20Bridge\\n     */\\n    function finalizeERC20Withdrawal(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external onlyFromCrossDomainAccount(l2TokenBridge) {\\n        deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] - _amount;\\n\\n        // When a withdrawal is finalized on L1, the L1 Bridge transfers the funds to the withdrawer\\n        // slither-disable-next-line reentrancy-events\\n        IERC20(_l1Token).safeTransfer(_to, _amount);\\n\\n        // slither-disable-next-line reentrancy-events\\n        emit ERC20WithdrawalFinalized(_l1Token, _l2Token, _from, _to, _amount, _data);\\n    }\\n\\n    /*****************************\\n     * Temporary - Migrating ETH *\\n     *****************************/\\n\\n    /**\\n     * @dev Adds ETH balance to the account. This is meant to allow for ETH\\n     * to be migrated from an old gateway to a new gateway.\\n     * NOTE: This is left for one upgrade only so we are able to receive the migrated ETH from the\\n     * old contract\\n     */\\n    function donateETH() external payable {}\\n}\\n\"\n    },\n    \"contracts/L1/rollup/CanonicalTransactionChain.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { AddressAliasHelper } from \\\"../../standards/AddressAliasHelper.sol\\\";\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\n\\n/* Interface Imports */\\nimport { ICanonicalTransactionChain } from \\\"./ICanonicalTransactionChain.sol\\\";\\nimport { IChainStorageContainer } from \\\"./IChainStorageContainer.sol\\\";\\n\\n/**\\n * @title CanonicalTransactionChain\\n * @dev The Canonical Transaction Chain (CTC) contract is an append-only log of transactions\\n * which must be applied to the rollup state. It defines the ordering of rollup transactions by\\n * writing them to the 'CTC:batches' instance of the Chain Storage Container.\\n * The CTC also allows any account to 'enqueue' an L2 transaction, which will require that the\\n * Sequencer will eventually append it to the rollup state.\\n *\\n */\\ncontract CanonicalTransactionChain is ICanonicalTransactionChain, Lib_AddressResolver {\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    // L2 tx gas-related\\n    uint256 public constant MIN_ROLLUP_TX_GAS = 100000;\\n    uint256 public constant MAX_ROLLUP_TX_SIZE = 50000;\\n\\n    // The approximate cost of calling the enqueue function\\n    uint256 public enqueueGasCost;\\n    // The ratio of the cost of L1 gas to the cost of L2 gas\\n    uint256 public l2GasDiscountDivisor;\\n    // The amount of L2 gas which can be forwarded to L2 without spam prevention via 'gas burn'.\\n    // Calculated as the product of l2GasDiscountDivisor * enqueueGasCost.\\n    // See comments in enqueue() for further detail.\\n    uint256 public enqueueL2GasPrepaid;\\n\\n    // Encoding-related (all in bytes)\\n    uint256 internal constant BATCH_CONTEXT_SIZE = 16;\\n    // slither-disable-next-line unused-state\\n    uint256 internal constant BATCH_CONTEXT_LENGTH_POS = 12;\\n    uint256 internal constant BATCH_CONTEXT_START_POS = 15;\\n    // slither-disable-next-line unused-state\\n    uint256 internal constant TX_DATA_HEADER_SIZE = 3;\\n    // slither-disable-next-line unused-state\\n    uint256 internal constant BYTES_TILL_TX_DATA = 65;\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    uint256 public maxTransactionGasLimit;\\n\\n    /***************\\n     * Queue State *\\n     ***************/\\n\\n    uint40 private _nextQueueIndex; // index of the first queue element not yet included\\n    Lib_OVMCodec.QueueElement[] queueElements;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    constructor(\\n        address _libAddressManager,\\n        uint256 _maxTransactionGasLimit,\\n        uint256 _l2GasDiscountDivisor,\\n        uint256 _enqueueGasCost\\n    ) Lib_AddressResolver(_libAddressManager) {\\n        maxTransactionGasLimit = _maxTransactionGasLimit;\\n        l2GasDiscountDivisor = _l2GasDiscountDivisor;\\n        enqueueGasCost = _enqueueGasCost;\\n        enqueueL2GasPrepaid = _l2GasDiscountDivisor * _enqueueGasCost;\\n    }\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    /**\\n     * Modifier to enforce that, if configured, only the Burn Admin may\\n     * successfully call a method.\\n     */\\n    modifier onlyBurnAdmin() {\\n        require(msg.sender == libAddressManager.owner(), \\\"Only callable by the Burn Admin.\\\");\\n        _;\\n    }\\n\\n    /*******************************\\n     * Authorized Setter Functions *\\n     *******************************/\\n\\n    /**\\n     * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.\\n     * The value of enqueueL2GasPrepaid is immediately updated as well.\\n     */\\n    function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost)\\n        external\\n        onlyBurnAdmin\\n    {\\n        enqueueGasCost = _enqueueGasCost;\\n        l2GasDiscountDivisor = _l2GasDiscountDivisor;\\n        // See the comment in enqueue() for the rationale behind this formula.\\n        enqueueL2GasPrepaid = _l2GasDiscountDivisor * _enqueueGasCost;\\n\\n        emit L2GasParamsUpdated(l2GasDiscountDivisor, enqueueGasCost, enqueueL2GasPrepaid);\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Accesses the batch storage container.\\n     * @return Reference to the batch storage container.\\n     */\\n    function batches() public view returns (IChainStorageContainer) {\\n        return IChainStorageContainer(resolve(\\\"ChainStorageContainer-CTC-batches\\\"));\\n    }\\n\\n    /**\\n     * Retrieves the total number of elements submitted.\\n     * @return _totalElements Total submitted elements.\\n     */\\n    function getTotalElements() public view returns (uint256 _totalElements) {\\n        (uint40 totalElements, , , ) = _getBatchExtraData();\\n        return uint256(totalElements);\\n    }\\n\\n    /**\\n     * Retrieves the total number of batches submitted.\\n     * @return _totalBatches Total submitted batches.\\n     */\\n    // slither-disable-next-line external-function\\n    function getTotalBatches() public view returns (uint256 _totalBatches) {\\n        return batches().length();\\n    }\\n\\n    /**\\n     * Returns the index of the next element to be enqueued.\\n     * @return Index for the next queue element.\\n     */\\n    // slither-disable-next-line external-function\\n    function getNextQueueIndex() public view returns (uint40) {\\n        return _nextQueueIndex;\\n    }\\n\\n    /**\\n     * Returns the timestamp of the last transaction.\\n     * @return Timestamp for the last transaction.\\n     */\\n    // slither-disable-next-line external-function\\n    function getLastTimestamp() public view returns (uint40) {\\n        (, , uint40 lastTimestamp, ) = _getBatchExtraData();\\n        return lastTimestamp;\\n    }\\n\\n    /**\\n     * Returns the blocknumber of the last transaction.\\n     * @return Blocknumber for the last transaction.\\n     */\\n    // slither-disable-next-line external-function\\n    function getLastBlockNumber() public view returns (uint40) {\\n        (, , , uint40 lastBlockNumber) = _getBatchExtraData();\\n        return lastBlockNumber;\\n    }\\n\\n    /**\\n     * Gets the queue element at a particular index.\\n     * @param _index Index of the queue element to access.\\n     * @return _element Queue element at the given index.\\n     */\\n    // slither-disable-next-line external-function\\n    function getQueueElement(uint256 _index)\\n        public\\n        view\\n        returns (Lib_OVMCodec.QueueElement memory _element)\\n    {\\n        return queueElements[_index];\\n    }\\n\\n    /**\\n     * Get the number of queue elements which have not yet been included.\\n     * @return Number of pending queue elements.\\n     */\\n    // slither-disable-next-line external-function\\n    function getNumPendingQueueElements() public view returns (uint40) {\\n        return uint40(queueElements.length) - _nextQueueIndex;\\n    }\\n\\n    /**\\n     * Retrieves the length of the queue, including\\n     * both pending and canonical transactions.\\n     * @return Length of the queue.\\n     */\\n    // slither-disable-next-line external-function\\n    function getQueueLength() public view returns (uint40) {\\n        return uint40(queueElements.length);\\n    }\\n\\n    /**\\n     * Adds a transaction to the queue.\\n     * @param _target Target L2 contract to send the transaction to.\\n     * @param _gasLimit Gas limit for the enqueued L2 transaction.\\n     * @param _data Transaction data.\\n     */\\n    function enqueue(\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    ) external {\\n        require(\\n            _data.length <= MAX_ROLLUP_TX_SIZE,\\n            \\\"Transaction data size exceeds maximum for rollup transaction.\\\"\\n        );\\n\\n        require(\\n            _gasLimit <= maxTransactionGasLimit,\\n            \\\"Transaction gas limit exceeds maximum for rollup transaction.\\\"\\n        );\\n\\n        require(_gasLimit >= MIN_ROLLUP_TX_GAS, \\\"Transaction gas limit too low to enqueue.\\\");\\n\\n        // Transactions submitted to the queue lack a method for paying gas fees to the Sequencer.\\n        // So we need to prevent spam attacks by ensuring that the cost of enqueueing a transaction\\n        // from L1 to L2 is not underpriced. For transaction with a high L2 gas limit, we do this by\\n        // burning some extra gas on L1. Of course there is also some intrinsic cost to enqueueing a\\n        // transaction, so we want to make sure not to over-charge (by burning too much L1 gas).\\n        // Therefore, we define 'enqueueL2GasPrepaid' as the L2 gas limit above which we must burn\\n        // additional gas on L1. This threshold is the product of two inputs:\\n        // 1. enqueueGasCost: the base cost of calling this function.\\n        // 2. l2GasDiscountDivisor: the ratio between the cost of gas on L1 and L2. This is a\\n        //    positive integer, meaning we assume L2 gas is always less costly.\\n        // The calculation below for gasToConsume can be seen as converting the difference (between\\n        // the specified L2 gas limit and the prepaid L2 gas limit) to an L1 gas amount.\\n        if (_gasLimit > enqueueL2GasPrepaid) {\\n            uint256 gasToConsume = (_gasLimit - enqueueL2GasPrepaid) / l2GasDiscountDivisor;\\n            uint256 startingGas = gasleft();\\n\\n            // Although this check is not necessary (burn below will run out of gas if not true), it\\n            // gives the user an explicit reason as to why the enqueue attempt failed.\\n            require(startingGas > gasToConsume, \\\"Insufficient gas for L2 rate limiting burn.\\\");\\n\\n            uint256 i;\\n            while (startingGas - gasleft() < gasToConsume) {\\n                i++;\\n            }\\n        }\\n\\n        // Apply an aliasing unless msg.sender == tx.origin. This prevents an attack in which a\\n        // contract on L1 has the same address as a contract on L2 but doesn't have the same code.\\n        // We can safely ignore this for EOAs because they're guaranteed to have the same \\\"code\\\"\\n        // (i.e. no code at all). This also makes it possible for users to interact with contracts\\n        // on L2 even when the Sequencer is down.\\n        address sender;\\n        if (msg.sender == tx.origin) {\\n            sender = msg.sender;\\n        } else {\\n            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\\n        }\\n\\n        bytes32 transactionHash = keccak256(abi.encode(sender, _target, _gasLimit, _data));\\n\\n        queueElements.push(\\n            Lib_OVMCodec.QueueElement({\\n                transactionHash: transactionHash,\\n                timestamp: uint40(block.timestamp),\\n                blockNumber: uint40(block.number)\\n            })\\n        );\\n        uint256 queueIndex = queueElements.length - 1;\\n        emit TransactionEnqueued(sender, _target, _gasLimit, _data, queueIndex, block.timestamp);\\n    }\\n\\n    /**\\n     * Allows the sequencer to append a batch of transactions.\\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\\n     * .param _contexts Array of batch contexts.\\n     * .param _transactionDataFields Array of raw transaction data.\\n     */\\n    function appendSequencerBatch() external {\\n        uint40 shouldStartAtElement;\\n        uint24 totalElementsToAppend;\\n        uint24 numContexts;\\n        assembly {\\n            shouldStartAtElement := shr(216, calldataload(4))\\n            totalElementsToAppend := shr(232, calldataload(9))\\n            numContexts := shr(232, calldataload(12))\\n        }\\n\\n        require(\\n            shouldStartAtElement == getTotalElements(),\\n            \\\"Actual batch start index does not match expected start index.\\\"\\n        );\\n\\n        require(\\n            msg.sender == resolve(\\\"OVM_Sequencer\\\"),\\n            \\\"Function can only be called by the Sequencer.\\\"\\n        );\\n\\n        uint40 nextTransactionPtr = uint40(\\n            BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts\\n        );\\n\\n        require(msg.data.length >= nextTransactionPtr, \\\"Not enough BatchContexts provided.\\\");\\n\\n        // Counter for number of sequencer transactions appended so far.\\n        uint32 numSequencerTransactions = 0;\\n\\n        // Cache the _nextQueueIndex storage variable to a temporary stack variable.\\n        // This is safe as long as nothing reads or writes to the storage variable\\n        // until it is updated by the temp variable.\\n        uint40 nextQueueIndex = _nextQueueIndex;\\n\\n        BatchContext memory curContext;\\n        for (uint32 i = 0; i < numContexts; i++) {\\n            BatchContext memory nextContext = _getBatchContext(i);\\n\\n            // Now we can update our current context.\\n            curContext = nextContext;\\n\\n            // Process sequencer transactions first.\\n            numSequencerTransactions += uint32(curContext.numSequencedTransactions);\\n\\n            // Now process any subsequent queue transactions.\\n            nextQueueIndex += uint40(curContext.numSubsequentQueueTransactions);\\n        }\\n\\n        require(\\n            nextQueueIndex <= queueElements.length,\\n            \\\"Attempted to append more elements than are available in the queue.\\\"\\n        );\\n\\n        // Generate the required metadata that we need to append this batch\\n        uint40 numQueuedTransactions = totalElementsToAppend - numSequencerTransactions;\\n        uint40 blockTimestamp;\\n        uint40 blockNumber;\\n        if (curContext.numSubsequentQueueTransactions == 0) {\\n            // The last element is a sequencer tx, therefore pull timestamp and block number from\\n            // the last context.\\n            blockTimestamp = uint40(curContext.timestamp);\\n            blockNumber = uint40(curContext.blockNumber);\\n        } else {\\n            // The last element is a queue tx, therefore pull timestamp and block number from the\\n            // queue element.\\n            // curContext.numSubsequentQueueTransactions > 0 which means that we've processed at\\n            // least one queue element. We increment nextQueueIndex after processing each queue\\n            // element, so the index of the last element we processed is nextQueueIndex - 1.\\n            Lib_OVMCodec.QueueElement memory lastElement = queueElements[nextQueueIndex - 1];\\n\\n            blockTimestamp = lastElement.timestamp;\\n            blockNumber = lastElement.blockNumber;\\n        }\\n\\n        // Cache the previous blockhash to ensure all transaction data can be retrieved efficiently.\\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events\\n        _appendBatch(\\n            blockhash(block.number - 1),\\n            totalElementsToAppend,\\n            numQueuedTransactions,\\n            blockTimestamp,\\n            blockNumber\\n        );\\n\\n        // slither-disable-next-line reentrancy-events\\n        emit SequencerBatchAppended(\\n            nextQueueIndex - numQueuedTransactions,\\n            numQueuedTransactions,\\n            getTotalElements()\\n        );\\n\\n        // Update the _nextQueueIndex storage variable.\\n        // slither-disable-next-line reentrancy-no-eth\\n        _nextQueueIndex = nextQueueIndex;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Returns the BatchContext located at a particular index.\\n     * @param _index The index of the BatchContext\\n     * @return The BatchContext at the specified index.\\n     */\\n    function _getBatchContext(uint256 _index) internal pure returns (BatchContext memory) {\\n        uint256 contextPtr = 15 + _index * BATCH_CONTEXT_SIZE;\\n        // slither-disable-next-line similar-names\\n        uint256 numSequencedTransactions;\\n        uint256 numSubsequentQueueTransactions;\\n        uint256 ctxTimestamp;\\n        uint256 ctxBlockNumber;\\n\\n        assembly {\\n            numSequencedTransactions := shr(232, calldataload(contextPtr))\\n            numSubsequentQueueTransactions := shr(232, calldataload(add(contextPtr, 3)))\\n            ctxTimestamp := shr(216, calldataload(add(contextPtr, 6)))\\n            ctxBlockNumber := shr(216, calldataload(add(contextPtr, 11)))\\n        }\\n\\n        return\\n            BatchContext({\\n                numSequencedTransactions: numSequencedTransactions,\\n                numSubsequentQueueTransactions: numSubsequentQueueTransactions,\\n                timestamp: ctxTimestamp,\\n                blockNumber: ctxBlockNumber\\n            });\\n    }\\n\\n    /**\\n     * Parses the batch context from the extra data.\\n     * @return Total number of elements submitted.\\n     * @return Index of the next queue element.\\n     */\\n    function _getBatchExtraData()\\n        internal\\n        view\\n        returns (\\n            uint40,\\n            uint40,\\n            uint40,\\n            uint40\\n        )\\n    {\\n        bytes27 extraData = batches().getGlobalMetadata();\\n\\n        uint40 totalElements;\\n        uint40 nextQueueIndex;\\n        uint40 lastTimestamp;\\n        uint40 lastBlockNumber;\\n\\n        // solhint-disable max-line-length\\n        assembly {\\n            extraData := shr(40, extraData)\\n            totalElements := and(\\n                extraData,\\n                0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF\\n            )\\n            nextQueueIndex := shr(\\n                40,\\n                and(extraData, 0x00000000000000000000000000000000000000000000FFFFFFFFFF0000000000)\\n            )\\n            lastTimestamp := shr(\\n                80,\\n                and(extraData, 0x0000000000000000000000000000000000FFFFFFFFFF00000000000000000000)\\n            )\\n            lastBlockNumber := shr(\\n                120,\\n                and(extraData, 0x000000000000000000000000FFFFFFFFFF000000000000000000000000000000)\\n            )\\n        }\\n        // solhint-enable max-line-length\\n\\n        return (totalElements, nextQueueIndex, lastTimestamp, lastBlockNumber);\\n    }\\n\\n    /**\\n     * Encodes the batch context for the extra data.\\n     * @param _totalElements Total number of elements submitted.\\n     * @param _nextQueueIdx Index of the next queue element.\\n     * @param _timestamp Timestamp for the last batch.\\n     * @param _blockNumber Block number of the last batch.\\n     * @return Encoded batch context.\\n     */\\n    function _makeBatchExtraData(\\n        uint40 _totalElements,\\n        uint40 _nextQueueIdx,\\n        uint40 _timestamp,\\n        uint40 _blockNumber\\n    ) internal pure returns (bytes27) {\\n        bytes27 extraData;\\n        assembly {\\n            extraData := _totalElements\\n            extraData := or(extraData, shl(40, _nextQueueIdx))\\n            extraData := or(extraData, shl(80, _timestamp))\\n            extraData := or(extraData, shl(120, _blockNumber))\\n            extraData := shl(40, extraData)\\n        }\\n\\n        return extraData;\\n    }\\n\\n    /**\\n     * Inserts a batch into the chain of batches.\\n     * @param _transactionRoot Root of the transaction tree for this batch.\\n     * @param _batchSize Number of elements in the batch.\\n     * @param _numQueuedTransactions Number of queue transactions in the batch.\\n     * @param _timestamp The latest batch timestamp.\\n     * @param _blockNumber The latest batch blockNumber.\\n     */\\n    function _appendBatch(\\n        bytes32 _transactionRoot,\\n        uint256 _batchSize,\\n        uint256 _numQueuedTransactions,\\n        uint40 _timestamp,\\n        uint40 _blockNumber\\n    ) internal {\\n        IChainStorageContainer batchesRef = batches();\\n        (uint40 totalElements, uint40 nextQueueIndex, , ) = _getBatchExtraData();\\n\\n        Lib_OVMCodec.ChainBatchHeader memory header = Lib_OVMCodec.ChainBatchHeader({\\n            batchIndex: batchesRef.length(),\\n            batchRoot: _transactionRoot,\\n            batchSize: _batchSize,\\n            prevTotalElements: totalElements,\\n            extraData: hex\\\"\\\"\\n        });\\n\\n        emit TransactionBatchAppended(\\n            header.batchIndex,\\n            header.batchRoot,\\n            header.batchSize,\\n            header.prevTotalElements,\\n            header.extraData\\n        );\\n\\n        bytes32 batchHeaderHash = Lib_OVMCodec.hashBatchHeader(header);\\n        bytes27 latestBatchContext = _makeBatchExtraData(\\n            totalElements + uint40(header.batchSize),\\n            nextQueueIndex + uint40(_numQueuedTransactions),\\n            _timestamp,\\n            _blockNumber\\n        );\\n\\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events\\n        batchesRef.push(batchHeaderHash, latestBatchContext);\\n    }\\n}\\n\"\n    },\n    \"contracts/L1/rollup/ChainStorageContainer.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_Buffer } from \\\"../../libraries/utils/Lib_Buffer.sol\\\";\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\n\\n/* Interface Imports */\\nimport { IChainStorageContainer } from \\\"./IChainStorageContainer.sol\\\";\\n\\n/**\\n * @title ChainStorageContainer\\n * @dev The Chain Storage Container provides its owner contract with read, write and delete\\n * functionality. This provides gas efficiency gains by enabling it to overwrite storage slots which\\n * can no longer be used in a fraud proof due to the fraud window having passed, and the associated\\n * chain state or transactions being finalized.\\n * Three distinct Chain Storage Containers will be deployed on Layer 1:\\n * 1. Stores transaction batches for the Canonical Transaction Chain\\n * 2. Stores queued transactions for the Canonical Transaction Chain\\n * 3. Stores chain state batches for the State Commitment Chain\\n *\\n */\\ncontract ChainStorageContainer is IChainStorageContainer, Lib_AddressResolver {\\n    /*************\\n     * Libraries *\\n     *************/\\n\\n    using Lib_Buffer for Lib_Buffer.Buffer;\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    string public owner;\\n    Lib_Buffer.Buffer internal buffer;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Address Manager.\\n     * @param _owner Name of the contract that owns this container (will be resolved later).\\n     */\\n    constructor(address _libAddressManager, string memory _owner)\\n        Lib_AddressResolver(_libAddressManager)\\n    {\\n        owner = _owner;\\n    }\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == resolve(owner),\\n            \\\"ChainStorageContainer: Function can only be called by the owner.\\\"\\n        );\\n        _;\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function setGlobalMetadata(bytes27 _globalMetadata) public onlyOwner {\\n        return buffer.setExtraData(_globalMetadata);\\n    }\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function getGlobalMetadata() public view returns (bytes27) {\\n        return buffer.getExtraData();\\n    }\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function length() public view returns (uint256) {\\n        return uint256(buffer.getLength());\\n    }\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function push(bytes32 _object) public onlyOwner {\\n        buffer.push(_object);\\n    }\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function push(bytes32 _object, bytes27 _globalMetadata) public onlyOwner {\\n        buffer.push(_object, _globalMetadata);\\n    }\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function get(uint256 _index) public view returns (bytes32) {\\n        return buffer.get(uint40(_index));\\n    }\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function deleteElementsAfterInclusive(uint256 _index) public onlyOwner {\\n        buffer.deleteElementsAfterInclusive(uint40(_index));\\n    }\\n\\n    /**\\n     * @inheritdoc IChainStorageContainer\\n     */\\n    // slither-disable-next-line external-function\\n    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata)\\n        public\\n        onlyOwner\\n    {\\n        buffer.deleteElementsAfterInclusive(uint40(_index), _globalMetadata);\\n    }\\n}\\n\"\n    },\n    \"contracts/L1/rollup/ICanonicalTransactionChain.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/* Interface Imports */\\nimport { IChainStorageContainer } from \\\"./IChainStorageContainer.sol\\\";\\n\\n/**\\n * @title ICanonicalTransactionChain\\n */\\ninterface ICanonicalTransactionChain {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event L2GasParamsUpdated(\\n        uint256 l2GasDiscountDivisor,\\n        uint256 enqueueGasCost,\\n        uint256 enqueueL2GasPrepaid\\n    );\\n\\n    event TransactionEnqueued(\\n        address indexed _l1TxOrigin,\\n        address indexed _target,\\n        uint256 _gasLimit,\\n        bytes _data,\\n        uint256 indexed _queueIndex,\\n        uint256 _timestamp\\n    );\\n\\n    event QueueBatchAppended(\\n        uint256 _startingQueueIndex,\\n        uint256 _numQueueElements,\\n        uint256 _totalElements\\n    );\\n\\n    event SequencerBatchAppended(\\n        uint256 _startingQueueIndex,\\n        uint256 _numQueueElements,\\n        uint256 _totalElements\\n    );\\n\\n    event TransactionBatchAppended(\\n        uint256 indexed _batchIndex,\\n        bytes32 _batchRoot,\\n        uint256 _batchSize,\\n        uint256 _prevTotalElements,\\n        bytes _extraData\\n    );\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct BatchContext {\\n        uint256 numSequencedTransactions;\\n        uint256 numSubsequentQueueTransactions;\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n    }\\n\\n    /*******************************\\n     * Authorized Setter Functions *\\n     *******************************/\\n\\n    /**\\n     * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.\\n     * The value of enqueueL2GasPrepaid is immediately updated as well.\\n     */\\n    function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost) external;\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Accesses the batch storage container.\\n     * @return Reference to the batch storage container.\\n     */\\n    function batches() external view returns (IChainStorageContainer);\\n\\n    /**\\n     * Retrieves the total number of elements submitted.\\n     * @return _totalElements Total submitted elements.\\n     */\\n    function getTotalElements() external view returns (uint256 _totalElements);\\n\\n    /**\\n     * Retrieves the total number of batches submitted.\\n     * @return _totalBatches Total submitted batches.\\n     */\\n    function getTotalBatches() external view returns (uint256 _totalBatches);\\n\\n    /**\\n     * Returns the index of the next element to be enqueued.\\n     * @return Index for the next queue element.\\n     */\\n    function getNextQueueIndex() external view returns (uint40);\\n\\n    /**\\n     * Gets the queue element at a particular index.\\n     * @param _index Index of the queue element to access.\\n     * @return _element Queue element at the given index.\\n     */\\n    function getQueueElement(uint256 _index)\\n        external\\n        view\\n        returns (Lib_OVMCodec.QueueElement memory _element);\\n\\n    /**\\n     * Returns the timestamp of the last transaction.\\n     * @return Timestamp for the last transaction.\\n     */\\n    function getLastTimestamp() external view returns (uint40);\\n\\n    /**\\n     * Returns the blocknumber of the last transaction.\\n     * @return Blocknumber for the last transaction.\\n     */\\n    function getLastBlockNumber() external view returns (uint40);\\n\\n    /**\\n     * Get the number of queue elements which have not yet been included.\\n     * @return Number of pending queue elements.\\n     */\\n    function getNumPendingQueueElements() external view returns (uint40);\\n\\n    /**\\n     * Retrieves the length of the queue, including\\n     * both pending and canonical transactions.\\n     * @return Length of the queue.\\n     */\\n    function getQueueLength() external view returns (uint40);\\n\\n    /**\\n     * Adds a transaction to the queue.\\n     * @param _target Target contract to send the transaction to.\\n     * @param _gasLimit Gas limit for the given transaction.\\n     * @param _data Transaction data.\\n     */\\n    function enqueue(\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    ) external;\\n\\n    /**\\n     * Allows the sequencer to append a batch of transactions.\\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\\n     * .param _contexts Array of batch contexts.\\n     * .param _transactionDataFields Array of raw transaction data.\\n     */\\n    function appendSequencerBatch(\\n        // uint40 _shouldStartAtElement,\\n        // uint24 _totalElementsToAppend,\\n        // BatchContext[] _contexts,\\n        // bytes[] _transactionDataFields\\n    ) external;\\n}\\n\"\n    },\n    \"contracts/L1/rollup/IChainStorageContainer.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title IChainStorageContainer\\n */\\ninterface IChainStorageContainer {\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\\n     * 27 bytes to store arbitrary data.\\n     * @param _globalMetadata New global metadata to set.\\n     */\\n    function setGlobalMetadata(bytes27 _globalMetadata) external;\\n\\n    /**\\n     * Retrieves the container's global metadata field.\\n     * @return Container global metadata field.\\n     */\\n    function getGlobalMetadata() external view returns (bytes27);\\n\\n    /**\\n     * Retrieves the number of objects stored in the container.\\n     * @return Number of objects in the container.\\n     */\\n    function length() external view returns (uint256);\\n\\n    /**\\n     * Pushes an object into the container.\\n     * @param _object A 32 byte value to insert into the container.\\n     */\\n    function push(bytes32 _object) external;\\n\\n    /**\\n     * Pushes an object into the container. Function allows setting the global metadata since\\n     * we'll need to touch the \\\"length\\\" storage slot anyway, which also contains the global\\n     * metadata (it's an optimization).\\n     * @param _object A 32 byte value to insert into the container.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function push(bytes32 _object, bytes27 _globalMetadata) external;\\n\\n    /**\\n     * Retrieves an object from the container.\\n     * @param _index Index of the particular object to access.\\n     * @return 32 byte object value.\\n     */\\n    function get(uint256 _index) external view returns (bytes32);\\n\\n    /**\\n     * Removes all objects after and including a given index.\\n     * @param _index Object index to delete from.\\n     */\\n    function deleteElementsAfterInclusive(uint256 _index) external;\\n\\n    /**\\n     * Removes all objects after and including a given index. Also allows setting the global\\n     * metadata field.\\n     * @param _index Object index to delete from.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata) external;\\n}\\n\"\n    },\n    \"contracts/L1/rollup/IStateCommitmentChain.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/**\\n * @title IStateCommitmentChain\\n */\\ninterface IStateCommitmentChain {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event StateBatchAppended(\\n        uint256 indexed _batchIndex,\\n        bytes32 _batchRoot,\\n        uint256 _batchSize,\\n        uint256 _prevTotalElements,\\n        bytes _extraData\\n    );\\n\\n    event StateBatchDeleted(uint256 indexed _batchIndex, bytes32 _batchRoot);\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Retrieves the total number of elements submitted.\\n     * @return _totalElements Total submitted elements.\\n     */\\n    function getTotalElements() external view returns (uint256 _totalElements);\\n\\n    /**\\n     * Retrieves the total number of batches submitted.\\n     * @return _totalBatches Total submitted batches.\\n     */\\n    function getTotalBatches() external view returns (uint256 _totalBatches);\\n\\n    /**\\n     * Retrieves the timestamp of the last batch submitted by the sequencer.\\n     * @return _lastSequencerTimestamp Last sequencer batch timestamp.\\n     */\\n    function getLastSequencerTimestamp() external view returns (uint256 _lastSequencerTimestamp);\\n\\n    /**\\n     * Appends a batch of state roots to the chain.\\n     * @param _batch Batch of state roots.\\n     * @param _shouldStartAtElement Index of the element at which this batch should start.\\n     */\\n    function appendStateBatch(bytes32[] calldata _batch, uint256 _shouldStartAtElement) external;\\n\\n    /**\\n     * Deletes all state roots after (and including) a given batch.\\n     * @param _batchHeader Header of the batch to start deleting from.\\n     */\\n    function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) external;\\n\\n    /**\\n     * Verifies a batch inclusion proof.\\n     * @param _element Hash of the element to verify a proof for.\\n     * @param _batchHeader Header of the batch in which the element was included.\\n     * @param _proof Merkle inclusion proof for the element.\\n     */\\n    function verifyStateCommitment(\\n        bytes32 _element,\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\\n        Lib_OVMCodec.ChainInclusionProof memory _proof\\n    ) external view returns (bool _verified);\\n\\n    /**\\n     * Checks whether a given batch is still inside its fraud proof window.\\n     * @param _batchHeader Header of the batch to check.\\n     * @return _inside Whether or not the batch is inside the fraud proof window.\\n     */\\n    function insideFraudProofWindow(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\\n        external\\n        view\\n        returns (bool _inside);\\n}\\n\"\n    },\n    \"contracts/L1/rollup/StateCommitmentChain.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\nimport { Lib_MerkleTree } from \\\"../../libraries/utils/Lib_MerkleTree.sol\\\";\\n\\n/* Interface Imports */\\nimport { IStateCommitmentChain } from \\\"./IStateCommitmentChain.sol\\\";\\nimport { ICanonicalTransactionChain } from \\\"./ICanonicalTransactionChain.sol\\\";\\nimport { IBondManager } from \\\"../verification/IBondManager.sol\\\";\\nimport { IChainStorageContainer } from \\\"./IChainStorageContainer.sol\\\";\\n\\n/**\\n * @title StateCommitmentChain\\n * @dev The State Commitment Chain (SCC) contract contains a list of proposed state roots which\\n * Proposers assert to be a result of each transaction in the Canonical Transaction Chain (CTC).\\n * Elements here have a 1:1 correspondence with transactions in the CTC, and should be the unique\\n * state root calculated off-chain by applying the canonical transactions one by one.\\n *\\n */\\ncontract StateCommitmentChain is IStateCommitmentChain, Lib_AddressResolver {\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    uint256 public FRAUD_PROOF_WINDOW;\\n    uint256 public SEQUENCER_PUBLISH_WINDOW;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Address Manager.\\n     */\\n    constructor(\\n        address _libAddressManager,\\n        uint256 _fraudProofWindow,\\n        uint256 _sequencerPublishWindow\\n    ) Lib_AddressResolver(_libAddressManager) {\\n        FRAUD_PROOF_WINDOW = _fraudProofWindow;\\n        SEQUENCER_PUBLISH_WINDOW = _sequencerPublishWindow;\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Accesses the batch storage container.\\n     * @return Reference to the batch storage container.\\n     */\\n    function batches() public view returns (IChainStorageContainer) {\\n        return IChainStorageContainer(resolve(\\\"ChainStorageContainer-SCC-batches\\\"));\\n    }\\n\\n    /**\\n     * @inheritdoc IStateCommitmentChain\\n     */\\n    function getTotalElements() public view returns (uint256 _totalElements) {\\n        (uint40 totalElements, ) = _getBatchExtraData();\\n        return uint256(totalElements);\\n    }\\n\\n    /**\\n     * @inheritdoc IStateCommitmentChain\\n     */\\n    function getTotalBatches() public view returns (uint256 _totalBatches) {\\n        return batches().length();\\n    }\\n\\n    /**\\n     * @inheritdoc IStateCommitmentChain\\n     */\\n    // slither-disable-next-line external-function\\n    function getLastSequencerTimestamp() public view returns (uint256 _lastSequencerTimestamp) {\\n        (, uint40 lastSequencerTimestamp) = _getBatchExtraData();\\n        return uint256(lastSequencerTimestamp);\\n    }\\n\\n    /**\\n     * @inheritdoc IStateCommitmentChain\\n     */\\n    // slither-disable-next-line external-function\\n    function appendStateBatch(bytes32[] memory _batch, uint256 _shouldStartAtElement) public {\\n        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\\n        // publication of batches by some other user.\\n        require(\\n            _shouldStartAtElement == getTotalElements(),\\n            \\\"Actual batch start index does not match expected start index.\\\"\\n        );\\n\\n        // Proposers must have previously staked at the BondManager\\n        require(\\n            IBondManager(resolve(\\\"BondManager\\\")).isCollateralized(msg.sender),\\n            \\\"Proposer does not have enough collateral posted\\\"\\n        );\\n\\n        require(_batch.length > 0, \\\"Cannot submit an empty state batch.\\\");\\n\\n        require(\\n            getTotalElements() + _batch.length <=\\n                ICanonicalTransactionChain(resolve(\\\"CanonicalTransactionChain\\\")).getTotalElements(),\\n            \\\"Number of state roots cannot exceed the number of canonical transactions.\\\"\\n        );\\n\\n        // Pass the block's timestamp and the publisher of the data\\n        // to be used in the fraud proofs\\n        _appendBatch(_batch, abi.encode(block.timestamp, msg.sender));\\n    }\\n\\n    /**\\n     * @inheritdoc IStateCommitmentChain\\n     */\\n    // slither-disable-next-line external-function\\n    function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) public {\\n        require(\\n            msg.sender == resolve(\\\"OVM_FraudVerifier\\\"),\\n            \\\"State batches can only be deleted by the OVM_FraudVerifier.\\\"\\n        );\\n\\n        require(_isValidBatchHeader(_batchHeader), \\\"Invalid batch header.\\\");\\n\\n        require(\\n            insideFraudProofWindow(_batchHeader),\\n            \\\"State batches can only be deleted within the fraud proof window.\\\"\\n        );\\n\\n        _deleteBatch(_batchHeader);\\n    }\\n\\n    /**\\n     * @inheritdoc IStateCommitmentChain\\n     */\\n    // slither-disable-next-line external-function\\n    function verifyStateCommitment(\\n        bytes32 _element,\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\\n        Lib_OVMCodec.ChainInclusionProof memory _proof\\n    ) public view returns (bool) {\\n        require(_isValidBatchHeader(_batchHeader), \\\"Invalid batch header.\\\");\\n\\n        require(\\n            Lib_MerkleTree.verify(\\n                _batchHeader.batchRoot,\\n                _element,\\n                _proof.index,\\n                _proof.siblings,\\n                _batchHeader.batchSize\\n            ),\\n            \\\"Invalid inclusion proof.\\\"\\n        );\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @inheritdoc IStateCommitmentChain\\n     */\\n    function insideFraudProofWindow(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\\n        public\\n        view\\n        returns (bool _inside)\\n    {\\n        (uint256 timestamp, ) = abi.decode(_batchHeader.extraData, (uint256, address));\\n\\n        require(timestamp != 0, \\\"Batch header timestamp cannot be zero\\\");\\n        return (timestamp + FRAUD_PROOF_WINDOW) > block.timestamp;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Parses the batch context from the extra data.\\n     * @return Total number of elements submitted.\\n     * @return Timestamp of the last batch submitted by the sequencer.\\n     */\\n    function _getBatchExtraData() internal view returns (uint40, uint40) {\\n        bytes27 extraData = batches().getGlobalMetadata();\\n\\n        // solhint-disable max-line-length\\n        uint40 totalElements;\\n        uint40 lastSequencerTimestamp;\\n        assembly {\\n            extraData := shr(40, extraData)\\n            totalElements := and(\\n                extraData,\\n                0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF\\n            )\\n            lastSequencerTimestamp := shr(\\n                40,\\n                and(extraData, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000)\\n            )\\n        }\\n        // solhint-enable max-line-length\\n\\n        return (totalElements, lastSequencerTimestamp);\\n    }\\n\\n    /**\\n     * Encodes the batch context for the extra data.\\n     * @param _totalElements Total number of elements submitted.\\n     * @param _lastSequencerTimestamp Timestamp of the last batch submitted by the sequencer.\\n     * @return Encoded batch context.\\n     */\\n    function _makeBatchExtraData(uint40 _totalElements, uint40 _lastSequencerTimestamp)\\n        internal\\n        pure\\n        returns (bytes27)\\n    {\\n        bytes27 extraData;\\n        assembly {\\n            extraData := _totalElements\\n            extraData := or(extraData, shl(40, _lastSequencerTimestamp))\\n            extraData := shl(40, extraData)\\n        }\\n\\n        return extraData;\\n    }\\n\\n    /**\\n     * Appends a batch to the chain.\\n     * @param _batch Elements within the batch.\\n     * @param _extraData Any extra data to append to the batch.\\n     */\\n    function _appendBatch(bytes32[] memory _batch, bytes memory _extraData) internal {\\n        address sequencer = resolve(\\\"OVM_Proposer\\\");\\n        (uint40 totalElements, uint40 lastSequencerTimestamp) = _getBatchExtraData();\\n\\n        if (msg.sender == sequencer) {\\n            lastSequencerTimestamp = uint40(block.timestamp);\\n        } else {\\n            // We keep track of the last batch submitted by the sequencer so there's a window in\\n            // which only the sequencer can publish state roots. A window like this just reduces\\n            // the chance of \\\"system breaking\\\" state roots being published while we're still in\\n            // testing mode. This window should be removed or significantly reduced in the future.\\n            require(\\n                lastSequencerTimestamp + SEQUENCER_PUBLISH_WINDOW < block.timestamp,\\n                \\\"Cannot publish state roots within the sequencer publication window.\\\"\\n            );\\n        }\\n\\n        // For efficiency reasons getMerkleRoot modifies the `_batch` argument in place\\n        // while calculating the root hash therefore any arguments passed to it must not\\n        // be used again afterwards\\n        Lib_OVMCodec.ChainBatchHeader memory batchHeader = Lib_OVMCodec.ChainBatchHeader({\\n            batchIndex: getTotalBatches(),\\n            batchRoot: Lib_MerkleTree.getMerkleRoot(_batch),\\n            batchSize: _batch.length,\\n            prevTotalElements: totalElements,\\n            extraData: _extraData\\n        });\\n\\n        emit StateBatchAppended(\\n            batchHeader.batchIndex,\\n            batchHeader.batchRoot,\\n            batchHeader.batchSize,\\n            batchHeader.prevTotalElements,\\n            batchHeader.extraData\\n        );\\n\\n        batches().push(\\n            Lib_OVMCodec.hashBatchHeader(batchHeader),\\n            _makeBatchExtraData(\\n                uint40(batchHeader.prevTotalElements + batchHeader.batchSize),\\n                lastSequencerTimestamp\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Removes a batch and all subsequent batches from the chain.\\n     * @param _batchHeader Header of the batch to remove.\\n     */\\n    function _deleteBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) internal {\\n        require(_batchHeader.batchIndex < batches().length(), \\\"Invalid batch index.\\\");\\n\\n        require(_isValidBatchHeader(_batchHeader), \\\"Invalid batch header.\\\");\\n\\n        // slither-disable-next-line reentrancy-events\\n        batches().deleteElementsAfterInclusive(\\n            _batchHeader.batchIndex,\\n            _makeBatchExtraData(uint40(_batchHeader.prevTotalElements), 0)\\n        );\\n\\n        // slither-disable-next-line reentrancy-events\\n        emit StateBatchDeleted(_batchHeader.batchIndex, _batchHeader.batchRoot);\\n    }\\n\\n    /**\\n     * Checks that a batch header matches the stored hash for the given index.\\n     * @param _batchHeader Batch header to validate.\\n     * @return Whether or not the header matches the stored one.\\n     */\\n    function _isValidBatchHeader(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return Lib_OVMCodec.hashBatchHeader(_batchHeader) == batches().get(_batchHeader.batchIndex);\\n    }\\n}\\n\"\n    },\n    \"contracts/L1/teleportr/TeleportrDeposit.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.9;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title TeleportrDeposit\\n *\\n * Shout out to 0xclem for providing the inspiration for this contract:\\n * https://github.com/0xclem/teleportr/blob/main/contracts/BridgeDeposit.sol\\n */\\ncontract TeleportrDeposit is Ownable {\\n    /// The minimum amount that be deposited in a receive.\\n    uint256 public minDepositAmount;\\n    /// The maximum amount that be deposited in a receive.\\n    uint256 public maxDepositAmount;\\n    /// The maximum balance the contract can hold after a receive.\\n    uint256 public maxBalance;\\n    /// The total number of successful deposits received.\\n    uint256 public totalDeposits;\\n\\n    /**\\n     * @notice Emitted any time the minimum deposit amount is set.\\n     * @param previousAmount The previous minimum deposit amount.\\n     * @param newAmount The new minimum deposit amount.\\n     */\\n    event MinDepositAmountSet(uint256 previousAmount, uint256 newAmount);\\n\\n    /**\\n     * @notice Emitted any time the maximum deposit amount is set.\\n     * @param previousAmount The previous maximum deposit amount.\\n     * @param newAmount The new maximum deposit amount.\\n     */\\n    event MaxDepositAmountSet(uint256 previousAmount, uint256 newAmount);\\n\\n    /**\\n     * @notice Emitted any time the contract maximum balance is set.\\n     * @param previousBalance The previous maximum contract balance.\\n     * @param newBalance The new maximum contract balance.\\n     */\\n    event MaxBalanceSet(uint256 previousBalance, uint256 newBalance);\\n\\n    /**\\n     * @notice Emitted any time the balance is withdrawn by the owner.\\n     * @param owner The current owner and recipient of the funds.\\n     * @param balance The current contract balance paid to the owner.\\n     */\\n    event BalanceWithdrawn(address indexed owner, uint256 balance);\\n\\n    /**\\n     * @notice Emitted any time a successful deposit is received.\\n     * @param depositId A unique sequencer number identifying the deposit.\\n     * @param emitter The sending address of the payer.\\n     * @param amount The amount deposited by the payer.\\n     */\\n    event EtherReceived(uint256 indexed depositId, address indexed emitter, uint256 indexed amount);\\n\\n    /**\\n     * @notice Initializes a new TeleportrDeposit contract.\\n     * @param _minDepositAmount The initial minimum deposit amount.\\n     * @param _maxDepositAmount The initial maximum deposit amount.\\n     * @param _maxBalance The initial maximum contract balance.\\n     */\\n    constructor(\\n        uint256 _minDepositAmount,\\n        uint256 _maxDepositAmount,\\n        uint256 _maxBalance\\n    ) {\\n        minDepositAmount = _minDepositAmount;\\n        maxDepositAmount = _maxDepositAmount;\\n        maxBalance = _maxBalance;\\n        totalDeposits = 0;\\n        emit MinDepositAmountSet(0, _minDepositAmount);\\n        emit MaxDepositAmountSet(0, _maxDepositAmount);\\n        emit MaxBalanceSet(0, _maxBalance);\\n    }\\n\\n    /**\\n     * @notice Accepts deposits that will be disbursed to the sender's address on L2.\\n     * The method reverts if the amount is less than the current\\n     * minDepositAmount, the amount is greater than the current\\n     * maxDepositAmount, or the amount causes the contract to exceed its maximum\\n     * allowed balance.\\n     */\\n    receive() external payable {\\n        require(msg.value >= minDepositAmount, \\\"Deposit amount is too small\\\");\\n        require(msg.value <= maxDepositAmount, \\\"Deposit amount is too big\\\");\\n        require(address(this).balance <= maxBalance, \\\"Contract max balance exceeded\\\");\\n\\n        emit EtherReceived(totalDeposits, msg.sender, msg.value);\\n        unchecked {\\n            totalDeposits += 1;\\n        }\\n    }\\n\\n    /**\\n     * @notice Sends the contract's current balance to the owner.\\n     */\\n    function withdrawBalance() external onlyOwner {\\n        address _owner = owner();\\n        uint256 _balance = address(this).balance;\\n        emit BalanceWithdrawn(_owner, _balance);\\n        payable(_owner).transfer(_balance);\\n    }\\n\\n    /**\\n     * @notice Sets the minimum amount that can be deposited in a receive.\\n     * @param _minDepositAmount The new minimum deposit amount.\\n     */\\n    function setMinAmount(uint256 _minDepositAmount) external onlyOwner {\\n        emit MinDepositAmountSet(minDepositAmount, _minDepositAmount);\\n        minDepositAmount = _minDepositAmount;\\n    }\\n\\n    /**\\n     * @notice Sets the maximum amount that can be deposited in a receive.\\n     * @param _maxDepositAmount The new maximum deposit amount.\\n     */\\n    function setMaxAmount(uint256 _maxDepositAmount) external onlyOwner {\\n        emit MaxDepositAmountSet(maxDepositAmount, _maxDepositAmount);\\n        maxDepositAmount = _maxDepositAmount;\\n    }\\n\\n    /**\\n     * @notice Sets the maximum balance the contract can hold after a receive.\\n     * @param _maxBalance The new maximum contract balance.\\n     */\\n    function setMaxBalance(uint256 _maxBalance) external onlyOwner {\\n        emit MaxBalanceSet(maxBalance, _maxBalance);\\n        maxBalance = _maxBalance;\\n    }\\n}\\n\"\n    },\n    \"contracts/L1/verification/BondManager.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Interface Imports */\\nimport { IBondManager } from \\\"./IBondManager.sol\\\";\\n\\n/* Contract Imports */\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\n\\n/**\\n * @title BondManager\\n * @dev This contract is, for now, a stub of the \\\"real\\\" BondManager that does nothing but\\n * allow the \\\"OVM_Proposer\\\" to submit state root batches.\\n *\\n */\\ncontract BondManager is IBondManager, Lib_AddressResolver {\\n    /**\\n     * @param _libAddressManager Address of the Address Manager.\\n     */\\n    constructor(address _libAddressManager) Lib_AddressResolver(_libAddressManager) {}\\n\\n    /**\\n     * Checks whether a given address is properly collateralized and can perform actions within\\n     * the system.\\n     * @param _who Address to check.\\n     * @return true if the address is properly collateralized, false otherwise.\\n     */\\n    // slither-disable-next-line external-function\\n    function isCollateralized(address _who) public view returns (bool) {\\n        // Only authenticate sequencer to submit state root batches.\\n        return _who == resolve(\\\"OVM_Proposer\\\");\\n    }\\n}\\n\"\n    },\n    \"contracts/L1/verification/IBondManager.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title IBondManager\\n */\\ninterface IBondManager {\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function isCollateralized(address _who) external view returns (bool);\\n}\\n\"\n    },\n    \"contracts/L2/messaging/IL2CrossDomainMessenger.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Interface Imports */\\nimport { ICrossDomainMessenger } from \\\"../../libraries/bridge/ICrossDomainMessenger.sol\\\";\\n\\n/**\\n * @title IL2CrossDomainMessenger\\n */\\ninterface IL2CrossDomainMessenger is ICrossDomainMessenger {\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Relays a cross domain message to a contract.\\n     * @param _target Target contract address.\\n     * @param _sender Message sender address.\\n     * @param _message Message to send to the target.\\n     * @param _messageNonce Nonce for the provided message.\\n     */\\n    function relayMessage(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _messageNonce\\n    ) external;\\n}\\n\"\n    },\n    \"contracts/L2/messaging/IL2ERC20Bridge.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title IL2ERC20Bridge\\n */\\ninterface IL2ERC20Bridge {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event WithdrawalInitiated(\\n        address indexed _l1Token,\\n        address indexed _l2Token,\\n        address indexed _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes _data\\n    );\\n\\n    event DepositFinalized(\\n        address indexed _l1Token,\\n        address indexed _l2Token,\\n        address indexed _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes _data\\n    );\\n\\n    event DepositFailed(\\n        address indexed _l1Token,\\n        address indexed _l2Token,\\n        address indexed _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes _data\\n    );\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * @dev get the address of the corresponding L1 bridge contract.\\n     * @return Address of the corresponding L1 bridge contract.\\n     */\\n    function l1TokenBridge() external returns (address);\\n\\n    /**\\n     * @dev initiate a withdraw of some tokens to the caller's account on L1\\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\\n     * @param _amount Amount of the token to withdraw.\\n     * param _l1Gas Unused, but included for potential forward compatibility considerations.\\n     * @param _data Optional data to forward to L1. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function withdraw(\\n        address _l2Token,\\n        uint256 _amount,\\n        uint32 _l1Gas,\\n        bytes calldata _data\\n    ) external;\\n\\n    /**\\n     * @dev initiate a withdraw of some token to a recipient's account on L1.\\n     * @param _l2Token Address of L2 token where withdrawal is initiated.\\n     * @param _to L1 adress to credit the withdrawal to.\\n     * @param _amount Amount of the token to withdraw.\\n     * param _l1Gas Unused, but included for potential forward compatibility considerations.\\n     * @param _data Optional data to forward to L1. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function withdrawTo(\\n        address _l2Token,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _l1Gas,\\n        bytes calldata _data\\n    ) external;\\n\\n    /*************************\\n     * Cross-chain Functions *\\n     *************************/\\n\\n    /**\\n     * @dev Complete a deposit from L1 to L2, and credits funds to the recipient's balance of this\\n     * L2 token. This call will fail if it did not originate from a corresponding deposit in\\n     * L1StandardTokenBridge.\\n     * @param _l1Token Address for the l1 token this is called with\\n     * @param _l2Token Address for the l2 token this is called with\\n     * @param _from Account to pull the deposit from on L2.\\n     * @param _to Address to receive the withdrawal at\\n     * @param _amount Amount of the token to withdraw\\n     * @param _data Data provider by the sender on L1. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function finalizeDeposit(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external;\\n}\\n\"\n    },\n    \"contracts/L2/messaging/L2CrossDomainMessenger.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { AddressAliasHelper } from \\\"../../standards/AddressAliasHelper.sol\\\";\\nimport { Lib_CrossDomainUtils } from \\\"../../libraries/bridge/Lib_CrossDomainUtils.sol\\\";\\nimport { Lib_DefaultValues } from \\\"../../libraries/constants/Lib_DefaultValues.sol\\\";\\nimport { Lib_PredeployAddresses } from \\\"../../libraries/constants/Lib_PredeployAddresses.sol\\\";\\n\\n/* Interface Imports */\\nimport { IL2CrossDomainMessenger } from \\\"./IL2CrossDomainMessenger.sol\\\";\\nimport { iOVM_L2ToL1MessagePasser } from \\\"../predeploys/iOVM_L2ToL1MessagePasser.sol\\\";\\n\\n/**\\n * @title L2CrossDomainMessenger\\n * @dev The L2 Cross Domain Messenger contract sends messages from L2 to L1, and is the entry point\\n * for L2 messages sent via the L1 Cross Domain Messenger.\\n *\\n */\\ncontract L2CrossDomainMessenger is IL2CrossDomainMessenger {\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    mapping(bytes32 => bool) public relayedMessages;\\n    mapping(bytes32 => bool) public successfulMessages;\\n    mapping(bytes32 => bool) public sentMessages;\\n    uint256 public messageNonce;\\n    address internal xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\\n    address public l1CrossDomainMessenger;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    constructor(address _l1CrossDomainMessenger) {\\n        l1CrossDomainMessenger = _l1CrossDomainMessenger;\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    // slither-disable-next-line external-function\\n    function xDomainMessageSender() public view returns (address) {\\n        require(\\n            xDomainMsgSender != Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER,\\n            \\\"xDomainMessageSender is not set\\\"\\n        );\\n        return xDomainMsgSender;\\n    }\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    // slither-disable-next-line external-function\\n    function sendMessage(\\n        address _target,\\n        bytes memory _message,\\n        uint32 _gasLimit\\n    ) public {\\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\\n            _target,\\n            msg.sender,\\n            _message,\\n            messageNonce\\n        );\\n\\n        sentMessages[keccak256(xDomainCalldata)] = true;\\n\\n        // Actually send the message.\\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events\\n        iOVM_L2ToL1MessagePasser(Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER).passMessageToL1(\\n            xDomainCalldata\\n        );\\n\\n        // Emit an event before we bump the nonce or the nonce will be off by one.\\n        // slither-disable-next-line reentrancy-events\\n        emit SentMessage(_target, msg.sender, _message, messageNonce, _gasLimit);\\n        // slither-disable-next-line reentrancy-no-eth\\n        messageNonce += 1;\\n    }\\n\\n    /**\\n     * Relays a cross domain message to a contract.\\n     * @inheritdoc IL2CrossDomainMessenger\\n     */\\n    // slither-disable-next-line external-function\\n    function relayMessage(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _messageNonce\\n    ) public {\\n        // Since it is impossible to deploy a contract to an address on L2 which matches\\n        // the alias of the L1CrossDomainMessenger, this check can only pass when it is called in\\n        // the first call from of a deposit transaction. Thus reentrancy is prevented here.\\n        require(\\n            AddressAliasHelper.undoL1ToL2Alias(msg.sender) == l1CrossDomainMessenger,\\n            \\\"Provided message could not be verified.\\\"\\n        );\\n\\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\\n            _target,\\n            _sender,\\n            _message,\\n            _messageNonce\\n        );\\n\\n        bytes32 xDomainCalldataHash = keccak256(xDomainCalldata);\\n\\n        require(\\n            successfulMessages[xDomainCalldataHash] == false,\\n            \\\"Provided message has already been received.\\\"\\n        );\\n\\n        // Prevent calls to OVM_L2ToL1MessagePasser, which would enable\\n        // an attacker to maliciously craft the _message to spoof\\n        // a call from any L2 account.\\n        if (_target == Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER) {\\n            // Write to the successfulMessages mapping and return immediately.\\n            successfulMessages[xDomainCalldataHash] = true;\\n            return;\\n        }\\n\\n        xDomainMsgSender = _sender;\\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events, reentrancy-benign\\n        (bool success, ) = _target.call(_message);\\n        // slither-disable-next-line reentrancy-benign\\n        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\\n\\n        // Mark the message as received if the call was successful. Ensures that a message can be\\n        // relayed multiple times in the case that the call reverted.\\n        if (success == true) {\\n            // slither-disable-next-line reentrancy-no-eth\\n            successfulMessages[xDomainCalldataHash] = true;\\n            // slither-disable-next-line reentrancy-events\\n            emit RelayedMessage(xDomainCalldataHash);\\n        } else {\\n            // slither-disable-next-line reentrancy-events\\n            emit FailedRelayedMessage(xDomainCalldataHash);\\n        }\\n\\n        // Store an identifier that can be used to prove that the given message was relayed by some\\n        // user. Gives us an easy way to pay relayers for their work.\\n        bytes32 relayId = keccak256(abi.encodePacked(xDomainCalldata, msg.sender, block.number));\\n\\n        // slither-disable-next-line reentrancy-benign\\n        relayedMessages[relayId] = true;\\n    }\\n}\\n\"\n    },\n    \"contracts/L2/messaging/L2StandardBridge.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Interface Imports */\\nimport { IL1StandardBridge } from \\\"../../L1/messaging/IL1StandardBridge.sol\\\";\\nimport { IL1ERC20Bridge } from \\\"../../L1/messaging/IL1ERC20Bridge.sol\\\";\\nimport { IL2ERC20Bridge } from \\\"./IL2ERC20Bridge.sol\\\";\\n\\n/* Library Imports */\\nimport { ERC165Checker } from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport { CrossDomainEnabled } from \\\"../../libraries/bridge/CrossDomainEnabled.sol\\\";\\nimport { Lib_PredeployAddresses } from \\\"../../libraries/constants/Lib_PredeployAddresses.sol\\\";\\n\\n/* Contract Imports */\\nimport { IL2StandardERC20 } from \\\"../../standards/IL2StandardERC20.sol\\\";\\n\\n/**\\n * @title L2StandardBridge\\n * @dev The L2 Standard bridge is a contract which works together with the L1 Standard bridge to\\n * enable ETH and ERC20 transitions between L1 and L2.\\n * This contract acts as a minter for new tokens when it hears about deposits into the L1 Standard\\n * bridge.\\n * This contract also acts as a burner of the tokens intended for withdrawal, informing the L1\\n * bridge to release L1 funds.\\n */\\ncontract L2StandardBridge is IL2ERC20Bridge, CrossDomainEnabled {\\n    /********************************\\n     * External Contract References *\\n     ********************************/\\n\\n    address public l1TokenBridge;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _l2CrossDomainMessenger Cross-domain messenger used by this contract.\\n     * @param _l1TokenBridge Address of the L1 bridge deployed to the main chain.\\n     */\\n    constructor(address _l2CrossDomainMessenger, address _l1TokenBridge)\\n        CrossDomainEnabled(_l2CrossDomainMessenger)\\n    {\\n        l1TokenBridge = _l1TokenBridge;\\n    }\\n\\n    /***************\\n     * Withdrawing *\\n     ***************/\\n\\n    /**\\n     * @inheritdoc IL2ERC20Bridge\\n     */\\n    function withdraw(\\n        address _l2Token,\\n        uint256 _amount,\\n        uint32 _l1Gas,\\n        bytes calldata _data\\n    ) external virtual {\\n        _initiateWithdrawal(_l2Token, msg.sender, msg.sender, _amount, _l1Gas, _data);\\n    }\\n\\n    /**\\n     * @inheritdoc IL2ERC20Bridge\\n     */\\n    function withdrawTo(\\n        address _l2Token,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _l1Gas,\\n        bytes calldata _data\\n    ) external virtual {\\n        _initiateWithdrawal(_l2Token, msg.sender, _to, _amount, _l1Gas, _data);\\n    }\\n\\n    /**\\n     * @dev Performs the logic for withdrawals by burning the token and informing\\n     *      the L1 token Gateway of the withdrawal.\\n     * @param _l2Token Address of L2 token where withdrawal is initiated.\\n     * @param _from Account to pull the withdrawal from on L2.\\n     * @param _to Account to give the withdrawal to on L1.\\n     * @param _amount Amount of the token to withdraw.\\n     * @param _l1Gas Unused, but included for potential forward compatibility considerations.\\n     * @param _data Optional data to forward to L1. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function _initiateWithdrawal(\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _l1Gas,\\n        bytes calldata _data\\n    ) internal {\\n        // When a withdrawal is initiated, we burn the withdrawer's funds to prevent subsequent L2\\n        // usage\\n        // slither-disable-next-line reentrancy-events\\n        IL2StandardERC20(_l2Token).burn(msg.sender, _amount);\\n\\n        // Construct calldata for l1TokenBridge.finalizeERC20Withdrawal(_to, _amount)\\n        // slither-disable-next-line reentrancy-events\\n        address l1Token = IL2StandardERC20(_l2Token).l1Token();\\n        bytes memory message;\\n\\n        if (_l2Token == Lib_PredeployAddresses.OVM_ETH) {\\n            message = abi.encodeWithSelector(\\n                IL1StandardBridge.finalizeETHWithdrawal.selector,\\n                _from,\\n                _to,\\n                _amount,\\n                _data\\n            );\\n        } else {\\n            message = abi.encodeWithSelector(\\n                IL1ERC20Bridge.finalizeERC20Withdrawal.selector,\\n                l1Token,\\n                _l2Token,\\n                _from,\\n                _to,\\n                _amount,\\n                _data\\n            );\\n        }\\n\\n        // Send message up to L1 bridge\\n        // slither-disable-next-line reentrancy-events\\n        sendCrossDomainMessage(l1TokenBridge, _l1Gas, message);\\n\\n        // slither-disable-next-line reentrancy-events\\n        emit WithdrawalInitiated(l1Token, _l2Token, msg.sender, _to, _amount, _data);\\n    }\\n\\n    /************************************\\n     * Cross-chain Function: Depositing *\\n     ************************************/\\n\\n    /**\\n     * @inheritdoc IL2ERC20Bridge\\n     */\\n    function finalizeDeposit(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external virtual onlyFromCrossDomainAccount(l1TokenBridge) {\\n        // Check the target token is compliant and\\n        // verify the deposited token on L1 matches the L2 deposited token representation here\\n        if (\\n            // slither-disable-next-line reentrancy-events\\n            ERC165Checker.supportsInterface(_l2Token, 0x1d1d8b63) &&\\n            _l1Token == IL2StandardERC20(_l2Token).l1Token()\\n        ) {\\n            // When a deposit is finalized, we credit the account on L2 with the same amount of\\n            // tokens.\\n            // slither-disable-next-line reentrancy-events\\n            IL2StandardERC20(_l2Token).mint(_to, _amount);\\n            // slither-disable-next-line reentrancy-events\\n            emit DepositFinalized(_l1Token, _l2Token, _from, _to, _amount, _data);\\n        } else {\\n            // Either the L2 token which is being deposited-into disagrees about the correct address\\n            // of its L1 token, or does not support the correct interface.\\n            // This should only happen if there is a  malicious L2 token, or if a user somehow\\n            // specified the wrong L2 token address to deposit into.\\n            // In either case, we stop the process here and construct a withdrawal\\n            // message so that users can get their funds out in some cases.\\n            // There is no way to prevent malicious token contracts altogether, but this does limit\\n            // user error and mitigate some forms of malicious contract behavior.\\n            bytes memory message = abi.encodeWithSelector(\\n                IL1ERC20Bridge.finalizeERC20Withdrawal.selector,\\n                _l1Token,\\n                _l2Token,\\n                _to, // switched the _to and _from here to bounce back the deposit to the sender\\n                _from,\\n                _amount,\\n                _data\\n            );\\n\\n            // Send message up to L1 bridge\\n            // slither-disable-next-line reentrancy-events\\n            sendCrossDomainMessage(l1TokenBridge, 0, message);\\n            // slither-disable-next-line reentrancy-events\\n            emit DepositFailed(_l1Token, _l2Token, _from, _to, _amount, _data);\\n        }\\n    }\\n}\\n\"\n    },\n    \"contracts/L2/messaging/L2StandardTokenFactory.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Contract Imports */\\nimport { L2StandardERC20 } from \\\"../../standards/L2StandardERC20.sol\\\";\\nimport { Lib_PredeployAddresses } from \\\"../../libraries/constants/Lib_PredeployAddresses.sol\\\";\\n\\n/**\\n * @title L2StandardTokenFactory\\n * @dev Factory contract for creating standard L2 token representations of L1 ERC20s\\n * compatible with and working on the standard bridge.\\n */\\ncontract L2StandardTokenFactory {\\n    event StandardL2TokenCreated(address indexed _l1Token, address indexed _l2Token);\\n\\n    /**\\n     * @dev Creates an instance of the standard ERC20 token on L2.\\n     * @param _l1Token Address of the corresponding L1 token.\\n     * @param _name ERC20 name.\\n     * @param _symbol ERC20 symbol.\\n     */\\n    function createStandardL2Token(\\n        address _l1Token,\\n        string memory _name,\\n        string memory _symbol\\n    ) external {\\n        require(_l1Token != address(0), \\\"Must provide L1 token address\\\");\\n\\n        L2StandardERC20 l2Token = new L2StandardERC20(\\n            Lib_PredeployAddresses.L2_STANDARD_BRIDGE,\\n            _l1Token,\\n            _name,\\n            _symbol\\n        );\\n\\n        emit StandardL2TokenCreated(_l1Token, address(l2Token));\\n    }\\n}\\n\"\n    },\n    \"contracts/L2/predeploys/iOVM_L1BlockNumber.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title iOVM_L1BlockNumber\\n */\\ninterface iOVM_L1BlockNumber {\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function getL1BlockNumber() external view returns (uint256);\\n}\\n\"\n    },\n    \"contracts/L2/predeploys/iOVM_L2ToL1MessagePasser.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title iOVM_L2ToL1MessagePasser\\n */\\ninterface iOVM_L2ToL1MessagePasser {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event L2ToL1Message(uint256 _nonce, address _sender, bytes _data);\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function passMessageToL1(bytes calldata _message) external;\\n}\\n\"\n    },\n    \"contracts/L2/predeploys/OVM_DeployerWhitelist.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title OVM_DeployerWhitelist\\n * @dev The Deployer Whitelist is a temporary predeploy used to provide additional safety during the\\n * initial phases of our mainnet roll out. It is owned by the Optimism team, and defines accounts\\n * which are allowed to deploy contracts on Layer2. The Execution Manager will only allow an\\n * ovmCREATE or ovmCREATE2 operation to proceed if the deployer's address whitelisted.\\n */\\ncontract OVM_DeployerWhitelist {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event OwnerChanged(address oldOwner, address newOwner);\\n    event WhitelistStatusChanged(address deployer, bool whitelisted);\\n    event WhitelistDisabled(address oldOwner);\\n\\n    /**********************\\n     * Contract Constants *\\n     **********************/\\n\\n    // WARNING: When owner is set to address(0), the whitelist is disabled.\\n    address public owner;\\n    mapping(address => bool) public whitelist;\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    /**\\n     * Blocks functions to anyone except the contract owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Function can only be called by the owner of this contract.\\\");\\n        _;\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Adds or removes an address from the deployment whitelist.\\n     * @param _deployer Address to update permissions for.\\n     * @param _isWhitelisted Whether or not the address is whitelisted.\\n     */\\n    function setWhitelistedDeployer(address _deployer, bool _isWhitelisted) external onlyOwner {\\n        whitelist[_deployer] = _isWhitelisted;\\n        emit WhitelistStatusChanged(_deployer, _isWhitelisted);\\n    }\\n\\n    /**\\n     * Updates the owner of this contract.\\n     * @param _owner Address of the new owner.\\n     */\\n    // slither-disable-next-line external-function\\n    function setOwner(address _owner) public onlyOwner {\\n        // Prevent users from setting the whitelist owner to address(0) except via\\n        // enableArbitraryContractDeployment. If you want to burn the whitelist owner, send it to\\n        // any other address that doesn't have a corresponding knowable private key.\\n        require(\\n            _owner != address(0),\\n            \\\"OVM_DeployerWhitelist: can only be disabled via enableArbitraryContractDeployment\\\"\\n        );\\n\\n        emit OwnerChanged(owner, _owner);\\n        owner = _owner;\\n    }\\n\\n    /**\\n     * Permanently enables arbitrary contract deployment and deletes the owner.\\n     */\\n    function enableArbitraryContractDeployment() external onlyOwner {\\n        emit WhitelistDisabled(owner);\\n        owner = address(0);\\n    }\\n\\n    /**\\n     * Checks whether an address is allowed to deploy contracts.\\n     * @param _deployer Address to check.\\n     * @return _allowed Whether or not the address can deploy contracts.\\n     */\\n    function isDeployerAllowed(address _deployer) external view returns (bool) {\\n        return (owner == address(0) || whitelist[_deployer]);\\n    }\\n}\\n\"\n    },\n    \"contracts/L2/predeploys/OVM_ETH.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_PredeployAddresses } from \\\"../../libraries/constants/Lib_PredeployAddresses.sol\\\";\\n\\n/* Contract Imports */\\nimport { L2StandardERC20 } from \\\"../../standards/L2StandardERC20.sol\\\";\\n\\n/**\\n * @title OVM_ETH\\n * @dev The ETH predeploy provides an ERC20 interface for ETH deposited to Layer 2. Note that\\n * unlike on Layer 1, Layer 2 accounts do not have a balance field.\\n */\\ncontract OVM_ETH is L2StandardERC20 {\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    constructor()\\n        L2StandardERC20(Lib_PredeployAddresses.L2_STANDARD_BRIDGE, address(0), \\\"Ether\\\", \\\"ETH\\\")\\n    {}\\n\\n    // ETH ERC20 features are disabled until further notice.\\n    // Discussion here: https://github.com/ethereum-optimism/optimism/discussions/1444\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        revert(\\\"OVM_ETH: transfer is disabled pending further community discussion.\\\");\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        revert(\\\"OVM_ETH: approve is disabled pending further community discussion.\\\");\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        revert(\\\"OVM_ETH: transferFrom is disabled pending further community discussion.\\\");\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        revert(\\\"OVM_ETH: increaseAllowance is disabled pending further community discussion.\\\");\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        revert(\\\"OVM_ETH: decreaseAllowance is disabled pending further community discussion.\\\");\\n    }\\n}\\n\"\n    },\n    \"contracts/L2/predeploys/OVM_GasPriceOracle.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* External Imports */\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title OVM_GasPriceOracle\\n * @dev This contract exposes the current l2 gas price, a measure of how congested the network\\n * currently is. This measure is used by the Sequencer to determine what fee to charge for\\n * transactions. When the system is more congested, the l2 gas price will increase and fees\\n * will also increase as a result.\\n *\\n * All public variables are set while generating the initial L2 state. The\\n * constructor doesn't run in practice as the L2 state generation script uses\\n * the deployed bytecode instead of running the initcode.\\n */\\ncontract OVM_GasPriceOracle is Ownable {\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    // Current L2 gas price\\n    uint256 public gasPrice;\\n    // Current L1 base fee\\n    uint256 public l1BaseFee;\\n    // Amortized cost of batch submission per transaction\\n    uint256 public overhead;\\n    // Value to scale the fee up by\\n    uint256 public scalar;\\n    // Number of decimals of the scalar\\n    uint256 public decimals;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _owner Address that will initially own this contract.\\n     */\\n    constructor(address _owner) Ownable() {\\n        transferOwnership(_owner);\\n    }\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event GasPriceUpdated(uint256);\\n    event L1BaseFeeUpdated(uint256);\\n    event OverheadUpdated(uint256);\\n    event ScalarUpdated(uint256);\\n    event DecimalsUpdated(uint256);\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Allows the owner to modify the l2 gas price.\\n     * @param _gasPrice New l2 gas price.\\n     */\\n    // slither-disable-next-line external-function\\n    function setGasPrice(uint256 _gasPrice) public onlyOwner {\\n        gasPrice = _gasPrice;\\n        emit GasPriceUpdated(_gasPrice);\\n    }\\n\\n    /**\\n     * Allows the owner to modify the l1 base fee.\\n     * @param _baseFee New l1 base fee\\n     */\\n    // slither-disable-next-line external-function\\n    function setL1BaseFee(uint256 _baseFee) public onlyOwner {\\n        l1BaseFee = _baseFee;\\n        emit L1BaseFeeUpdated(_baseFee);\\n    }\\n\\n    /**\\n     * Allows the owner to modify the overhead.\\n     * @param _overhead New overhead\\n     */\\n    // slither-disable-next-line external-function\\n    function setOverhead(uint256 _overhead) public onlyOwner {\\n        overhead = _overhead;\\n        emit OverheadUpdated(_overhead);\\n    }\\n\\n    /**\\n     * Allows the owner to modify the scalar.\\n     * @param _scalar New scalar\\n     */\\n    // slither-disable-next-line external-function\\n    function setScalar(uint256 _scalar) public onlyOwner {\\n        scalar = _scalar;\\n        emit ScalarUpdated(_scalar);\\n    }\\n\\n    /**\\n     * Allows the owner to modify the decimals.\\n     * @param _decimals New decimals\\n     */\\n    // slither-disable-next-line external-function\\n    function setDecimals(uint256 _decimals) public onlyOwner {\\n        decimals = _decimals;\\n        emit DecimalsUpdated(_decimals);\\n    }\\n\\n    /**\\n     * Computes the L1 portion of the fee\\n     * based on the size of the RLP encoded tx\\n     * and the current l1BaseFee\\n     * @param _data Unsigned RLP encoded tx, 6 elements\\n     * @return L1 fee that should be paid for the tx\\n     */\\n    // slither-disable-next-line external-function\\n    function getL1Fee(bytes memory _data) public view returns (uint256) {\\n        uint256 l1GasUsed = getL1GasUsed(_data);\\n        uint256 l1Fee = l1GasUsed * l1BaseFee;\\n        uint256 divisor = 10**decimals;\\n        uint256 unscaled = l1Fee * scalar;\\n        uint256 scaled = unscaled / divisor;\\n        return scaled;\\n    }\\n\\n    // solhint-disable max-line-length\\n    /**\\n     * Computes the amount of L1 gas used for a transaction\\n     * The overhead represents the per batch gas overhead of\\n     * posting both transaction and state roots to L1 given larger\\n     * batch sizes.\\n     * 4 gas for 0 byte\\n     * https://github.com/ethereum/go-ethereum/blob/9ada4a2e2c415e6b0b51c50e901336872e028872/params/protocol_params.go#L33\\n     * 16 gas for non zero byte\\n     * https://github.com/ethereum/go-ethereum/blob/9ada4a2e2c415e6b0b51c50e901336872e028872/params/protocol_params.go#L87\\n     * This will need to be updated if calldata gas prices change\\n     * Account for the transaction being unsigned\\n     * Padding is added to account for lack of signature on transaction\\n     * 1 byte for RLP V prefix\\n     * 1 byte for V\\n     * 1 byte for RLP R prefix\\n     * 32 bytes for R\\n     * 1 byte for RLP S prefix\\n     * 32 bytes for S\\n     * Total: 68 bytes of padding\\n     * @param _data Unsigned RLP encoded tx, 6 elements\\n     * @return Amount of L1 gas used for a transaction\\n     */\\n    // solhint-enable max-line-length\\n    function getL1GasUsed(bytes memory _data) public view returns (uint256) {\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < _data.length; i++) {\\n            if (_data[i] == 0) {\\n                total += 4;\\n            } else {\\n                total += 16;\\n            }\\n        }\\n        uint256 unsigned = total + overhead;\\n        return unsigned + (68 * 16);\\n    }\\n}\\n\"\n    },\n    \"contracts/L2/predeploys/OVM_L2ToL1MessagePasser.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Interface Imports */\\nimport { iOVM_L2ToL1MessagePasser } from \\\"./iOVM_L2ToL1MessagePasser.sol\\\";\\n\\n/**\\n * @title OVM_L2ToL1MessagePasser\\n * @dev The L2 to L1 Message Passer is a utility contract which facilitate an L1 proof of the\\n * of a message on L2. The L1 Cross Domain Messenger performs this proof in its\\n * _verifyStorageProof function, which verifies the existence of the transaction hash in this\\n * contract's `sentMessages` mapping.\\n */\\ncontract OVM_L2ToL1MessagePasser is iOVM_L2ToL1MessagePasser {\\n    /**********************\\n     * Contract Variables *\\n     **********************/\\n\\n    mapping(bytes32 => bool) public sentMessages;\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Passes a message to L1.\\n     * @param _message Message to pass to L1.\\n     */\\n    // slither-disable-next-line external-function\\n    function passMessageToL1(bytes memory _message) public {\\n        // Note: although this function is public, only messages sent from the\\n        // L2CrossDomainMessenger will be relayed by the L1CrossDomainMessenger.\\n        // This is enforced by a check in L1CrossDomainMessenger._verifyStorageProof().\\n        sentMessages[keccak256(abi.encodePacked(_message, msg.sender))] = true;\\n    }\\n}\\n\"\n    },\n    \"contracts/L2/predeploys/OVM_SequencerFeeVault.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_PredeployAddresses } from \\\"../../libraries/constants/Lib_PredeployAddresses.sol\\\";\\n\\n/* Contract Imports */\\nimport { L2StandardBridge } from \\\"../messaging/L2StandardBridge.sol\\\";\\n\\n/**\\n * @title OVM_SequencerFeeVault\\n * @dev Simple holding contract for fees paid to the Sequencer. Likely to be replaced in the future\\n * but \\\"good enough for now\\\".\\n */\\ncontract OVM_SequencerFeeVault {\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    // Minimum ETH balance that can be withdrawn in a single withdrawal.\\n    uint256 public constant MIN_WITHDRAWAL_AMOUNT = 15 ether;\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    // Address on L1 that will hold the fees once withdrawn. Dynamically initialized within l2geth.\\n    address public l1FeeWallet;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _l1FeeWallet Initial address for the L1 wallet that will hold fees once withdrawn.\\n     * Currently HAS NO EFFECT in production because l2geth will mutate this storage slot during\\n     * the genesis block. This is ONLY for testing purposes.\\n     */\\n    constructor(address _l1FeeWallet) {\\n        l1FeeWallet = _l1FeeWallet;\\n    }\\n\\n    /************\\n     * Fallback *\\n     ************/\\n\\n    // slither-disable-next-line locked-ether\\n    receive() external payable {}\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    // slither-disable-next-line external-function\\n    function withdraw() public {\\n        require(\\n            address(this).balance >= MIN_WITHDRAWAL_AMOUNT,\\n            // solhint-disable-next-line max-line-length\\n            \\\"OVM_SequencerFeeVault: withdrawal amount must be greater than minimum withdrawal amount\\\"\\n        );\\n\\n        L2StandardBridge(Lib_PredeployAddresses.L2_STANDARD_BRIDGE).withdrawTo(\\n            Lib_PredeployAddresses.OVM_ETH,\\n            l1FeeWallet,\\n            address(this).balance,\\n            0,\\n            bytes(\\\"\\\")\\n        );\\n    }\\n}\\n\"\n    },\n    \"contracts/L2/teleportr/TeleportrDisburser.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.9;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title TeleportrDisburser\\n */\\ncontract TeleportrDisburser is Ownable {\\n    /**\\n     * @notice A struct holding the address and amount to disbursement.\\n     */\\n    struct Disbursement {\\n        uint256 amount;\\n        address addr;\\n    }\\n\\n    /// The total number of disbursements processed.\\n    uint256 public totalDisbursements;\\n\\n    /**\\n     * @notice Emitted any time the balance is withdrawn by the owner.\\n     * @param owner The current owner and recipient of the funds.\\n     * @param balance The current contract balance paid to the owner.\\n     */\\n    event BalanceWithdrawn(address indexed owner, uint256 balance);\\n\\n    /**\\n     * @notice Emitted any time a disbursement is successfuly sent.\\n     * @param depositId The unique sequence number identifying the deposit.\\n     * @param to The recipient of the disbursement.\\n     * @param amount The amount sent to the recipient.\\n     */\\n    event DisbursementSuccess(uint256 indexed depositId, address indexed to, uint256 amount);\\n\\n    /**\\n     * @notice Emitted any time a disbursement fails to send.\\n     * @param depositId The unique sequence number identifying the deposit.\\n     * @param to The intended recipient of the disbursement.\\n     * @param amount The amount intended to be sent to the recipient.\\n     */\\n    event DisbursementFailed(uint256 indexed depositId, address indexed to, uint256 amount);\\n\\n    /**\\n     * @notice Initializes a new TeleportrDisburser contract.\\n     */\\n    constructor() {\\n        totalDisbursements = 0;\\n    }\\n\\n    /**\\n     * @notice Accepts a list of Disbursements and forwards the amount paid to\\n     * the contract to each recipient. The method reverts if there are zero\\n     * disbursements, the total amount to forward differs from the amount sent\\n     * in the transaction, or the _nextDepositId is unexpected. Failed\\n     * disbursements will not cause the method to revert, but will instead be\\n     * held by the contract and availabe for the owner to withdraw.\\n     * @param _nextDepositId The depositId of the first Dispursement.\\n     * @param _disbursements A list of Disbursements to process.\\n     */\\n    function disburse(uint256 _nextDepositId, Disbursement[] calldata _disbursements)\\n        external\\n        payable\\n        onlyOwner\\n    {\\n        // Ensure there are disbursements to process.\\n        uint256 _numDisbursements = _disbursements.length;\\n        require(_numDisbursements > 0, \\\"No disbursements\\\");\\n\\n        // Ensure the _nextDepositId matches our expected value.\\n        uint256 _depositId = totalDisbursements;\\n        require(_depositId == _nextDepositId, \\\"Unexpected next deposit id\\\");\\n        unchecked {\\n            totalDisbursements += _numDisbursements;\\n        }\\n\\n        // Ensure the amount sent in the transaction is equal to the sum of the\\n        // disbursements.\\n        uint256 _totalDisbursed = 0;\\n        for (uint256 i = 0; i < _numDisbursements; i++) {\\n            _totalDisbursed += _disbursements[i].amount;\\n        }\\n        require(_totalDisbursed == msg.value, \\\"Disbursement total != amount sent\\\");\\n\\n        // Process disbursements.\\n        for (uint256 i = 0; i < _numDisbursements; i++) {\\n            uint256 _amount = _disbursements[i].amount;\\n            address _addr = _disbursements[i].addr;\\n\\n            // Deliver the dispursement amount to the receiver. If the\\n            // disbursement fails, the amount will be kept by the contract\\n            // rather than reverting to prevent blocking progress on other\\n            // disbursements.\\n\\n            // slither-disable-next-line calls-loop,reentrancy-events\\n            (bool success, ) = _addr.call{ value: _amount, gas: 2300 }(\\\"\\\");\\n            if (success) emit DisbursementSuccess(_depositId, _addr, _amount);\\n            else emit DisbursementFailed(_depositId, _addr, _amount);\\n\\n            unchecked {\\n                _depositId += 1;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Sends the contract's current balance to the owner.\\n     */\\n    function withdrawBalance() external onlyOwner {\\n        address _owner = owner();\\n        uint256 balance = address(this).balance;\\n        emit BalanceWithdrawn(_owner, balance);\\n        payable(_owner).transfer(balance);\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/bridge/CrossDomainEnabled.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/* Interface Imports */\\nimport { ICrossDomainMessenger } from \\\"./ICrossDomainMessenger.sol\\\";\\n\\n/**\\n * @title CrossDomainEnabled\\n * @dev Helper contract for contracts performing cross-domain communications\\n *\\n * Compiler used: defined by inheriting contract\\n */\\ncontract CrossDomainEnabled {\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    // Messenger contract used to send and recieve messages from the other domain.\\n    address public messenger;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _messenger Address of the CrossDomainMessenger on the current layer.\\n     */\\n    constructor(address _messenger) {\\n        messenger = _messenger;\\n    }\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    /**\\n     * Enforces that the modified function is only callable by a specific cross-domain account.\\n     * @param _sourceDomainAccount The only account on the originating domain which is\\n     *  authenticated to call this function.\\n     */\\n    modifier onlyFromCrossDomainAccount(address _sourceDomainAccount) {\\n        require(\\n            msg.sender == address(getCrossDomainMessenger()),\\n            \\\"OVM_XCHAIN: messenger contract unauthenticated\\\"\\n        );\\n\\n        require(\\n            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,\\n            \\\"OVM_XCHAIN: wrong sender of cross-domain message\\\"\\n        );\\n\\n        _;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Gets the messenger, usually from storage. This function is exposed in case a child contract\\n     * needs to override.\\n     * @return The address of the cross-domain messenger contract which should be used.\\n     */\\n    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {\\n        return ICrossDomainMessenger(messenger);\\n    }\\n\\n    /**q\\n     * Sends a message to an account on another domain\\n     * @param _crossDomainTarget The intended recipient on the destination domain\\n     * @param _message The data to send to the target (usually calldata to a function with\\n     *  `onlyFromCrossDomainAccount()`)\\n     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.\\n     */\\n    function sendCrossDomainMessage(\\n        address _crossDomainTarget,\\n        uint32 _gasLimit,\\n        bytes memory _message\\n    ) internal {\\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\\n        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/bridge/ICrossDomainMessenger.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title ICrossDomainMessenger\\n */\\ninterface ICrossDomainMessenger {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event SentMessage(\\n        address indexed target,\\n        address sender,\\n        bytes message,\\n        uint256 messageNonce,\\n        uint256 gasLimit\\n    );\\n    event RelayedMessage(bytes32 indexed msgHash);\\n    event FailedRelayedMessage(bytes32 indexed msgHash);\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    function xDomainMessageSender() external view returns (address);\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    function sendMessage(\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _gasLimit\\n    ) external;\\n}\\n\"\n    },\n    \"contracts/libraries/bridge/Lib_CrossDomainUtils.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_CrossDomainUtils\\n */\\nlibrary Lib_CrossDomainUtils {\\n    /**\\n     * Generates the correct cross domain calldata for a message.\\n     * @param _target Target contract address.\\n     * @param _sender Message sender address.\\n     * @param _message Message to send to the target.\\n     * @param _messageNonce Nonce for the provided message.\\n     * @return ABI encoded cross domain calldata.\\n     */\\n    function encodeXDomainCalldata(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _messageNonce\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodeWithSignature(\\n                \\\"relayMessage(address,address,bytes,uint256)\\\",\\n                _target,\\n                _sender,\\n                _message,\\n                _messageNonce\\n            );\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/codec/Lib_OVMCodec.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_RLPReader } from \\\"../rlp/Lib_RLPReader.sol\\\";\\nimport { Lib_RLPWriter } from \\\"../rlp/Lib_RLPWriter.sol\\\";\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\nimport { Lib_Bytes32Utils } from \\\"../utils/Lib_Bytes32Utils.sol\\\";\\n\\n/**\\n * @title Lib_OVMCodec\\n */\\nlibrary Lib_OVMCodec {\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum QueueOrigin {\\n        SEQUENCER_QUEUE,\\n        L1TOL2_QUEUE\\n    }\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct EVMAccount {\\n        uint256 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n    }\\n\\n    struct ChainBatchHeader {\\n        uint256 batchIndex;\\n        bytes32 batchRoot;\\n        uint256 batchSize;\\n        uint256 prevTotalElements;\\n        bytes extraData;\\n    }\\n\\n    struct ChainInclusionProof {\\n        uint256 index;\\n        bytes32[] siblings;\\n    }\\n\\n    struct Transaction {\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n        QueueOrigin l1QueueOrigin;\\n        address l1TxOrigin;\\n        address entrypoint;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n\\n    struct TransactionChainElement {\\n        bool isSequenced;\\n        uint256 queueIndex; // QUEUED TX ONLY\\n        uint256 timestamp; // SEQUENCER TX ONLY\\n        uint256 blockNumber; // SEQUENCER TX ONLY\\n        bytes txData; // SEQUENCER TX ONLY\\n    }\\n\\n    struct QueueElement {\\n        bytes32 transactionHash;\\n        uint40 timestamp;\\n        uint40 blockNumber;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Encodes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return Encoded transaction bytes.\\n     */\\n    function encodeTransaction(Transaction memory _transaction)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encodePacked(\\n                _transaction.timestamp,\\n                _transaction.blockNumber,\\n                _transaction.l1QueueOrigin,\\n                _transaction.l1TxOrigin,\\n                _transaction.entrypoint,\\n                _transaction.gasLimit,\\n                _transaction.data\\n            );\\n    }\\n\\n    /**\\n     * Hashes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return Hashed transaction\\n     */\\n    function hashTransaction(Transaction memory _transaction) internal pure returns (bytes32) {\\n        return keccak256(encodeTransaction(_transaction));\\n    }\\n\\n    /**\\n     * @notice Decodes an RLP-encoded account state into a useful struct.\\n     * @param _encoded RLP-encoded account state.\\n     * @return Account state struct.\\n     */\\n    function decodeEVMAccount(bytes memory _encoded) internal pure returns (EVMAccount memory) {\\n        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\\n\\n        return\\n            EVMAccount({\\n                nonce: Lib_RLPReader.readUint256(accountState[0]),\\n                balance: Lib_RLPReader.readUint256(accountState[1]),\\n                storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\\n                codeHash: Lib_RLPReader.readBytes32(accountState[3])\\n            });\\n    }\\n\\n    /**\\n     * Calculates a hash for a given batch header.\\n     * @param _batchHeader Header to hash.\\n     * @return Hash of the header.\\n     */\\n    function hashBatchHeader(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    _batchHeader.batchRoot,\\n                    _batchHeader.batchSize,\\n                    _batchHeader.prevTotalElements,\\n                    _batchHeader.extraData\\n                )\\n            );\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/constants/Lib_DefaultValues.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_DefaultValues\\n */\\nlibrary Lib_DefaultValues {\\n    // The default x-domain message sender being set to a non-zero value makes\\n    // deployment a bit more expensive, but in exchange the refund on every call to\\n    // `relayMessage` by the L1 and L2 messengers will be higher.\\n    address internal constant DEFAULT_XDOMAIN_SENDER = 0x000000000000000000000000000000000000dEaD;\\n}\\n\"\n    },\n    \"contracts/libraries/constants/Lib_PredeployAddresses.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_PredeployAddresses\\n */\\nlibrary Lib_PredeployAddresses {\\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\\n    address payable internal constant OVM_ETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);\\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\\n        0x4200000000000000000000000000000000000007;\\n    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\\n    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\\n    address internal constant L2_STANDARD_TOKEN_FACTORY =\\n        0x4200000000000000000000000000000000000012;\\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\\n}\\n\"\n    },\n    \"contracts/libraries/resolver/Lib_AddressManager.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* External Imports */\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(string indexed _name, address _newAddress, address _oldAddress);\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    mapping(bytes32 => address) private addresses;\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Changes the address associated with a particular name.\\n     * @param _name String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(_name, _address, oldAddress);\\n    }\\n\\n    /**\\n     * Retrieves the address associated with a given name.\\n     * @param _name Name to retrieve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(string memory _name) external view returns (address) {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Computes the hash of a name.\\n     * @param _name Name to compute a hash for.\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/resolver/Lib_AddressResolver.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_AddressManager } from \\\"./Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title Lib_AddressResolver\\n */\\nabstract contract Lib_AddressResolver {\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    Lib_AddressManager public libAddressManager;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Lib_AddressManager.\\n     */\\n    constructor(address _libAddressManager) {\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Resolves the address associated with a given name.\\n     * @param _name Name to resolve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function resolve(string memory _name) public view returns (address) {\\n        return libAddressManager.getAddress(_name);\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/resolver/Lib_ResolvedDelegateProxy.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_AddressManager } from \\\"./Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title Lib_ResolvedDelegateProxy\\n */\\ncontract Lib_ResolvedDelegateProxy {\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    // Using mappings to store fields to avoid overwriting storage slots in the\\n    // implementation contract. For example, instead of storing these fields at\\n    // storage slot `0` & `1`, they are stored at `keccak256(key + slot)`.\\n    // See: https://solidity.readthedocs.io/en/v0.7.0/internals/layout_in_storage.html\\n    // NOTE: Do not use this code in your own contract system.\\n    //      There is a known flaw in this contract, and we will remove it from the repository\\n    //      in the near future. Due to the very limited way that we are using it, this flaw is\\n    //      not an issue in our system.\\n    mapping(address => string) private implementationName;\\n    mapping(address => Lib_AddressManager) private addressManager;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Lib_AddressManager.\\n     * @param _implementationName implementationName of the contract to proxy to.\\n     */\\n    constructor(address _libAddressManager, string memory _implementationName) {\\n        addressManager[address(this)] = Lib_AddressManager(_libAddressManager);\\n        implementationName[address(this)] = _implementationName;\\n    }\\n\\n    /*********************\\n     * Fallback Function *\\n     *********************/\\n\\n    fallback() external payable {\\n        address target = addressManager[address(this)].getAddress(\\n            (implementationName[address(this)])\\n        );\\n\\n        require(target != address(0), \\\"Target address must be initialized.\\\");\\n\\n        // slither-disable-next-line controlled-delegatecall\\n        (bool success, bytes memory returndata) = target.delegatecall(msg.data);\\n\\n        if (success == true) {\\n            assembly {\\n                return(add(returndata, 0x20), mload(returndata))\\n            }\\n        } else {\\n            assembly {\\n                revert(add(returndata, 0x20), mload(returndata))\\n            }\\n        }\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/rlp/Lib_RLPReader.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_RLPReader\\n * @dev Adapted from \\\"RLPReader\\\" by Hamdi Allam (hamdi.allam97@gmail.com).\\n */\\nlibrary Lib_RLPReader {\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    uint256 internal constant MAX_LIST_LENGTH = 32;\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct RLPItem {\\n        uint256 length;\\n        uint256 ptr;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts bytes to a reference to memory position and length.\\n     * @param _in Input bytes to convert.\\n     * @return Output memory reference.\\n     */\\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        return RLPItem({ length: _in.length, ptr: ptr });\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\\n        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.LIST_ITEM, \\\"Invalid RLP list value.\\\");\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            require(itemCount < MAX_LIST_LENGTH, \\\"Provided RLP list exceeds max list length.\\\");\\n\\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\\n                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })\\n            );\\n\\n            out[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out, itemCount)\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\\n        return readList(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.DATA_ITEM, \\\"Invalid RLP bytes value.\\\");\\n\\n        return _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        return readBytes(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(RLPItem memory _in) internal pure returns (string memory) {\\n        return string(readBytes(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(bytes memory _in) internal pure returns (string memory) {\\n        return readString(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\\n        require(_in.length <= 33, \\\"Invalid RLP bytes32 value.\\\");\\n\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.DATA_ITEM, \\\"Invalid RLP bytes32 value.\\\");\\n\\n        uint256 ptr = _in.ptr + itemOffset;\\n        bytes32 out;\\n        assembly {\\n            out := mload(ptr)\\n\\n            // Shift the bytes over to match the item size.\\n            if lt(itemLength, 32) {\\n                out := div(out, exp(256, sub(32, itemLength)))\\n            }\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(bytes memory _in) internal pure returns (bytes32) {\\n        return readBytes32(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(RLPItem memory _in) internal pure returns (uint256) {\\n        return uint256(readBytes32(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(bytes memory _in) internal pure returns (uint256) {\\n        return readUint256(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(RLPItem memory _in) internal pure returns (bool) {\\n        require(_in.length == 1, \\\"Invalid RLP boolean value.\\\");\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 out;\\n        assembly {\\n            out := byte(0, mload(ptr))\\n        }\\n\\n        require(out == 0 || out == 1, \\\"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\\\");\\n\\n        return out != 0;\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(bytes memory _in) internal pure returns (bool) {\\n        return readBool(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(RLPItem memory _in) internal pure returns (address) {\\n        if (_in.length == 1) {\\n            return address(0);\\n        }\\n\\n        require(_in.length == 21, \\\"Invalid RLP address value.\\\");\\n\\n        return address(uint160(readUint256(_in)));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(bytes memory _in) internal pure returns (address) {\\n        return readAddress(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads the raw bytes of an RLP item.\\n     * @param _in RLP item to read.\\n     * @return Raw RLP bytes.\\n     */\\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\\n        return _copy(_in);\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Decodes the length of an RLP item.\\n     * @param _in RLP item to decode.\\n     * @return Offset of the encoded data.\\n     * @return Length of the encoded data.\\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\\n     */\\n    function _decodeLength(RLPItem memory _in)\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            RLPItemType\\n        )\\n    {\\n        require(_in.length > 0, \\\"RLP item cannot be null.\\\");\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            // slither-disable-next-line variable-scope\\n            uint256 strLen = prefix - 0x80;\\n\\n            require(_in.length > strLen, \\\"Invalid RLP short string.\\\");\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(_in.length > lenOfStrLen, \\\"Invalid RLP long string length.\\\");\\n\\n            uint256 strLen;\\n            assembly {\\n                // Pick out the string length.\\n                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\\n            }\\n\\n            require(_in.length > lenOfStrLen + strLen, \\\"Invalid RLP long string.\\\");\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            // slither-disable-next-line variable-scope\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(_in.length > listLen, \\\"Invalid RLP short list.\\\");\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(_in.length > lenOfListLen, \\\"Invalid RLP long list length.\\\");\\n\\n            uint256 listLen;\\n            assembly {\\n                // Pick out the list length.\\n                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\\n            }\\n\\n            require(_in.length > lenOfListLen + listLen, \\\"Invalid RLP long list.\\\");\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /**\\n     * Copies the bytes from a memory location.\\n     * @param _src Pointer to the location to read from.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        uint256 _src,\\n        uint256 _offset,\\n        uint256 _length\\n    ) private pure returns (bytes memory) {\\n        bytes memory out = new bytes(_length);\\n        if (out.length == 0) {\\n            return out;\\n        }\\n\\n        uint256 src = _src + _offset;\\n        uint256 dest;\\n        assembly {\\n            dest := add(out, 32)\\n        }\\n\\n        // Copy over as many complete words as we can.\\n        for (uint256 i = 0; i < _length / 32; i++) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += 32;\\n            dest += 32;\\n        }\\n\\n        // Pick out the remaining bytes.\\n        uint256 mask;\\n        unchecked {\\n            mask = 256**(32 - (_length % 32)) - 1;\\n        }\\n\\n        assembly {\\n            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\\n        }\\n        return out;\\n    }\\n\\n    /**\\n     * Copies an RLP item into bytes.\\n     * @param _in RLP item to copy.\\n     * @return Copied bytes.\\n     */\\n    function _copy(RLPItem memory _in) private pure returns (bytes memory) {\\n        return _copy(_in.ptr, 0, _in.length);\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/rlp/Lib_RLPWriter.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_RLPWriter\\n * @author Bakaoh (with modifications)\\n */\\nlibrary Lib_RLPWriter {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * RLP encodes a byte string.\\n     * @param _in The byte string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * RLP encodes a list of RLP encoded byte byte strings.\\n     * @param _in The list of RLP encoded byte strings.\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * RLP encodes a string.\\n     * @param _in The string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeString(string memory _in) internal pure returns (bytes memory) {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * RLP encodes an address.\\n     * @param _in The address to encode.\\n     * @return The RLP encoded address in bytes.\\n     */\\n    function writeAddress(address _in) internal pure returns (bytes memory) {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a uint.\\n     * @param _in The uint256 to encode.\\n     * @return The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a bool.\\n     * @param _in The bool to encode.\\n     * @return The RLP encoded bool in bytes.\\n     */\\n    function writeBool(bool _in) internal pure returns (bytes memory) {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\\n     * @param _len The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     * @return RLP encoded bytes.\\n     */\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * Encode integer in big endian binary form with no leading zeroes.\\n     * @notice TODO: This should be optimized with assembly to save gas costs.\\n     * @param _x The integer to encode.\\n     * @return RLP encoded bytes.\\n     */\\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * Copies a piece of memory to another location.\\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\\n     * @param _dest Destination location.\\n     * @param _src Source location.\\n     * @param _len Length of memory to copy.\\n     */\\n    function _memcpy(\\n        uint256 _dest,\\n        uint256 _src,\\n        uint256 _len\\n    ) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256**(32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * Flattens a list of byte strings into one byte string.\\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\\n     * @param _list List of byte strings to flatten.\\n     * @return The flattened byte string.\\n     */\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(flattened, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/trie/Lib_MerkleTrie.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\nimport { Lib_RLPReader } from \\\"../rlp/Lib_RLPReader.sol\\\";\\nimport { Lib_RLPWriter } from \\\"../rlp/Lib_RLPWriter.sol\\\";\\n\\n/**\\n * @title Lib_MerkleTrie\\n */\\nlibrary Lib_MerkleTrie {\\n    /*******************\\n     * Data Structures *\\n     *******************/\\n\\n    enum NodeType {\\n        BranchNode,\\n        ExtensionNode,\\n        LeafNode\\n    }\\n\\n    struct TrieNode {\\n        bytes encoded;\\n        Lib_RLPReader.RLPItem[] decoded;\\n    }\\n\\n    /**********************\\n     * Contract Constants *\\n     **********************/\\n\\n    // TREE_RADIX determines the number of elements per branch node.\\n    uint256 constant TREE_RADIX = 16;\\n    // Branch nodes have TREE_RADIX elements plus an additional `value` slot.\\n    uint256 constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\\n    // Leaf nodes and extension nodes always have two elements, a `path` and a `value`.\\n    uint256 constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\\n\\n    // Prefixes are prepended to the `path` within a leaf or extension node and\\n    // allow us to differentiate between the two node types. `ODD` or `EVEN` is\\n    // determined by the number of nibbles within the unprefixed `path`. If the\\n    // number of nibbles if even, we need to insert an extra padding nibble so\\n    // the resulting prefixed `path` has an even number of nibbles.\\n    uint8 constant PREFIX_EXTENSION_EVEN = 0;\\n    uint8 constant PREFIX_EXTENSION_ODD = 1;\\n    uint8 constant PREFIX_LEAF_EVEN = 2;\\n    uint8 constant PREFIX_LEAF_ODD = 3;\\n\\n    // Just a utility constant. RLP represents `NULL` as 0x80.\\n    bytes1 constant RLP_NULL = bytes1(0x80);\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * @notice Verifies a proof that a given key/value pair is present in the\\n     * Merkle trie.\\n     * @param _key Key of the node to search for, as a hex string.\\n     * @param _value Value of the node to search for, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\\n     * traditional Merkle trees, this proof is executed top-down and consists\\n     * of a list of RLP-encoded nodes that make a path down to the target node.\\n     * @param _root Known root of the Merkle trie. Used to verify that the\\n     * included proof is correctly constructed.\\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\\n     */\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool _verified) {\\n        (bool exists, bytes memory value) = get(_key, _proof, _root);\\n\\n        return (exists && Lib_BytesUtils.equal(_value, value));\\n    }\\n\\n    /**\\n     * @notice Retrieves the value associated with a given key.\\n     * @param _key Key to search for, as hex bytes.\\n     * @param _proof Merkle trie inclusion proof for the key.\\n     * @param _root Known root of the Merkle trie.\\n     * @return _exists Whether or not the key exists.\\n     * @return _value Value of the key if it exists.\\n     */\\n    function get(\\n        bytes memory _key,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool _exists, bytes memory _value) {\\n        TrieNode[] memory proof = _parseProof(_proof);\\n        (uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(\\n            proof,\\n            _key,\\n            _root\\n        );\\n\\n        bool exists = keyRemainder.length == 0;\\n\\n        require(exists || isFinalNode, \\\"Provided proof is invalid.\\\");\\n\\n        bytes memory value = exists ? _getNodeValue(proof[pathLength - 1]) : bytes(\\\"\\\");\\n\\n        return (exists, value);\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * @notice Walks through a proof using a provided key.\\n     * @param _proof Inclusion proof to walk through.\\n     * @param _key Key to use for the walk.\\n     * @param _root Known root of the trie.\\n     * @return _pathLength Length of the final path\\n     * @return _keyRemainder Portion of the key remaining after the walk.\\n     * @return _isFinalNode Whether or not we've hit a dead end.\\n     */\\n    function _walkNodePath(\\n        TrieNode[] memory _proof,\\n        bytes memory _key,\\n        bytes32 _root\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256 _pathLength,\\n            bytes memory _keyRemainder,\\n            bool _isFinalNode\\n        )\\n    {\\n        uint256 pathLength = 0;\\n        bytes memory key = Lib_BytesUtils.toNibbles(_key);\\n\\n        bytes32 currentNodeID = _root;\\n        uint256 currentKeyIndex = 0;\\n        uint256 currentKeyIncrement = 0;\\n        TrieNode memory currentNode;\\n\\n        // Proof is top-down, so we start at the first element (root).\\n        for (uint256 i = 0; i < _proof.length; i++) {\\n            currentNode = _proof[i];\\n            currentKeyIndex += currentKeyIncrement;\\n\\n            // Keep track of the proof elements we actually need.\\n            // It's expensive to resize arrays, so this simply reduces gas costs.\\n            pathLength += 1;\\n\\n            if (currentKeyIndex == 0) {\\n                // First proof element is always the root node.\\n                require(keccak256(currentNode.encoded) == currentNodeID, \\\"Invalid root hash\\\");\\n            } else if (currentNode.encoded.length >= 32) {\\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\\n                require(\\n                    keccak256(currentNode.encoded) == currentNodeID,\\n                    \\\"Invalid large internal hash\\\"\\n                );\\n            } else {\\n                // Nodes smaller than 31 bytes aren't hashed.\\n                require(\\n                    Lib_BytesUtils.toBytes32(currentNode.encoded) == currentNodeID,\\n                    \\\"Invalid internal node hash\\\"\\n                );\\n            }\\n\\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\\n                if (currentKeyIndex == key.length) {\\n                    // We've hit the end of the key\\n                    // meaning the value should be within this branch node.\\n                    break;\\n                } else {\\n                    // We're not at the end of the key yet.\\n                    // Figure out what the next node ID should be and continue.\\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\\n                    Lib_RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\\n                    currentNodeID = _getNodeID(nextNode);\\n                    currentKeyIncrement = 1;\\n                    continue;\\n                }\\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\\n                bytes memory path = _getNodePath(currentNode);\\n                uint8 prefix = uint8(path[0]);\\n                uint8 offset = 2 - (prefix % 2);\\n                bytes memory pathRemainder = Lib_BytesUtils.slice(path, offset);\\n                bytes memory keyRemainder = Lib_BytesUtils.slice(key, currentKeyIndex);\\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\\n\\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\\n                    if (\\n                        pathRemainder.length == sharedNibbleLength &&\\n                        keyRemainder.length == sharedNibbleLength\\n                    ) {\\n                        // The key within this leaf matches our key exactly.\\n                        // Increment the key index to reflect that we have no remainder.\\n                        currentKeyIndex += sharedNibbleLength;\\n                    }\\n\\n                    // We've hit a leaf node, so our next node should be NULL.\\n                    currentNodeID = bytes32(RLP_NULL);\\n                    break;\\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\\n                    if (sharedNibbleLength != pathRemainder.length) {\\n                        // Our extension node is not identical to the remainder.\\n                        // We've hit the end of this path\\n                        // updates will need to modify this extension.\\n                        currentNodeID = bytes32(RLP_NULL);\\n                        break;\\n                    } else {\\n                        // Our extension shares some nibbles.\\n                        // Carry on to the next node.\\n                        currentNodeID = _getNodeID(currentNode.decoded[1]);\\n                        currentKeyIncrement = sharedNibbleLength;\\n                        continue;\\n                    }\\n                } else {\\n                    revert(\\\"Received a node with an unknown prefix\\\");\\n                }\\n            } else {\\n                revert(\\\"Received an unparseable node.\\\");\\n            }\\n        }\\n\\n        // If our node ID is NULL, then we're at a dead end.\\n        bool isFinalNode = currentNodeID == bytes32(RLP_NULL);\\n        return (pathLength, Lib_BytesUtils.slice(key, currentKeyIndex), isFinalNode);\\n    }\\n\\n    /**\\n     * @notice Parses an RLP-encoded proof into something more useful.\\n     * @param _proof RLP-encoded proof to parse.\\n     * @return _parsed Proof parsed into easily accessible structs.\\n     */\\n    function _parseProof(bytes memory _proof) private pure returns (TrieNode[] memory _parsed) {\\n        Lib_RLPReader.RLPItem[] memory nodes = Lib_RLPReader.readList(_proof);\\n        TrieNode[] memory proof = new TrieNode[](nodes.length);\\n\\n        for (uint256 i = 0; i < nodes.length; i++) {\\n            bytes memory encoded = Lib_RLPReader.readBytes(nodes[i]);\\n            proof[i] = TrieNode({ encoded: encoded, decoded: Lib_RLPReader.readList(encoded) });\\n        }\\n\\n        return proof;\\n    }\\n\\n    /**\\n     * @notice Picks out the ID for a node. Node ID is referred to as the\\n     * \\\"hash\\\" within the specification, but nodes < 32 bytes are not actually\\n     * hashed.\\n     * @param _node Node to pull an ID for.\\n     * @return _nodeID ID for the node, depending on the size of its contents.\\n     */\\n    function _getNodeID(Lib_RLPReader.RLPItem memory _node) private pure returns (bytes32 _nodeID) {\\n        bytes memory nodeID;\\n\\n        if (_node.length < 32) {\\n            // Nodes smaller than 32 bytes are RLP encoded.\\n            nodeID = Lib_RLPReader.readRawBytes(_node);\\n        } else {\\n            // Nodes 32 bytes or larger are hashed.\\n            nodeID = Lib_RLPReader.readBytes(_node);\\n        }\\n\\n        return Lib_BytesUtils.toBytes32(nodeID);\\n    }\\n\\n    /**\\n     * @notice Gets the path for a leaf or extension node.\\n     * @param _node Node to get a path for.\\n     * @return _path Node path, converted to an array of nibbles.\\n     */\\n    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory _path) {\\n        return Lib_BytesUtils.toNibbles(Lib_RLPReader.readBytes(_node.decoded[0]));\\n    }\\n\\n    /**\\n     * @notice Gets the path for a node.\\n     * @param _node Node to get a value for.\\n     * @return _value Node value, as hex bytes.\\n     */\\n    function _getNodeValue(TrieNode memory _node) private pure returns (bytes memory _value) {\\n        return Lib_RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);\\n    }\\n\\n    /**\\n     * @notice Utility; determines the number of nibbles shared between two\\n     * nibble arrays.\\n     * @param _a First nibble array.\\n     * @param _b Second nibble array.\\n     * @return _shared Number of shared nibbles.\\n     */\\n    function _getSharedNibbleLength(bytes memory _a, bytes memory _b)\\n        private\\n        pure\\n        returns (uint256 _shared)\\n    {\\n        uint256 i = 0;\\n        while (_a.length > i && _b.length > i && _a[i] == _b[i]) {\\n            i++;\\n        }\\n        return i;\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/trie/Lib_SecureMerkleTrie.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_MerkleTrie } from \\\"./Lib_MerkleTrie.sol\\\";\\n\\n/**\\n * @title Lib_SecureMerkleTrie\\n */\\nlibrary Lib_SecureMerkleTrie {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * @notice Verifies a proof that a given key/value pair is present in the\\n     * Merkle trie.\\n     * @param _key Key of the node to search for, as a hex string.\\n     * @param _value Value of the node to search for, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\\n     * traditional Merkle trees, this proof is executed top-down and consists\\n     * of a list of RLP-encoded nodes that make a path down to the target node.\\n     * @param _root Known root of the Merkle trie. Used to verify that the\\n     * included proof is correctly constructed.\\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\\n     */\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool _verified) {\\n        bytes memory key = _getSecureKey(_key);\\n        return Lib_MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\\n    }\\n\\n    /**\\n     * @notice Retrieves the value associated with a given key.\\n     * @param _key Key to search for, as hex bytes.\\n     * @param _proof Merkle trie inclusion proof for the key.\\n     * @param _root Known root of the Merkle trie.\\n     * @return _exists Whether or not the key exists.\\n     * @return _value Value of the key if it exists.\\n     */\\n    function get(\\n        bytes memory _key,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) internal pure returns (bool _exists, bytes memory _value) {\\n        bytes memory key = _getSecureKey(_key);\\n        return Lib_MerkleTrie.get(key, _proof, _root);\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Computes the secure counterpart to a key.\\n     * @param _key Key to get a secure key from.\\n     * @return _secureKey Secure version of the key.\\n     */\\n    function _getSecureKey(bytes memory _key) private pure returns (bytes memory _secureKey) {\\n        return abi.encodePacked(keccak256(_key));\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/utils/Lib_Buffer.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_Buffer\\n * @dev This library implements a bytes32 storage array with some additional gas-optimized\\n * functionality. In particular, it encodes its length as a uint40, and tightly packs this with an\\n * overwritable \\\"extra data\\\" field so we can store more information with a single SSTORE.\\n */\\nlibrary Lib_Buffer {\\n    /*************\\n     * Libraries *\\n     *************/\\n\\n    using Lib_Buffer for Buffer;\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct Buffer {\\n        bytes32 context;\\n        mapping(uint256 => bytes32) buf;\\n    }\\n\\n    struct BufferContext {\\n        // Stores the length of the array. Uint40 is way more elements than we'll ever reasonably\\n        // need in an array and we get an extra 27 bytes of extra data to play with.\\n        uint40 length;\\n        // Arbitrary extra data that can be modified whenever the length is updated. Useful for\\n        // squeezing out some gas optimizations.\\n        bytes27 extraData;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Pushes a single element to the buffer.\\n     * @param _self Buffer to access.\\n     * @param _value Value to push to the buffer.\\n     * @param _extraData Global extra data.\\n     */\\n    function push(\\n        Buffer storage _self,\\n        bytes32 _value,\\n        bytes27 _extraData\\n    ) internal {\\n        BufferContext memory ctx = _self.getContext();\\n\\n        _self.buf[ctx.length] = _value;\\n\\n        // Bump the global index and insert our extra data, then save the context.\\n        ctx.length++;\\n        ctx.extraData = _extraData;\\n        _self.setContext(ctx);\\n    }\\n\\n    /**\\n     * Pushes a single element to the buffer.\\n     * @param _self Buffer to access.\\n     * @param _value Value to push to the buffer.\\n     */\\n    function push(Buffer storage _self, bytes32 _value) internal {\\n        BufferContext memory ctx = _self.getContext();\\n\\n        _self.push(_value, ctx.extraData);\\n    }\\n\\n    /**\\n     * Retrieves an element from the buffer.\\n     * @param _self Buffer to access.\\n     * @param _index Element index to retrieve.\\n     * @return Value of the element at the given index.\\n     */\\n    function get(Buffer storage _self, uint256 _index) internal view returns (bytes32) {\\n        BufferContext memory ctx = _self.getContext();\\n\\n        require(_index < ctx.length, \\\"Index out of bounds.\\\");\\n\\n        return _self.buf[_index];\\n    }\\n\\n    /**\\n     * Deletes all elements after (and including) a given index.\\n     * @param _self Buffer to access.\\n     * @param _index Index of the element to delete from (inclusive).\\n     * @param _extraData Optional global extra data.\\n     */\\n    function deleteElementsAfterInclusive(\\n        Buffer storage _self,\\n        uint40 _index,\\n        bytes27 _extraData\\n    ) internal {\\n        BufferContext memory ctx = _self.getContext();\\n\\n        require(_index < ctx.length, \\\"Index out of bounds.\\\");\\n\\n        // Set our length and extra data, save the context.\\n        ctx.length = _index;\\n        ctx.extraData = _extraData;\\n        _self.setContext(ctx);\\n    }\\n\\n    /**\\n     * Deletes all elements after (and including) a given index.\\n     * @param _self Buffer to access.\\n     * @param _index Index of the element to delete from (inclusive).\\n     */\\n    function deleteElementsAfterInclusive(Buffer storage _self, uint40 _index) internal {\\n        BufferContext memory ctx = _self.getContext();\\n        _self.deleteElementsAfterInclusive(_index, ctx.extraData);\\n    }\\n\\n    /**\\n     * Retrieves the current global index.\\n     * @param _self Buffer to access.\\n     * @return Current global index.\\n     */\\n    function getLength(Buffer storage _self) internal view returns (uint40) {\\n        BufferContext memory ctx = _self.getContext();\\n        return ctx.length;\\n    }\\n\\n    /**\\n     * Changes current global extra data.\\n     * @param _self Buffer to access.\\n     * @param _extraData New global extra data.\\n     */\\n    function setExtraData(Buffer storage _self, bytes27 _extraData) internal {\\n        BufferContext memory ctx = _self.getContext();\\n        ctx.extraData = _extraData;\\n        _self.setContext(ctx);\\n    }\\n\\n    /**\\n     * Retrieves the current global extra data.\\n     * @param _self Buffer to access.\\n     * @return Current global extra data.\\n     */\\n    function getExtraData(Buffer storage _self) internal view returns (bytes27) {\\n        BufferContext memory ctx = _self.getContext();\\n        return ctx.extraData;\\n    }\\n\\n    /**\\n     * Sets the current buffer context.\\n     * @param _self Buffer to access.\\n     * @param _ctx Current buffer context.\\n     */\\n    function setContext(Buffer storage _self, BufferContext memory _ctx) internal {\\n        bytes32 context;\\n        uint40 length = _ctx.length;\\n        bytes27 extraData = _ctx.extraData;\\n        assembly {\\n            context := length\\n            context := or(context, extraData)\\n        }\\n\\n        if (_self.context != context) {\\n            _self.context = context;\\n        }\\n    }\\n\\n    /**\\n     * Retrieves the current buffer context.\\n     * @param _self Buffer to access.\\n     * @return Current buffer context.\\n     */\\n    function getContext(Buffer storage _self) internal view returns (BufferContext memory) {\\n        bytes32 context = _self.context;\\n        uint40 length;\\n        bytes27 extraData;\\n        assembly {\\n            length := and(\\n                context,\\n                0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF\\n            )\\n            extraData := and(\\n                context,\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000\\n            )\\n        }\\n\\n        return BufferContext({ length: length, extraData: extraData });\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/utils/Lib_Bytes32Utils.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_Byte32Utils\\n */\\nlibrary Lib_Bytes32Utils {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to \\\"true.\\\"\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as a boolean.\\n     */\\n    function toBool(bytes32 _in) internal pure returns (bool) {\\n        return _in != 0;\\n    }\\n\\n    /**\\n     * Converts a boolean to a bytes32 value.\\n     * @param _in Input boolean value.\\n     * @return Boolean as a bytes32.\\n     */\\n    function fromBool(bool _in) internal pure returns (bytes32) {\\n        return bytes32(uint256(_in ? 1 : 0));\\n    }\\n\\n    /**\\n     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as an address.\\n     */\\n    function toAddress(bytes32 _in) internal pure returns (address) {\\n        return address(uint160(uint256(_in)));\\n    }\\n\\n    /**\\n     * Converts an address to a bytes32.\\n     * @param _in Input address value.\\n     * @return Address as a bytes32.\\n     */\\n    function fromAddress(address _in) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(_in)));\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/utils/Lib_BytesUtils.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_BytesUtils\\n */\\nlibrary Lib_BytesUtils {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\\n        if (_start >= _bytes.length) {\\n            return bytes(\\\"\\\");\\n        }\\n\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {\\n        if (_bytes.length < 32) {\\n            bytes32 ret;\\n            assembly {\\n                ret := mload(add(_bytes, 32))\\n            }\\n            return ret;\\n        }\\n\\n        return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\\n    }\\n\\n    function toUint256(bytes memory _bytes) internal pure returns (uint256) {\\n        return uint256(toBytes32(_bytes));\\n    }\\n\\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n        bytes memory nibbles = new bytes(_bytes.length * 2);\\n\\n        for (uint256 i = 0; i < _bytes.length; i++) {\\n            nibbles[i * 2] = _bytes[i] >> 4;\\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\\n        }\\n\\n        return nibbles;\\n    }\\n\\n    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n        bytes memory ret = new bytes(_bytes.length / 2);\\n\\n        for (uint256 i = 0; i < ret.length; i++) {\\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/utils/Lib_MerkleTree.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_MerkleTree\\n * @author River Keefer\\n */\\nlibrary Lib_MerkleTree {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Calculates a merkle root for a list of 32-byte leaf hashes.  WARNING: If the number\\n     * of leaves passed in is not a power of two, it pads out the tree with zero hashes.\\n     * If you do not know the original length of elements for the tree you are verifying, then\\n     * this may allow empty leaves past _elements.length to pass a verification check down the line.\\n     * Note that the _elements argument is modified, therefore it must not be used again afterwards\\n     * @param _elements Array of hashes from which to generate a merkle root.\\n     * @return Merkle root of the leaves, with zero hashes for non-powers-of-two (see above).\\n     */\\n    function getMerkleRoot(bytes32[] memory _elements) internal pure returns (bytes32) {\\n        require(_elements.length > 0, \\\"Lib_MerkleTree: Must provide at least one leaf hash.\\\");\\n\\n        if (_elements.length == 1) {\\n            return _elements[0];\\n        }\\n\\n        uint256[16] memory defaults = [\\n            0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563,\\n            0x633dc4d7da7256660a892f8f1604a44b5432649cc8ec5cb3ced4c4e6ac94dd1d,\\n            0x890740a8eb06ce9be422cb8da5cdafc2b58c0a5e24036c578de2a433c828ff7d,\\n            0x3b8ec09e026fdc305365dfc94e189a81b38c7597b3d941c279f042e8206e0bd8,\\n            0xecd50eee38e386bd62be9bedb990706951b65fe053bd9d8a521af753d139e2da,\\n            0xdefff6d330bb5403f63b14f33b578274160de3a50df4efecf0e0db73bcdd3da5,\\n            0x617bdd11f7c0a11f49db22f629387a12da7596f9d1704d7465177c63d88ec7d7,\\n            0x292c23a9aa1d8bea7e2435e555a4a60e379a5a35f3f452bae60121073fb6eead,\\n            0xe1cea92ed99acdcb045a6726b2f87107e8a61620a232cf4d7d5b5766b3952e10,\\n            0x7ad66c0a68c72cb89e4fb4303841966e4062a76ab97451e3b9fb526a5ceb7f82,\\n            0xe026cc5a4aed3c22a58cbd3d2ac754c9352c5436f638042dca99034e83636516,\\n            0x3d04cffd8b46a874edf5cfae63077de85f849a660426697b06a829c70dd1409c,\\n            0xad676aa337a485e4728a0b240d92b3ef7b3c372d06d189322bfd5f61f1e7203e,\\n            0xa2fca4a49658f9fab7aa63289c91b7c7b6c832a6d0e69334ff5b0a3483d09dab,\\n            0x4ebfd9cd7bca2505f7bef59cc1c12ecc708fff26ae4af19abe852afe9e20c862,\\n            0x2def10d13dd169f550f578bda343d9717a138562e0093b380a1120789d53cf10\\n        ];\\n\\n        // Reserve memory space for our hashes.\\n        bytes memory buf = new bytes(64);\\n\\n        // We'll need to keep track of left and right siblings.\\n        bytes32 leftSibling;\\n        bytes32 rightSibling;\\n\\n        // Number of non-empty nodes at the current depth.\\n        uint256 rowSize = _elements.length;\\n\\n        // Current depth, counting from 0 at the leaves\\n        uint256 depth = 0;\\n\\n        // Common sub-expressions\\n        uint256 halfRowSize; // rowSize / 2\\n        bool rowSizeIsOdd; // rowSize % 2 == 1\\n\\n        while (rowSize > 1) {\\n            halfRowSize = rowSize / 2;\\n            rowSizeIsOdd = rowSize % 2 == 1;\\n\\n            for (uint256 i = 0; i < halfRowSize; i++) {\\n                leftSibling = _elements[(2 * i)];\\n                rightSibling = _elements[(2 * i) + 1];\\n                assembly {\\n                    mstore(add(buf, 32), leftSibling)\\n                    mstore(add(buf, 64), rightSibling)\\n                }\\n\\n                _elements[i] = keccak256(buf);\\n            }\\n\\n            if (rowSizeIsOdd) {\\n                leftSibling = _elements[rowSize - 1];\\n                rightSibling = bytes32(defaults[depth]);\\n                assembly {\\n                    mstore(add(buf, 32), leftSibling)\\n                    mstore(add(buf, 64), rightSibling)\\n                }\\n\\n                _elements[halfRowSize] = keccak256(buf);\\n            }\\n\\n            rowSize = halfRowSize + (rowSizeIsOdd ? 1 : 0);\\n            depth++;\\n        }\\n\\n        return _elements[0];\\n    }\\n\\n    /**\\n     * Verifies a merkle branch for the given leaf hash.  Assumes the original length\\n     * of leaves generated is a known, correct input, and does not return true for indices\\n     * extending past that index (even if _siblings would be otherwise valid.)\\n     * @param _root The Merkle root to verify against.\\n     * @param _leaf The leaf hash to verify inclusion of.\\n     * @param _index The index in the tree of this leaf.\\n     * @param _siblings Array of sibline nodes in the inclusion proof, starting from depth 0\\n     * (bottom of the tree).\\n     * @param _totalLeaves The total number of leaves originally passed into.\\n     * @return Whether or not the merkle branch and leaf passes verification.\\n     */\\n    function verify(\\n        bytes32 _root,\\n        bytes32 _leaf,\\n        uint256 _index,\\n        bytes32[] memory _siblings,\\n        uint256 _totalLeaves\\n    ) internal pure returns (bool) {\\n        require(_totalLeaves > 0, \\\"Lib_MerkleTree: Total leaves must be greater than zero.\\\");\\n\\n        require(_index < _totalLeaves, \\\"Lib_MerkleTree: Index out of bounds.\\\");\\n\\n        require(\\n            _siblings.length == _ceilLog2(_totalLeaves),\\n            \\\"Lib_MerkleTree: Total siblings does not correctly correspond to total leaves.\\\"\\n        );\\n\\n        bytes32 computedRoot = _leaf;\\n\\n        for (uint256 i = 0; i < _siblings.length; i++) {\\n            if ((_index & 1) == 1) {\\n                computedRoot = keccak256(abi.encodePacked(_siblings[i], computedRoot));\\n            } else {\\n                computedRoot = keccak256(abi.encodePacked(computedRoot, _siblings[i]));\\n            }\\n\\n            _index >>= 1;\\n        }\\n\\n        return _root == computedRoot;\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Calculates the integer ceiling of the log base 2 of an input.\\n     * @param _in Unsigned input to calculate the log.\\n     * @return ceil(log_base_2(_in))\\n     */\\n    function _ceilLog2(uint256 _in) private pure returns (uint256) {\\n        require(_in > 0, \\\"Lib_MerkleTree: Cannot compute ceil(log_2) of 0.\\\");\\n\\n        if (_in == 1) {\\n            return 0;\\n        }\\n\\n        // Find the highest set bit (will be floor(log_2)).\\n        // Borrowed with <3 from https://github.com/ethereum/solidity-examples\\n        uint256 val = _in;\\n        uint256 highest = 0;\\n        for (uint256 i = 128; i >= 1; i >>= 1) {\\n            if (val & (((uint256(1) << i) - 1) << i) != 0) {\\n                highest += i;\\n                val >>= i;\\n            }\\n        }\\n\\n        // Increment by one if this is not a perfect logarithm.\\n        if ((uint256(1) << highest) != _in) {\\n            highest += 1;\\n        }\\n\\n        return highest;\\n    }\\n}\\n\"\n    },\n    \"contracts/standards/AddressAliasHelper.sol\": {\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.7;\\n\\nlibrary AddressAliasHelper {\\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\\n\\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\\n    /// the inbox to the msg.sender viewed in the L2\\n    /// @param l1Address the address in the L1 that triggered the tx to L2\\n    /// @return l2Address L2 address as viewed in msg.sender\\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\\n        unchecked {\\n            l2Address = address(uint160(l1Address) + offset);\\n        }\\n    }\\n\\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n    /// address in the L1 that submitted a tx to the inbox\\n    /// @param l2Address L2 address as viewed in msg.sender\\n    /// @return l1Address the address in the L1 that triggered the tx to L2\\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\\n        unchecked {\\n            l1Address = address(uint160(l2Address) - offset);\\n        }\\n    }\\n}\\n\"\n    },\n    \"contracts/standards/IL2StandardERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface IL2StandardERC20 is IERC20, IERC165 {\\n    function l1Token() external returns (address);\\n\\n    function mint(address _to, uint256 _amount) external;\\n\\n    function burn(address _from, uint256 _amount) external;\\n\\n    event Mint(address indexed _account, uint256 _amount);\\n    event Burn(address indexed _account, uint256 _amount);\\n}\\n\"\n    },\n    \"contracts/standards/L2StandardERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport { ERC20 } from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./IL2StandardERC20.sol\\\";\\n\\ncontract L2StandardERC20 is IL2StandardERC20, ERC20 {\\n    address public l1Token;\\n    address public l2Bridge;\\n\\n    /**\\n     * @param _l2Bridge Address of the L2 standard bridge.\\n     * @param _l1Token Address of the corresponding L1 token.\\n     * @param _name ERC20 name.\\n     * @param _symbol ERC20 symbol.\\n     */\\n    constructor(\\n        address _l2Bridge,\\n        address _l1Token,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol) {\\n        l1Token = _l1Token;\\n        l2Bridge = _l2Bridge;\\n    }\\n\\n    modifier onlyL2Bridge() {\\n        require(msg.sender == l2Bridge, \\\"Only L2 Bridge can mint and burn\\\");\\n        _;\\n    }\\n\\n    // slither-disable-next-line external-function\\n    function supportsInterface(bytes4 _interfaceId) public pure returns (bool) {\\n        bytes4 firstSupportedInterface = bytes4(keccak256(\\\"supportsInterface(bytes4)\\\")); // ERC165\\n        bytes4 secondSupportedInterface = IL2StandardERC20.l1Token.selector ^\\n            IL2StandardERC20.mint.selector ^\\n            IL2StandardERC20.burn.selector;\\n        return _interfaceId == firstSupportedInterface || _interfaceId == secondSupportedInterface;\\n    }\\n\\n    // slither-disable-next-line external-function\\n    function mint(address _to, uint256 _amount) public virtual onlyL2Bridge {\\n        _mint(_to, _amount);\\n\\n        emit Mint(_to, _amount);\\n    }\\n\\n    // slither-disable-next-line external-function\\n    function burn(address _from, uint256 _amount) public virtual onlyL2Bridge {\\n        _burn(_from, _amount);\\n\\n        emit Burn(_from, _amount);\\n    }\\n}\\n\"\n    },\n    \"contracts/test-helpers/FailingReceiver.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.9;\\n\\ncontract FailingReceiver {\\n    receive() external payable {\\n        require(false, \\\"FailingReceiver\\\");\\n    }\\n}\\n\"\n    },\n    \"contracts/test-helpers/TestERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport { ERC20 } from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract TestERC20 is ERC20 {\\n    constructor() ERC20(\\\"TEST\\\", \\\"TST\\\") {}\\n\\n    function mint(address to, uint256 value) public {\\n        _mint(to, value);\\n    }\\n}\\n\"\n    },\n    \"contracts/test-libraries/bridge/TestLib_CrossDomainUtils.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_CrossDomainUtils } from \\\"../../libraries/bridge/Lib_CrossDomainUtils.sol\\\";\\n\\n/**\\n * @title TestLib_CrossDomainUtils\\n */\\nlibrary TestLib_CrossDomainUtils {\\n    function encodeXDomainCalldata(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _messageNonce\\n    ) public pure returns (bytes memory) {\\n        return\\n            Lib_CrossDomainUtils.encodeXDomainCalldata(_target, _sender, _message, _messageNonce);\\n    }\\n}\\n\"\n    },\n    \"contracts/test-libraries/codec/TestLib_OVMCodec.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/**\\n * @title TestLib_OVMCodec\\n */\\ncontract TestLib_OVMCodec {\\n    function encodeTransaction(Lib_OVMCodec.Transaction memory _transaction)\\n        public\\n        pure\\n        returns (bytes memory _encoded)\\n    {\\n        return Lib_OVMCodec.encodeTransaction(_transaction);\\n    }\\n\\n    function hashTransaction(Lib_OVMCodec.Transaction memory _transaction)\\n        public\\n        pure\\n        returns (bytes32 _hash)\\n    {\\n        return Lib_OVMCodec.hashTransaction(_transaction);\\n    }\\n}\\n\"\n    },\n    \"contracts/test-libraries/rlp/TestLib_RLPReader.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_RLPReader } from \\\"../../libraries/rlp/Lib_RLPReader.sol\\\";\\n\\n/**\\n * @title TestLib_RLPReader\\n */\\ncontract TestLib_RLPReader {\\n    function readList(bytes memory _in) public pure returns (bytes[] memory) {\\n        Lib_RLPReader.RLPItem[] memory decoded = Lib_RLPReader.readList(_in);\\n        bytes[] memory out = new bytes[](decoded.length);\\n        for (uint256 i = 0; i < out.length; i++) {\\n            out[i] = Lib_RLPReader.readRawBytes(decoded[i]);\\n        }\\n        return out;\\n    }\\n\\n    function readString(bytes memory _in) public pure returns (string memory) {\\n        return Lib_RLPReader.readString(_in);\\n    }\\n\\n    function readBytes(bytes memory _in) public pure returns (bytes memory) {\\n        return Lib_RLPReader.readBytes(_in);\\n    }\\n\\n    function readBytes32(bytes memory _in) public pure returns (bytes32) {\\n        return Lib_RLPReader.readBytes32(_in);\\n    }\\n\\n    function readUint256(bytes memory _in) public pure returns (uint256) {\\n        return Lib_RLPReader.readUint256(_in);\\n    }\\n\\n    function readBool(bytes memory _in) public pure returns (bool) {\\n        return Lib_RLPReader.readBool(_in);\\n    }\\n\\n    function readAddress(bytes memory _in) public pure returns (address) {\\n        return Lib_RLPReader.readAddress(_in);\\n    }\\n}\\n\"\n    },\n    \"contracts/test-libraries/rlp/TestLib_RLPWriter.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_RLPWriter } from \\\"../../libraries/rlp/Lib_RLPWriter.sol\\\";\\nimport { TestERC20 } from \\\"../../test-helpers/TestERC20.sol\\\";\\n\\n/**\\n * @title TestLib_RLPWriter\\n */\\ncontract TestLib_RLPWriter {\\n    function writeBytes(bytes memory _in) public pure returns (bytes memory _out) {\\n        return Lib_RLPWriter.writeBytes(_in);\\n    }\\n\\n    function writeList(bytes[] memory _in) public pure returns (bytes memory _out) {\\n        return Lib_RLPWriter.writeList(_in);\\n    }\\n\\n    function writeString(string memory _in) public pure returns (bytes memory _out) {\\n        return Lib_RLPWriter.writeString(_in);\\n    }\\n\\n    function writeAddress(address _in) public pure returns (bytes memory _out) {\\n        return Lib_RLPWriter.writeAddress(_in);\\n    }\\n\\n    function writeUint(uint256 _in) public pure returns (bytes memory _out) {\\n        return Lib_RLPWriter.writeUint(_in);\\n    }\\n\\n    function writeBool(bool _in) public pure returns (bytes memory _out) {\\n        return Lib_RLPWriter.writeBool(_in);\\n    }\\n\\n    function writeAddressWithTaintedMemory(address _in) public returns (bytes memory _out) {\\n        new TestERC20();\\n        return Lib_RLPWriter.writeAddress(_in);\\n    }\\n}\\n\"\n    },\n    \"contracts/test-libraries/standards/TestLib_AddressAliasHelper.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/* Library Imports */\\nimport { AddressAliasHelper } from \\\"../../standards/AddressAliasHelper.sol\\\";\\n\\n/**\\n * @title TestLib_AddressAliasHelper\\n */\\ncontract TestLib_AddressAliasHelper {\\n    function applyL1ToL2Alias(address _address) public pure returns (address) {\\n        return AddressAliasHelper.applyL1ToL2Alias(_address);\\n    }\\n\\n    function undoL1ToL2Alias(address _address) public pure returns (address) {\\n        return AddressAliasHelper.undoL1ToL2Alias(_address);\\n    }\\n}\\n\"\n    },\n    \"contracts/test-libraries/trie/TestLib_MerkleTrie.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_MerkleTrie } from \\\"../../libraries/trie/Lib_MerkleTrie.sol\\\";\\n\\n/**\\n * @title TestLib_MerkleTrie\\n */\\ncontract TestLib_MerkleTrie {\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) public pure returns (bool) {\\n        return Lib_MerkleTrie.verifyInclusionProof(_key, _value, _proof, _root);\\n    }\\n\\n    function get(\\n        bytes memory _key,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) public pure returns (bool, bytes memory) {\\n        return Lib_MerkleTrie.get(_key, _proof, _root);\\n    }\\n}\\n\"\n    },\n    \"contracts/test-libraries/trie/TestLib_SecureMerkleTrie.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_SecureMerkleTrie } from \\\"../../libraries/trie/Lib_SecureMerkleTrie.sol\\\";\\n\\n/**\\n * @title TestLib_SecureMerkleTrie\\n */\\ncontract TestLib_SecureMerkleTrie {\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) public pure returns (bool) {\\n        return Lib_SecureMerkleTrie.verifyInclusionProof(_key, _value, _proof, _root);\\n    }\\n\\n    function get(\\n        bytes memory _key,\\n        bytes memory _proof,\\n        bytes32 _root\\n    ) public pure returns (bool, bytes memory) {\\n        return Lib_SecureMerkleTrie.get(_key, _proof, _root);\\n    }\\n}\\n\"\n    },\n    \"contracts/test-libraries/utils/TestLib_Buffer.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_Buffer } from \\\"../../libraries/utils/Lib_Buffer.sol\\\";\\n\\n/**\\n * @title TestLib_Buffer\\n */\\ncontract TestLib_Buffer {\\n    using Lib_Buffer for Lib_Buffer.Buffer;\\n    using Lib_Buffer for Lib_Buffer.BufferContext;\\n\\n    Lib_Buffer.Buffer internal buf;\\n\\n    function push(bytes32 _value, bytes27 _extraData) public {\\n        buf.push(_value, _extraData);\\n    }\\n\\n    function push(bytes32 _value) public {\\n        buf.push(_value);\\n    }\\n\\n    function get(uint256 _index) public view returns (bytes32) {\\n        return buf.get(_index);\\n    }\\n\\n    function deleteElementsAfterInclusive(uint40 _index) public {\\n        return buf.deleteElementsAfterInclusive(_index);\\n    }\\n\\n    function deleteElementsAfterInclusive(uint40 _index, bytes27 _extraData) public {\\n        return buf.deleteElementsAfterInclusive(_index, _extraData);\\n    }\\n\\n    function getLength() public view returns (uint40) {\\n        return buf.getLength();\\n    }\\n\\n    function setExtraData(bytes27 _extraData) public {\\n        return buf.setExtraData(_extraData);\\n    }\\n\\n    function getExtraData() public view returns (bytes27) {\\n        return buf.getExtraData();\\n    }\\n\\n    function getContext() public view returns (Lib_Buffer.BufferContext memory) {\\n        return buf.getContext();\\n    }\\n\\n    function setContext(uint40 _index, bytes27 _extraData) public {\\n        Lib_Buffer.BufferContext memory _ctx = Lib_Buffer.BufferContext({\\n            length: _index,\\n            extraData: _extraData\\n        });\\n        return buf.setContext(_ctx);\\n    }\\n}\\n\"\n    },\n    \"contracts/test-libraries/utils/TestLib_Bytes32Utils.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_Bytes32Utils } from \\\"../../libraries/utils/Lib_Bytes32Utils.sol\\\";\\n\\n/**\\n * @title TestLib_Byte32Utils\\n */\\ncontract TestLib_Bytes32Utils {\\n    function toBool(bytes32 _in) public pure returns (bool _out) {\\n        return Lib_Bytes32Utils.toBool(_in);\\n    }\\n\\n    function fromBool(bool _in) public pure returns (bytes32 _out) {\\n        return Lib_Bytes32Utils.fromBool(_in);\\n    }\\n\\n    function toAddress(bytes32 _in) public pure returns (address _out) {\\n        return Lib_Bytes32Utils.toAddress(_in);\\n    }\\n\\n    function fromAddress(address _in) public pure returns (bytes32 _out) {\\n        return Lib_Bytes32Utils.fromAddress(_in);\\n    }\\n}\\n\"\n    },\n    \"contracts/test-libraries/utils/TestLib_BytesUtils.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_BytesUtils } from \\\"../../libraries/utils/Lib_BytesUtils.sol\\\";\\nimport { TestERC20 } from \\\"../../test-helpers/TestERC20.sol\\\";\\n\\n/**\\n * @title TestLib_BytesUtils\\n */\\ncontract TestLib_BytesUtils {\\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encodePacked(_preBytes, _postBytes);\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) public pure returns (bytes memory) {\\n        return Lib_BytesUtils.slice(_bytes, _start, _length);\\n    }\\n\\n    function toBytes32(bytes memory _bytes) public pure returns (bytes32) {\\n        return Lib_BytesUtils.toBytes32(_bytes);\\n    }\\n\\n    function toUint256(bytes memory _bytes) public pure returns (uint256) {\\n        return Lib_BytesUtils.toUint256(_bytes);\\n    }\\n\\n    function toNibbles(bytes memory _bytes) public pure returns (bytes memory) {\\n        return Lib_BytesUtils.toNibbles(_bytes);\\n    }\\n\\n    function fromNibbles(bytes memory _bytes) public pure returns (bytes memory) {\\n        return Lib_BytesUtils.fromNibbles(_bytes);\\n    }\\n\\n    function equal(bytes memory _bytes, bytes memory _other) public pure returns (bool) {\\n        return Lib_BytesUtils.equal(_bytes, _other);\\n    }\\n\\n    function sliceWithTaintedMemory(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) public returns (bytes memory) {\\n        new TestERC20();\\n        return Lib_BytesUtils.slice(_bytes, _start, _length);\\n    }\\n}\\n\"\n    },\n    \"contracts/test-libraries/utils/TestLib_MerkleTree.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_MerkleTree } from \\\"../../libraries/utils/Lib_MerkleTree.sol\\\";\\n\\n/**\\n * @title TestLib_MerkleTree\\n */\\ncontract TestLib_MerkleTree {\\n    function getMerkleRoot(bytes32[] memory _elements) public pure returns (bytes32) {\\n        return Lib_MerkleTree.getMerkleRoot(_elements);\\n    }\\n\\n    function verify(\\n        bytes32 _root,\\n        bytes32 _leaf,\\n        uint256 _index,\\n        bytes32[] memory _siblings,\\n        uint256 _totalLeaves\\n    ) public pure returns (bool) {\\n        return Lib_MerkleTree.verify(_root, _leaf, _index, _siblings, _totalLeaves);\\n    }\\n}\\n\"\n    }\n  },\n  \"settings\": {\n    \"optimizer\": {\n      \"enabled\": true,\n      \"runs\": 10000\n    },\n    \"outputSelection\": {\n      \"*\": {\n        \"*\": [\n          \"abi\",\n          \"evm.bytecode\",\n          \"evm.deployedBytecode\",\n          \"evm.methodIdentifiers\",\n          \"metadata\",\n          \"devdoc\",\n          \"userdoc\",\n          \"storageLayout\",\n          \"evm.gasEstimates\",\n          \"devdoc\",\n          \"userdoc\",\n          \"devdoc\",\n          \"userdoc\"\n        ],\n        \"\": [\n          \"ast\"\n        ]\n      }\n    },\n    \"metadata\": {\n      \"useLiteralContent\": true\n    }\n  }\n}",
      "solcInputHash": "cb7b0250f4993b161ea5042c4fbdf36f",
      "transactionHash": "0x887351cf7bbb89690df28e3b83f53079dac83e9286289db01c26b918aef26c9e",
      "args": [
        "0x21dF544947ba3E8b3c32561399E88B52Dc8b2823",
        "CanonicalTransactionChain"
      ]
    },
    "decoded": {
      "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
      "gasPrice": "1000000007",
      "gasLimit": "946990",
      "to": null,
      "value": "0",
      "nonce": 71,
      "data": "0x60806040523480156200001157600080fd5b50604051620011b3380380620011b3833981016040819052620000349162000129565b600080546001600160a01b0319166001600160a01b0384161790558051620000649060019060208401906200006d565b50505062000266565b8280546200007b9062000229565b90600052602060002090601f0160209004810192826200009f5760008555620000ea565b82601f10620000ba57805160ff1916838001178555620000ea565b82800160010185558215620000ea579182015b82811115620000ea578251825591602001919060010190620000cd565b50620000f8929150620000fc565b5090565b5b80821115620000f85760008155600101620000fd565b634e487b7160e01b600052604160045260246000fd5b600080604083850312156200013d57600080fd5b82516001600160a01b03811681146200015557600080fd5b602084810151919350906001600160401b03808211156200017557600080fd5b818601915086601f8301126200018a57600080fd5b8151818111156200019f576200019f62000113565b604051601f8201601f19908116603f01168101908382118183101715620001ca57620001ca62000113565b816040528281528986848701011115620001e357600080fd5b600093505b82841015620002075784840186015181850187015292850192620001e8565b82841115620002195760008684830101525b8096505050505050509250929050565b600181811c908216806200023e57607f821691505b602082108114156200026057634e487b7160e01b600052602260045260246000fd5b50919050565b610f3d80620002766000396000f3fe608060405234801561001057600080fd5b50600436106100c95760003560e01c8063461a4478116100815780639507d39a1161005b5780639507d39a146101a4578063b298e36b146101b7578063ccf8f969146101ca57600080fd5b8063461a4478146101695780634651d91e1461017c5780638da5cb5b1461018f57600080fd5b80632015276c116100b25780632015276c146100fe57806329061de214610111578063299ca4781461012457600080fd5b8063167fd681146100ce5780631f7b6d32146100e3575b600080fd5b6100e16100dc366004610c59565b6101e9565b005b6100eb61034d565b6040519081526020015b60405180910390f35b6100e161010c366004610c59565b610365565b6100e161011f366004610c85565b61043d565b6000546101449073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100f5565b610144610177366004610cd6565b610517565b6100e161018a366004610da5565b6105c4565b61019761069b565b6040516100f59190610dbe565b6100eb6101b2366004610da5565b610729565b6100e16101c5366004610da5565b61073d565b6101d2610814565b60405164ffffffffff1990911681526020016100f5565b61027c600180546101f990610e31565b80601f016020809104026020016040519081016040528092919081815260200182805461022590610e31565b80156102725780601f1061024757610100808354040283529160200191610272565b820191906000526020600020905b81548152906001019060200180831161025557829003601f168201915b5050505050610517565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461033d57604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e60648201526084015b60405180910390fd5b61034960028383610825565b5050565b6000610359600261090c565b64ffffffffff16905090565b610375600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461043157604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b61034960028383610957565b61044d600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461050957604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b6105146002826109e6565b50565b600080546040517fbf40fac100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091169063bf40fac19061056e908590600401610dbe565b60206040518083038186803b15801561058657600080fd5b505afa15801561059a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105be9190610e85565b92915050565b6105d4600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461069057604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b610514600282610a47565b600180546106a890610e31565b80601f01602080910402602001604051908101604052809291908181526020018280546106d490610e31565b80156107215780601f106106f657610100808354040283529160200191610721565b820191906000526020600020905b81548152906001019060200180831161070457829003601f168201915b505050505081565b60006105be600264ffffffffff8416610aa4565b61074d600180546101f990610e31565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461080957604080517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260248101919091527f436861696e53746f72616765436f6e7461696e65723a2046756e6374696f6e2060448201527f63616e206f6e6c792062652063616c6c656420627920746865206f776e65722e6064820152608401610334565b610514600282610b73565b60006108206002610bd0565b905090565b600061086784604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b9050806000015164ffffffffff168364ffffffffff16106108e4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f496e646578206f7574206f6620626f756e64732e0000000000000000000000006044820152606401610334565b64ffffffffff8316815264ffffffffff19821660208201526109068482610c1e565b50505050565b60008061094f83604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b519392505050565b600061099984604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b805164ffffffffff16600090815260018601602052604090208490558051909150816109c482610ebb565b64ffffffffff1690525064ffffffffff19821660208201526109068482610c1e565b6000610a2883604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b64ffffffffff19831660208201529050610a428382610c1e565b505050565b6000610a8983604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b9050610a42828260200151856108259092919063ffffffff16565b600080610ae784604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b805190915064ffffffffff168310610b5b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f496e646578206f7574206f6620626f756e64732e0000000000000000000000006044820152606401610334565b50506000908152600191909101602052604090205490565b6000610bb583604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b9050610a42828260200151856109579092919063ffffffff16565b600080610c1383604080518082019091526000808252602082015250546040805180820190915264ffffffffff8216815264ffffffffff19909116602082015290565b602001519392505050565b8051602082015183548183179291908314610c37578285555b5050505050565b803564ffffffffff1981168114610c5457600080fd5b919050565b60008060408385031215610c6c57600080fd5b82359150610c7c60208401610c3e565b90509250929050565b600060208284031215610c9757600080fd5b610ca082610c3e565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208284031215610ce857600080fd5b813567ffffffffffffffff80821115610d0057600080fd5b818401915084601f830112610d1457600080fd5b813581811115610d2657610d26610ca7565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715610d6c57610d6c610ca7565b81604052828152876020848701011115610d8557600080fd5b826020860160208301376000928101602001929092525095945050505050565b600060208284031215610db757600080fd5b5035919050565b600060208083528351808285015260005b81811015610deb57858101830151858201604001528201610dcf565b81811115610dfd576000604083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016929092016040019392505050565b600181811c90821680610e4557607f821691505b60208210811415610e7f577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b600060208284031215610e9757600080fd5b815173ffffffffffffffffffffffffffffffffffffffff81168114610ca057600080fd5b600064ffffffffff80831681811415610efd577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600101939250505056fea2646970667358221220e1995ee56c4c5e67de41c56ad510b16704727d3ab1fa5bb2e3c62b0bd7c0597564736f6c6343000809003300000000000000000000000021df544947ba3e8b3c32561399e88b52dc8b28230000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000001943616e6f6e6963616c5472616e73616374696f6e436861696e00000000000000",
      "r": "0xfb07b0d7c9a1401e0c19203f384cdfb0df7569f47f1ba6da28d5309207ec7abc",
      "s": "0x26f5b8af45114e7b0efd9e03e20a9cea779b14512d46ba50daa17a823a710d14",
      "v": 458018,
      "chainId": 228991
    }
  }
}